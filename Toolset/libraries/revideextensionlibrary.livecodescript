script "revideextensionlibrary"
local sExtensions, sExtensionProperties

on revLoadLibrary
   if the target is me then
      insert script of me into back 
   end if
end revLoadLibrary

on revUnloadLibrary
   if the target is me then
      remove script of me from back
   end if
end revUnloadLibrary

# Called at startup. Loads all the extensions ready for use
on revIDEInitialiseExtensions
   # Install extensions that haven't yet been installed
   repeat for each line tExtensionPackage in __extensionPackagePaths()
      revIDEInstallExtension tExtensionPackage
   end repeat
   
   # Load all the extensions ready for use
   __extensionsLoad
end revIDEInitialiseExtensions

# Intalls the extension
on revIDEInstallExtension pExtensionPath, pType, pCallbackObject, pCallbackMessage
   if pExtensionPath begins with "http" or there is a file pExtensionPath then 
      
      # Get the ID of the extension in the cache
      local tCacheIndex
      put __extensionCacheID("package_url",pExtensionPath) into tCacheIndex
      
      if tCacheIndex is empty then
         put __extensionCacheID("download_package_path",pExtensionPath) into tCacheIndex
      end if
      
      # If the extension cache ID couldn't be found, generate a new one
      if tCacheIndex is empty then 
         put the number of elements of sExtensions + 1 into tCacheIndex
      end if
      
      # Add callback data to cache
      __extensionPropertySet tCacheIndex, "callback_target", pCallbackObject
      __extensionPropertySet tCacheIndex, "callback_handler", pCallbackMessage
      __extensionPropertySet tCacheIndex, "name", "New Extension Installing"
      
      # AL-2015-03-06: [[ Bug 14820 ]] Set the type so that the icon is correct while downloading
      __extensionPropertySet tCacheIndex, "type", pType
      
      if pExtensionPath begins with "http" then 
         # Download the package and install
         __extensionPropertySet tCacheIndex, "package_url", pExtensionPath
         __extensionInstallDownload tCacheIndex
      else
         # Package already downloaded - begin installation
         __extensionPropertySet tCacheIndex, "download_package_path", pExtensionPath
         __extensionInstallVerify tCacheIndex
      end if
   else
      # pExtensionPath is not a URL or file on disk
      return __extensionError(tCacheIndex,"Could not install extension. The extension must be a URL to a valid package or a path to a extension package on disk:" && pExtensionPath)
   end if
end revIDEInstallExtension

# Uninstalls the extension
on revIDEUninstallExtension pExtensionTypeID 
   # Start the uninstall process
   if pExtensionTypeID is not a number then
      put __extensionCacheID("name", pExtensionTypeID) into pExtensionTypeID
   end if
   
   __extensionUninstallCheckInUse pExtensionTypeID
end revIDEUninstallExtension

# Returns the extension data
function revIDEExtensions pType, pStatus, pWithoutInvisible
   # No type passed so return all extensions
   
   # Repeat over the extension array looking for elements with matching type
   local tExtensions
   repeat for each key tExtensionKey in sExtensions
      if sExtensions[tExtensionKey]["name"] is empty then 
         delete variable sExtensions[tExtensionKey]
         next repeat
      end if
      if pType is not empty and sExtensions[tExtensionKey]["type"] is not pType then next repeat
      if pStatus is "installed" then
         if sExtensions[tExtensionKey]["status"] is "uninstalled" then
            next repeat
         end if
      else if pStatus is not empty then
         if sExtensions[tExtensionKey]["status"] is not pStatus then 
            next repeat
         end if
      end if
      
      if pWithoutInvisible and not sExtensions[tExtensionKey]["uservisible"] then
         next repeat
      end if
      
      local tIconPath
      if there is not a file sExtensions[tExtensionKey]["icon"] then 
         put revIDEDefaultExtensionIcon(pType) into sExtensions[tExtensionKey]["icon"]
      end if
      
      put sExtensions[tExtensionKey] into tExtensions[sExtensions[tExtensionKey]["name"]]
   end repeat
   return tExtensions
end revIDEExtensions

# Returns the extension data
function revIDEExtensionProperties pTypeID
   return sExtensionProperties[pTypeID]
end revIDEExtensionProperties

function revIDEExtensionPropertiesInfo pTypeId, pOrganise
   local tPropsA, tExtensionPropsInfoA
   put revIDEExtensionProperties(pTypeId) into tPropsA
   
   if pOrganise then
      # If pOrganise is true, organise the property info into the structure that the property 
      #  inspector expects, namely [<section>]["grouplist"][<group>]["proplist"][<prop>]
      repeat for each key tProp in tPropsA
         local tSection, tGroup, tOrder, tPropInfoA
         put tPropsA[tProp] into tPropInfoA
         put tPropsA[tProp]["order"] into tOrder
         put tPropsA[tProp]["label"] into tGroup
         put tPropsA[tProp]["section"] into tSection
         put tPropInfoA into tExtensionPropsInfoA[tSection]["grouplist"][tGroup]["proplist"][tProp]
         
         put true into tExtensionPropsInfoA[tSection]["grouplist"][tGroup]["widget_prop"]
         put tOrder into tExtensionPropsInfoA[tSection]["grouplist"][tGroup]["order"]
      end repeat
   else
      put tPropsA into tExtensionPropsInfoA
   end if
   return tExtensionPropsInfoA
end revIDEExtensionPropertiesInfo

function revIDEExtensionProperty pKind, pProperty
   local tExtensionID
   put __extensionCacheID("name", pKind) into tExtensionID
   
   return __extensionPropertyGet(tExtensionID, pProperty)
end revIDEExtensionProperty

##############################
# PRIVATE INSTALLATION PROCESS
##############################

# Download the extension
on __extensionInstallDownload pCacheIndex
   # Check the file extension is correct
   local tURL
   put __extensionPropertyGet(pCacheIndex,"package_url") into tURL
   
   set the itemdel to "."
   if the last item of tURL is not "lce" then return __extensionError(pCacheIndex,"Could not download extension. The package must have the file extension 'lce':" && tURL)
   
   local tPackageFilePath
   set the itemdel to "/"
   put the last item of tURL into tPackageFilePath
   
   __extensionPropertySet pCacheIndex, "download_package_path", revIDESpecialFolderPath("downloading extensions") & slash & tPackageFilePath
   __extensionPropertySet pCacheIndex, "status", "downloading"
   __extensionPropertySet pCacheIndex, "progress_message", "Downloading"
   __extensionPropertySet pCacheIndex, "progress", 0
   __extensionPropertySet pCacheIndex, "label", tPackageFilePath
   
   # Put is a first stab at the name
   set the itemdel to "."
   local tName
   put tPackageFilePath into tName
   delete the last item of tName
   repeat while the last item of tName is a number
      delete the last item of tName
   end repeat
   __extensionPropertySet pCacheIndex, "name", tName
   
   # Send update to refresh UI with new package installation
   __extensionsChanged
   
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Downloading", 0
   
   # Download the extension to a file
   libURLDownloadToFile tURL, __extensionPropertyGet(pCacheIndex,"download_package_path"), "__extensionInstallDownloadComplete"
end __extensionInstallDownload

# Dowload complete
on __extensionInstallDownloadComplete pURL, pDownloadStatus
   # Get the index of the extension
   local tExtensionID
   
   put __extensionCacheID("package_url", pURL) into tExtensionID
   
   # Update progress
   __extensionSendProgressUpdate tExtensionID, "Download Complete", 100
   
   # Start installing by verifying package
   send "__extensionInstallVerify" && tExtensionID to me in 0 milliseconds
end __extensionInstallDownloadComplete

# Verify extension package is valid
on __extensionInstallVerify pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Verifying extension", 0
   
   # Get the path to the extension
   local tExtensionPath
   put __extensionPropertyGet(pCacheIndex, "download_package_path") into tExtensionPath
   
   # Check the package exists
   if there is not a file tExtensionPath then return __extensionError(pCacheIndex,"Could not install extension. Package does not exists: " && tExtensionPath)
   
   # Check the file extension is valid
   set the itemdel to "."
   if the last item of tExtensionPath is not "lce" then return __extensionError(pCacheIndex,"Could not install extension. The package extension '"&the last item of tExtensionPath&"' Is not valid. Must be 'lce'.")
   
   local tManifestDataA
   ideExtensionParseManifestFromPackage tExtensionPath, "manifest.xml", tManifestDataA
   if the result is not empty then
      return the result for error
   end if
   
   # Check the manifest contains a name
   if tManifestDataA["name"] is empty then return __extensionError(pCacheIndex,"Could not install extension. The package manifest must contain a valid name (com.livecode.extensions.<developer_ID>.<extension_name>)")
   __extensionPropertySet pCacheIndex, "name", tManifestDataA["name"]
   
   # Check the manifest contains a version
   if tManifestDataA["version"] is empty then return __extensionError(pCacheIndex,"Could not install extension. The package manifest must contain a valid version number (1.2.3 - major,minor,maintenance)")
   __extensionPropertySet pCacheIndex, "version", tManifestDataA["name"]
   
   # Check the manifest contains an author
   if tManifestDataA["author"] is empty then return __extensionError(pCacheIndex,"Could not install extension. The package manifest must contain an author")
   __extensionPropertySet pCacheIndex, "author", tManifestDataA["author"]
   
   # Check the manifest contains an type
   if tManifestDataA["type"] is empty then return __extensionError(pCacheIndex,"Could not install extension. The package manifest must contain a type")
   __extensionPropertySet pCacheIndex, "type", tManifestDataA["type"]
   
   # Check the manifest contains an title
   if tManifestDataA["title"] is empty then return __extensionError(pCacheIndex,"Could not install extension. The package manifest must contain a title")
   __extensionPropertySet pCacheIndex, "title", tManifestDataA["title"]
   
   # Build the type ID from the name and version
   __extensionPropertySet pCacheIndex, "type_id", tManifestDataA["name"] & "." & tManifestDataA["version"]
   
   # Next step
   send "__extensionInstallRemoveOlderVersions" && pCacheIndex to me in 0 milliseconds
end __extensionInstallVerify

on __extensionInstallRemoveOlderVersions pCacheIndex
   __extensionSendProgressUpdate pCacheIndex, "Removing older versions", 7
   
   local tName
   put __extensionPropertyGet(pCacheIndex, "name") into tName
   
   repeat for each key tCacheIndex in sExtensions
      if tCacheIndex is pCacheIndex then next repeat
      if sExtensions[tCacheIndex]["name"] is tName then
         revIDEUninstallExtension tCacheIndex
      end if
   end repeat
   
   # Next step
   send "__extensionInstallExtract" && pCacheIndex to me in 0 milliseconds
end __extensionInstallRemoveOlderVersions

# Extract the extension files
on __extensionInstallExtract pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Extracting extension", 15
   
   # Get the path to the package file
   local tExtensionPackageFile
   put __extensionPropertyGet(pCacheIndex, "download_package_path") into tExtensionPackageFile
   
   # Create directory to extract into
   local tExtensionDirectory
   put revIDESpecialFolderPath("temp extensions") & slash & __extensionPropertyGet(pCacheIndex, "type_id") into tExtensionDirectory
   revIDEEnsurePath(tExtensionDirectory)
   
   # Extract the icon,docs and executable module into the folder
   revZipOpenArchive tExtensionPackageFile, "read"
   
   # Work out the root of the zip
   local tZipItems, tZipRoot
   put revZipEnumerateItems(tExtensionPackageFile) into tZipItems
   if the last char of line 1 of tZipItems is "/" then
      put line 1 of tZipItems into tZipRoot
   else
      put empty into tZipRoot
   end if
   
   # Extract all the files
   local tDirectory
   set the itemdel to slash
   repeat for each line tFile in tZipItems
      put tExtensionDirectory & slash & item 1 to -2 of tFile into tDirectory
      revIDEEnsurePath(tDirectory)
      revZipExtractItemToFile tExtensionPackageFile, tFile, tExtensionDirectory & slash & tFile
   end repeat 
   
   # add path to icon file to the data array
   __extensionPropertySet pCacheIndex, "icon", revIDESpecialFolderPath("user extensions") & slash & __extensionPropertyGet(pCacheIndex,"type_id") & "/support/icon.png"
   
   revZipCloseArchive tExtensionPackageFile
   
   # Next step
   send "__extensionInstallGuide" && pCacheIndex to me in 0 milliseconds
end __extensionInstallExtract

# Install the guide into the IDE
on __extensionInstallGuide pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Adding user guide to documentation", 30
   
   # Path to user guide
   local tUserGuideFolder
   put revIDESpecialFolderPath("temp extensions") & slash & __extensionPropertyGet(pCacheIndex, "type_id") & slash & "docs/guide" into tUserGuideFolder
   
   # Get the name and author required by user guide install function
   local tExtensionName, tExtensionAuthor
   put __extensionPropertyGet(pCacheIndex, "name") into tExtensionName
   put __extensionPropertyGet(pCacheIndex, "author") into tExtensionAuthor
   
   # Install user guide into the IDE
   revIDEInstallUserGuide tUserGuideFolder, tExtensionName, tExtensionAuthor
   
   send "__extensionInstallAPI" && pCacheIndex to me in 500 milliseconds
end __extensionInstallGuide

# Install the extension API into the IDE
on __extensionInstallAPI pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Adding API to documentation", 45
   
   # Path to user guide
   local tUserAPIFolder
   put revIDESpecialFolderPath("temp extensions") & slash & __extensionPropertyGet(pCacheIndex, "type_id") & slash & "docs/api" into tUserAPIFolder
   
   # Get the name and author required by API install function
   local tExtensionName, tExtensionAuthor
   put __extensionPropertyGet(pCacheIndex, "name") into tExtensionName
   put __extensionPropertyGet(pCacheIndex, "author") into tExtensionAuthor
   
   # Install API into the IDE
   // revIDEInstallAPI tUserAPIFolder, tExtensionName, tExtensionAuthor
   revIDEInstallAPI tUserAPIFolder, tExtensionName, tExtensionAuthor
   
   # Next step
   send "__extensionInstallMakeLive" && pCacheIndex to me in 0 milliseconds
end __extensionInstallAPI

# Moves to temp extracted files into their final live location
on __extensionInstallMakeLive pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Copying extension into install location", 60
   
   # Get path the directories
   local tTempInstallPath, tFinalPath
   put revIDESpecialFolderPath("temp extensions") & slash & __extensionPropertyGet(pCacheIndex, "type_id") into tTempInstallPath
   put revIDESpecialFolderPath("user extensions") into tFinalPath
   __extensionPropertySet pCacheIndex, "install_path", tFinalPath & slash & __extensionPropertyGet(pCacheIndex, "type_id")
   
   # Copy folder from temp directory into live directory
   revCopyFolder tTempInstallPath,tFinalPath
   
   # AL-2015-03-15: [[ Bug 15008 ]] Move interface file to interface folder
   local tInterfaceFile, tInterfacePath
   put __extensionPropertyGet(pCacheIndex, "name") & ".lci" into tInterfaceFile
   put tFinalPath & slash &__extensionPropertyGet(pCacheIndex, "type_id") \ 
         & slash & tInterfaceFile into tInterfacePath
   
   if there is a file tInterfacePath then
      local tTargetFolder
      put tFinalPath & slash & "interface" into tTargetFolder
      revIDEEnsurePath tTargetFolder
      revCopyFile tInterfacePath, tTargetFolder & slash & tInterfaceFile
   end if
   
   # Next step
   send "__extensionInstallLoad" && pCacheIndex to me in 0 milliseconds
end __extensionInstallMakeLive

on __extensionInstallLoad pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Loading extension", 75
   
   # Path to module file
   local tModuleFile
   put revIDESpecialFolderPath("temp extensions") \ 
         & slash & __extensionPropertyGet(pCacheIndex, "type_id") \
         & slash & "module.lcm" into tModuleFile
   
   # Store the extension's property metadata
   local tTypeID
   put  __extensionPropertyGet(pCacheIndex, "name") into tTypeID
   revIDEExtensionSetInfo tTypeID
   
   # Load module file into the engine
   local tDataA
   put sExtensions[pCacheIndex] into tDataA["copies"][1]
   
   local tExisting
   repeat for each key tExtensionID in sExtensions
      if tExtensionID is pCacheIndex then next repeat
      if sExtensions[tExtensionID]["name"] is tTypeID then
         put sExtensions[tExtensionID]["copies"] into tExisting
      end if
   end repeat
   
   repeat for each key tKey in tExisting
      put tExisting[tKey] into tDataA["copies"][tKey + 1]
   end repeat
   
   __extensionLoad tTypeID, tDataA
   
   # Next step
   send "__extensionInstallFinalise" && pCacheIndex to me in 0 milliseconds
end __extensionInstallLoad

# Delete installation files and original package
on __extensionInstallFinalise pCacheIndex
   # Update progress
   __extensionSendProgressUpdate  pCacheIndex, "Removing temp files", 90
   
   # Delete temp install folder
   local tTempInstallPath
   put revIDESpecialFolderPath("temp extensions") & slash & __extensionPropertyGet(pCacheIndex, "type_id") into tTempInstallPath
   if there is a folder tTempInstallPath then
      revDeleteFolder tTempInstallPath
   end if
   
   # Delete temp package file
   local tTempInstallPackage
   put revIDESpecialFolderPath("downloading extensions") & slash & __extensionPropertyGet(pCacheIndex, "type_id") & ".lce" into tTempInstallPackage
   if there is a file tTempInstallPackage then
      revDeleteFolder tTempInstallPackage
   end if
   
   # Update the cache
   __extensionSendProgressUpdate  pCacheIndex, "Complete", 100
   __extensionPropertySet pCacheIndex, "status", "installed"
   
   # Notify palettes
   __extensionsChanged
end __extensionInstallFinalise

##############################
# PRIVATE UNINSTALL
##############################

# Check if the widget to be uninstalled is in use
on __extensionUninstallCheckInUse pCacheIndex
   # Update progress
   if pCacheIndex is not a number then return __extensionError(pCacheIndex, "Could not remove extension '" & pCacheIndex & "' because it is not a valid index")
   
   __extensionSendProgressUpdate pCacheIndex, "Checking if extension is in use", 20
   
   # Next step
   __extensionUninstallDeleteFiles pCacheIndex
end __extensionUninstallCheckInUse

# Delete the files associated to the extension
on __extensionUninstallDeleteFiles pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Deleting extension files", 40
   
   # Get the extension isntall path
   local tPath
   put __extensionPropertyGet(pCacheIndex, "install_path") into tPath
   
   # Make sure the path contains the folder extension as a check before deleting a folder
   if tPath begins with revIDESpecialFolderPath("user extensions") then
      revDeleteFolder tPath
   end if
   
   # AL-2015-03-15: [[ Bug 15008 ]] Delete interface file from interface folder
   local tInterfaceFile
   put __extensionPropertyGet(pCacheIndex, "name") & ".lci" into tInterfaceFile
   if there is a file (revIDESpecialFolderPath("user extensions") & slash & "interface" & slash & tInterfaceFile) then
      revDeleteFile revIDESpecialFolderPath("user extensions") & slash & "interface" & slash & tInterfaceFile
   end if
   
   # Next step
   __extensionUninstallUnload pCacheIndex
end __extensionUninstallDeleteFiles

# Unload the extension
on __extensionUninstallUnload pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Unloading extension", 60
   
   # Unload the extension by name
   local tName
   put __extensionPropertyGet(pCacheIndex, "name") into tName
   revIDEExtensionUnload tName
   
   # Next step
   __extensionUninstallDocs pCacheIndex
end __extensionUninstallUnload

# Remove the guide from the IDE
on __extensionUninstallDocs pCacheIndex
   # Update progress
   __extensionSendProgressUpdate pCacheIndex, "Removing API and user guide from documentation", 80
   
   revIDERegenerateBuiltDictionaryData
   
   __extensionUninstallComplete pCacheIndex
end __extensionUninstallDocs

on __extensionUninstallComplete pCacheIndex
   # Notify IDE uninstallation complete
   __extensionSendProgressUpdate pCacheIndex, "Complete", 100
   
   # Update the IDE
   __extensionsChanged
end __extensionUninstallComplete

##############################
# PRIVATE SHARED
##############################

private command __extensionSetPropertyInfo pCacheIndex
   local tPropertyDataA
   put __extensionPropertyGet(pCacheIndex, "property") into tPropertyDataA
   
   local tName
   repeat for each key tName in tPropertyDataA
      local tMetadata
      put __extensionPropertyGet(pCacheIndex, tName) into tMetadata
      if tMetadata is not empty then
         union tPropertyDataA[tName] with tMetadata recursively
      end if
      
      local tPropertyInfo
      put revIDEPropertyInfo(tName) into tPropertyInfo
      if tPropertyInfo is not empty then
         union tPropertyDataA[tName] with tPropertyInfo recursively
      end if
       
      if tPropertyDataA[tName]["editor"] is empty then
         if tPropertyDataA[tName]["get"] is "Integer" or tPropertyDataA[tName]["get"] is "Real" then
            put "com.livecode.pi.number" into tPropertyDataA[tName]["editor"]
         else
            put "com.livecode.pi." & tolower(tPropertyDataA[tName]["get"]) into tPropertyDataA[tName]["editor"]
         end if
      end if
      
      local tLabel, tSection
      
      if tPropertyDataA[tName]["section"] is empty then
         put "Basic" into tPropertyDataA[tName]["section"]
      end if
      
      if tPropertyDataA[tName]["label"] is empty then
         put tName into tPropertyDataA[tName]["label"]
      end if
      
      # Process value options, default and delimiter
      replace comma with return in tPropertyDataA[tName]["options"]
      replace "\n" with return in tPropertyDataA[tName]["delimiter"]
      if tPropertyDataA[tName]["default"] is not empty then
         replace "\n" with return in tPropertyDataA[tName]["default"]
      end if
      
      # Tag the property as a widget property, so we can order them 
      # correctly after the built-in props for the given section
      put true into tPropertyDataA[tName]["widget_prop"]
      
      if tPropertyDataA[tName]["user_visible"] is empty then
         put true into tPropertyDataA[tName]["user_visible"]
      end if
   end repeat
   
   put __extensionPropertyGet(pCacheIndex, "name") into tName
   put tPropertyDataA into sExtensionProperties[tName]
end __extensionSetPropertyInfo

command revIDEExtensionSetInfo pTypeID
   set the itemdelimiter to slash
   
   # Get the internal cache ID
   local tCacheIndex
   put __extensionCacheID("name", pTypeID) into tCacheIndex
   
   # Get the target folder
   local tFolder
   put __extensionPropertyGet(tCacheIndex, "install_path") into tFolder
   
   # Get information from the download package path if the manifest was not found
   if tFolder is empty then
      put item 1 to -2 of __extensionPropertyGet(tCacheIndex, "download_package_path") into tFolder
   end if
   
   local tManifest
   put tFolder & slash & "manifest.xml" into tManifest
   if there is not a file tManifest then 
      exit revIDEExtensionSetInfo
   end if
   
   __extensionSetExtensionInfoFromManifest tCacheIndex, tManifest
   __extensionSetPropertyInfo tCacheIndex
   
   # Set the default name
   local tTitle
   put __extensionPropertyGet(tCacheIndex, "title") into tTitle
   put tTitle into sExtensionProperties[pTypeID]["name"]["default"]
   
end revIDEExtensionSetInfo

private command __extensionSetExtensionInfoFromManifest pCacheIndex, pManifestPath
   local tDataA
   ideExtensionParseManifest pManifestPath, tDataA
   
   repeat for each key tKey in tDataA
      __extensionPropertySet pCacheIndex, tKey, tDataA[tKey]
   end repeat
end __extensionSetExtensionInfoFromManifest

function __extensionError pCacheIndex, pErrorMessage
   __extensionSendProgressUpdate pCacheIndex, "Error:" && pErrorMessage, 100
   --put "Error:" && pErrorMessage, 100
   --revIDEUninstallExtension pCacheIndex
   return empty
end __extensionError

# Send notication that widget has been added/removed
on __extensionsChanged
   ideMessageSend "ideExtensionsChanged"
end __extensionsChanged

# Sent progress update on installation of widget
on __extensionSendProgressUpdate pCacheIndex, pMessage, pProgress
   # Get progress information for extension
   __extensionPropertySet pCacheIndex, "progress_message", pMessage
   __extensionPropertySet pCacheIndex, "progress", pProgress
   
   local tName
   put __extensionPropertyGet(pCacheIndex, "name") into tName
   ideMessageSend "ideExtensionStatusChanged", (tName & comma & pMessage & comma & pProgress)
end __extensionSendProgressUpdate

private function __fetchManifestData pManifestFile
   local tDataA, tFolder
   
   ideExtensionParseManifest pManifestFile, tDataA
   # If we couldn't fetch a type id, or there was no manifest then the result will not be empty
   if the result is not empty then
      put "Invalid manifest" into tDataA["error"]
      put "error" into tDataA["status"]
   end if
   return tDataA
end __fetchManifestData

private function __extensionIsBuiltin pID
   switch pID
      case "com.livecode.widget"
      case "com.livecode.engine"
      case "com.livecode.canvas"
      case "com.livecode.foreign"
      case "com.livecode.arithmetic"
      case "com.livecode.array"
      case "com.livecode.binary"
      case "com.livecode.bitwise"
      case "com.livecode.byte"
      case "com.livecode.char"
      case "com.livecode.codeunit"
      case "com.livecode.date"
      case "com.livecode.file"
      case "com.livecode.list"
      case "com.livecode.logic"
      case "com.livecode.mathfoundation"
      case "com.livecode.math"
      case "com.livecode.sort"
      case "com.livecode.stream"
      case "com.livecode.string"
      case "com.livecode.system"
      case "com.livecode.type"
      case "com.livecode.typeconvert"
      case "com.livecode.extensions.libbrowser"
         return true
      default
         return false
   end switch
end __extensionIsBuiltin

private on __addToDependencies pDependee, pDependent, @xDependencies
   # AL-2015-04-13: [[ Bug 15216 ]] Use keys of array to remove duplicates
   put true into xDependencies[pDependee][pDependent]
end __addToDependencies

private on __addToList pNode, @xList
   if xList is empty then
      put pNode into xList
   else
      put return & pNode after xList
   end if
end __addToList

private on __removeFromList pNode, @xList
   get lineOffset(pNode, xList)
   if it is not 0 then
      delete line it of xList
   end if
end __removeFromList

private on __visitNode pDependencies, pNode, @xUnmarked, @xMarked, @xTemporaryMarked, @xOrder
   if pNode is among the lines of xTemporaryMarked then
      return "Error"
   end if
   if pNode is among the lines of xMarked then
      # AL-2015-04-13: [[ Bug 15216 ]] Remove from unmarked if this was already marked
      __removeFromList pNode, xUnmarked
      return ""
   end if
   __addToList pNode, xTemporaryMarked
   repeat for each key tNode in pDependencies[pNode]
      __visitNode pDependencies, tNode, xUnmarked, xMarked, xTemporaryMarked, xOrder
      if the result is not empty then
         return "Error"
      end if
   end repeat
   __addToList pNode, xMarked
   __removeFromList pNode, xUnmarked
   __removeFromList pNode, xTemporaryMarked
   __addToList pNode, xOrder
end __visitNode

private function __dependencyOrder pDependencies, pList
   local tUnmarked, tTemporaryMarked, tMarked, tOrder, tToVisit
   put pList into tUnmarked
   repeat while tUnmarked is not empty
      put any line of tUnmarked into tToVisit
      __visitNode pDependencies, tToVisit, tUnmarked, tMarked, tTemporaryMarked, tOrder
      if the result is not empty then
         throw "Circularity in dependencies starting from" && tToVisit
         return empty
      end if
   end repeat
   return tOrder
end __dependencyOrder

function revIDEExtensionsOrderByDependency pExtensions
   # Accumulate an array of dependencies
   local tDependencies, tRequirements
   repeat for each line tExtension in pExtensions
      put revIDEExtensionProperty(tExtension, "requires") into tRequirements
      repeat for each element tDependent in tRequirements
         if __extensionIsBuiltin(tDependent) then
            next repeat
         end if
         __addToDependencies tExtension, tDependent, tDependencies
      end repeat
   end repeat
   
   # Order them
   return __dependencyOrder(tDependencies, pExtensions)
end revIDEExtensionsOrderByDependency

on __extensionsLoad
   local tDataA
   
   # Fetch all the available data about extensions in the search paths
   local tFoldersA, tExtensionFolder, tPath
   put revIDEExtensionFolders() into tFoldersA
   set the itemdel to "."
   repeat for each key tKey in tFoldersA
      put tFoldersA[tKey] into tExtensionFolder
      repeat for each line tFolder in folders(tExtensionFolder)
         if tFolder begins with "." then next repeat
         if tFolder is among the items of "downloading,temp,uninstalled" then next repeat
         
         local tArray
         put  tExtensionFolder & slash & tFolder & slash & "manifest.xml" into tPath
         
         if there is a file tPath then
            put __fetchManifestData(tPath) into tArray
            put tKey is "ide" into tArray["ide"]
            
            if tArray["type"] is "package" then
               -- parse included extensions
               
               local tInclusion
               repeat for each element tInclusion in tArray["includes"]
                  local tInclusionFolder
                  if tInclusion["name"] begins with tArray["name"] & "." then
                     put char length(tArray["name"]) + 2 to -1 of tInclusion["name"] into tInclusionFolder
                  else
                     next repeat
                  end if
                  
                  if there is no folder (tExtensionFolder & slash & tFolder & slash & tInclusionFolder) then
                     next repeat
                  end if
                  
                  local tInclusionArray
                  put  tExtensionFolder & slash & tFolder & slash & tInclusionFolder & slash & "manifest.xml" into tPath
                  
                  if there is a file tPath then
                     put __fetchManifestData(tPath) into tInclusionArray
                     put tKey is "ide" into tInclusionArray["ide"]
                     
                     put tInclusionArray into tDataA[tInclusionArray["name"]][tExtensionFolder & slash & tFolder][tInclusionFolder]
                  end if
               end repeat
            end if
            
            put tArray into tDataA[tArray["name"]][tExtensionFolder][tFolder]
         end if
      end repeat
   end repeat
   
   __extensionsLoadInDependencyOrder tDataA
   
end __extensionsLoad

private command __extensionsLoadInDependencyOrder pDataA
   # Now loop through, checking the status of them
   local tExtensionsList, tExtensionsA, tExtensionCount, tExtensionCopyCount, tExtensionDataA
   put the keys of pDataA into tExtensionsList
   sort tExtensionsList
   
   local tToLoadA, tDependencies
   set the itemdel to ","
   put 1 into tExtensionCount
   repeat for each line tTypeID in tExtensionsList
      put 1 into tExtensionCopyCount
      repeat for each key tRootFolder in pDataA[tTypeID]
         repeat for each key tFolder in pDataA[tTypeID][tRootFolder]
            put pDataA[tTypeID][tRootFolder][tFolder] into tExtensionDataA["copies"][tExtensionCopyCount]
            put tRootFolder & slash & tFolder into tExtensionDataA["copies"][tExtensionCopyCount]["install_path"]
            add 1 to tExtensionCopyCount
         end repeat
      end repeat
      put tExtensionDataA into tToLoadA[tTypeID]
      # Accumulate an array of dependencies
      repeat for each element tDependent in tExtensionDataA["copies"][1]["requires"]
         if __extensionIsBuiltin(tDependent) then
            next repeat
         end if
         __addToDependencies tTypeID, tDependent, tDependencies
      end repeat
      put empty into tExtensionDataA
   end repeat
   
   # Perform topological sort on list of dependencies so that they are loaded in the correct order
   repeat for each line tLine in __dependencyOrder(tDependencies, the keys of tToLoadA)
      -- no need to load packages here as their inclusions are already in the dependency order
      if tToLoadA[tLine]["type"] is "package" then
         next repeat
      end if
      __extensionLoad tLine, tToLoadA[tLine]
   end repeat
end __extensionsLoadInDependencyOrder

# Returns: List of the packages that are in the directory but not installed
function __extensionPackagePaths
   local tPaths
   return tPaths
end __extensionPackagePaths

# Calls Weservice and returns updates
function __extensionUpdates
end __extensionUpdates

# Returns the ID of the internal array given the extension typeID
private function __extensionCacheID pPropertyToSearch, pValue
   repeat for each key tExtensionID in sExtensions
      if sExtensions[tExtensionID][pPropertyToSearch] is pValue then
         return tExtensionID
      end if
   end repeat
end __extensionCacheID

# Gets a property from the internal extension cache
function __extensionPropertyGet pCacheIndex, pProperty
   return sExtensions[pCacheIndex][pProperty]
end __extensionPropertyGet

# Sets a property in the internal extension cache
on __extensionPropertySet pCacheIndex, pProperty, pValue
   put pValue into sExtensions[pCacheIndex][pProperty]
end __extensionPropertySet

# Loads an extension
private command __extensionLoad pID, pExtensionDataA
   local tLoadedDataA, tToLoadA
   # Only try to load the first copy in the load order
   put pExtensionDataA["copies"][1] into tToLoadA
   
   local tFolder, tVersion, tStatus, tError, tIDEExtension
   put tToLoadA["install_path"] into tFolder
   put tToLoadA["version"] into tVersion
   put tToLoadA["status"] into tStatus
   put tToLoadA["error"] into tError
   put tToLoadA["ide"] into tIDEExtension
   revIDEExtensionLoad pID, tFolder, tVersion, tStatus, tError, tIDEExtension
end __extensionLoad

command revIDEExtensionLoad pID, pFolder, pVersion, pStatus, pError, pIDEExtension
   # Find entry in the cache if it exists
   local tCacheIndex
   put __extensionCacheID("install_path", pFolder) into tCacheIndex
   
   # If no extry is in the cache, create one
   if tCacheIndex is not a number then
      put the number of elements of sExtensions + 1 into tCacheIndex
      __extensionPropertySet tCacheIndex, "install_path", pFolder
   end if
   
   # Update name, status, error, and whether the extension comes with the IDE
   __extensionPropertySet tCacheIndex, "name", pID
   __extensionPropertySet tCacheIndex, "type_id", pID  & "." & pVersion 
   __extensionPropertySet tCacheIndex, "ide", pIDEExtension
   
   # Store the extension's property metadata
   revIDEExtensionSetInfo pID
   
   local tStatus, tError
   if pError is empty then
      switch __extensionPropertyGet(tCacheIndex, "type")
         case "widget"
         case "library"
         case "module"
            local tResources, tModule
            put pFolder & slash & "resources" into tResources
            put pFolder & slash & "module.lcm" into tModule
            
            # If we have a resources folder then load with resource path
            if there is a folder tResources then
               load extension from file tModule with resource path tResources
            else
               load extension from file tModule
            end if
            if the result is not empty then
               put toUpper(char 1 of the result) & char 2 to -1 of the result into tError
               put "error" into tStatus
            else
               put "installed" into tStatus
            end if
            break
         case "package"
            -- iterate over inclusions and recurse
            local tInclusions
            put __extensionPropertyGet(tCacheIndex, "includes") into tInclusions
            
            local tInclusion, tDataA
            repeat for each element tInclusion in tInclusions
               local tInclusionFolder
               if tInclusion["name"] begins with tInclusions["name"] & "." then
                  put char length(tInclusions["name"]) + 2 to -1 of tInclusion["name"] into tInclusionFolder
               else
                  next repeat
               end if
               
               if there is no folder (pFolder & slash & tInclusionFolder) then
                  next repeat
               end if
               
               local tInclusionArray, tPath
               put pFolder & slash & tInclusionFolder & slash & "manifest.xml" into tPath
               
               if there is a file tPath then
                  put __fetchManifestData(tPath) into tInclusionArray
                  put pIDEExtension into tInclusionArray["ide"]
                  
                  put tInclusionArray into tDataA[tInclusionArray["name"]][pFolder][tInclusionFolder]
               end if
            end repeat
            
            __extensionsLoadInDependencyOrder tDataA
            break
         default
            put "error" into tStatus
            put "unsupported package type" into tError
            break
      end switch
   else
      put pStatus into tStatus
      put pError into tError
   end if
   
   __extensionPropertySet tCacheIndex, "status", tStatus
   __extensionPropertySet tCacheIndex, "error", tError
   
   # Deal with the various icon possibilities
   if sExtensionProperties[pID]["svgIconPath"] is empty then
      local tIconPath
      put pFolder & "/support/icon.png" into tIconPath
      if there is a file tIconPath then
         __extensionPropertySet tCacheIndex, "icon", tIconPath
      end if
   end if
   
   # Load the default script if there is one
   local tDefaultScript
   put revIDEExtensionFetchDefaultScript(pFolder, pID, true) into tDefaultScript
   __extensionPropertySet tCacheIndex, "defaultScript", tDefaultScript
   
   # Generate extension API from source if there is not one present in the folder
   # Don't do in an installed IDE as we might not be able to generate the files in the appropriate location
   if not revEnvironmentIsInstalled() and not there is a file (pFolder & slash & "api.lcdoc") then
      revIDEExtensionUpdateAPI pFolder
   end if
   
   return tError
end revIDEExtensionLoad

function revIDEExtensionFetchDefaultScript pFolder, pCacheIndex, pValidate
   if there is a stack (pCacheIndex& ".__DefaultScript") then
      return the script of stack (pCacheIndex& ".__DefaultScript")
   end if
   
   local tDefaultScriptPath
   put pFolder & "/support/defaultscript.livecodescript" into tDefaultScriptPath
   
   if there is not a file tDefaultScriptPath then
      return empty
   end if
   
   lock messages
   try
      open stack tDefaultScriptPath
   catch tStackError
      return empty
   end try
   
   local tScript
   if tStackError is empty then
      if pValidate then
         if there is a stack (pCacheIndex& ".__DefaultScript") then
            put the script of stack (pCacheIndex & ".__DefaultScript") into tScript
         end if
      else
         put the script of stack tDefaultScriptPath into tScript
      end if
      delete stack tDefaultScriptPath
   end if
   unlock messages
   
   return tScript
end revIDEExtensionFetchDefaultScript

##############################
# CALLBACKS
##############################

on extensionUpdateDataReceived
end extensionUpdateDataReceived

function revIDEExtensionDocsData
   local tExtensionsA
   put revIDEExtensions("", "installed", true) into tExtensionsA
   local tDataA, tCount
   repeat for each element tExtension in tExtensionsA
      add 1 to tCount
      put tExtension["install_path"] into tDataA[tCount]["folder"]
      put tExtension["title"] into tDataA[tCount]["title"]
      put tExtension["author"] into tDataA[tCount]["author"]
   end repeat
   return tDataA
end revIDEExtensionDocsData

on revIDEExtensionUpdateAPI pFolder, pExtensionSource
   if pExtensionSource is empty then
      local tFiles
      revIDEPushDefaultFolder pFolder
      put the files into tFiles
      filter tFiles with "*.lcb"
      if tFiles is empty then exit revIDEExtensionUpdateAPI
      put line 1 of tFiles into pExtensionSource
      revIDEPopDefaultFolder
   end if
   
   # Check timestamps to see if API  is out of date.
   local tNeedUpdate, tError
   put revIDEIsFilesetStale(pFolder & slash & pExtensionSource, \
      pFolder & slash & "api.lcdoc", false, tError) into tNeedUpdate
   if tNeedUpdate is empty then put true into tNeedUpdate
   
   if tNeedUpdate then
      local tAPI
      dispatch function "revDocsGenerateDocsFileFromModularFile" to stack "revDocsParser" with (pFolder & slash & pExtensionSource) 
      put the result into tAPI 
      put textEncode(tAPI, "utf-8") into url ("binfile:" & pFolder & slash & "api.lcdoc")
      return "updated"
   end if
end revIDEExtensionUpdateAPI

private command __StripBOM @xData
   local tBom
   put textEncode(numToCodepoint(0xfeff), "UTF-8") into tBom

   if xData begins with tBom then
      delete byte 1 to (the number of bytes in tBom) of xData
   end if
end __StripBOM

private command __DecodeUTF8 @xData
   __StripBOM xData

   put textDecode(xData, "UTF-8") into xData
end __DecodeUTF8

/**

Parse manifest file into array

Parameters:

pManifestPath (string): A full path to a manifest file

rDataA (array): Set to the the parsed manifest data

The result:
An error string if an error occurs

*/

command ideExtensionParseManifest pManifestPath, @rDataA
   local tDataA
   
   local tManifestContents
   put url ("binfile:" & pManifestPath) into tManifestContents
   
   __DecodeUTF8 tManifestContents
   
   __ParseManifest tManifestContents, rDataA
   
   if the result is not empty then
      return the result for error
   else
      return empty for value
   end if   
end ideExtensionParseManifest

/**

Parse manifest from package into array

Parameters:

pPackagePath (string): A full path to package

pManifestPath (string): A relative path to a manifest file within the
package

rDataA (array): Set to the the parsed manifest data

The result:
An error string if an error occurs

*/

command ideExtensionParseManifestFromPackage pPackagePath, pManifestPath, @rDataA
   local tDataA
   
   if not there is a file pPackagePath then \
      return "Could not extract manifest because package was not found in downloads folder" for error
   
   # A zip can come compressed with a base folder or without. So work out what the 
   # root folder is before trying to extract files
   revZipOpenArchive pPackagePath, "read"
   
   local tZipItems
   put revZipEnumerateItems(pPackagePath) into tZipItems
   
   if the last char of line 1 of tZipItems is "/" then
      if not (pManifestPath begins with "/") then
         put "/" before pManifestPath
      end if
   else
      if pManifestPath begins with "/" then
         delete char 1 of pManifestPath
      end if
   end if
   
   
   # Extract the package manfiest to a variable to read key data
   local tManifestContents
   revZipExtractItemToVariable pPackagePath, pManifestPath, "tManifestContents"
   
   revZipCloseArchive pPackagePath
   
   __DecodeUTF8 tManifestContents
   
   __ParseManifest tManifestContents, rDataA
   
   if the result is not empty then
      return the result for error
   else
      return empty for value
   end if   
end ideExtensionParseManifestFromPackage

private command __ParseManifest pManifestContents, @rDataA
   local tTreeID, tDataA
   put revXMLCreateTree(pManifestContents, true, true, false) into tTreeID
   if tTreeID begins with "xmlerr" then
      return "Error: invalid xml in manifest" for error
   end if
   
   local tTargetType
   put textDecode(revXMLNodeContents(tTreeID, "/package/type"), "utf-8") into tTargetType
   
   if tTargetType begins with "xmlerr" then
      return "Error: no type found in manifest" for error
   end if
   put tTargetType into tDataA["type"]
   
   local tTargetName
   put textDecode(revXMLNodeContents(tTreeID, "/package/name"), "utf-8") into tTargetName
   if tTargetName begins with "xmlerr" then
      return "Error: couldn't retrieve extension name from manifest" for error
   end if
   put tTargetName into tDataA["name"]
   
   local tTargetTitle
   put textDecode(revXMLNodeContents(tTreeID, "/package/title"), "utf-8") into tTargetTitle
   
   if tTargetTitle is empty or tTargetTitle begins with "xmlerr" then
      put empty into tTargetTitle
   end if
   put tTargetTitle into tDataA["title"]
   
   local tTargetVersion
   put textDecode(revXMLNodeContents(tTreeID, "/package/version"), "utf-8") into tTargetVersion
   
   if tTargetVersion is empty or tTargetVersion begins with "xmlerr" then
      put empty into tTargetVersion
   end if
   put tTargetVersion into tDataA["version"]
   
   local tTargetAuthor
   put textDecode(revXMLNodeContents(tTreeID, "/package/author"), "utf-8") into tTargetAuthor
   if tTargetAuthor is empty or tTargetAuthor begins with "xmlerr" then
      put empty into tTargetAuthor
   end if
   put tTargetAuthor into tDataA["author"]
   
   # Fetch property metadata
   local tMetadataValue, tMetadataKey
   local tMetadataNodes
   put revXMLChildNames(tTreeID, "package",return,"metadata",true) into tMetadataNodes
   repeat for each line tMetadata in tMetadataNodes
      put revXMLAttribute(tTreeID,"package" & "/" & tMetadata,"key") into tMetadataKey
      put revXMLNodeContents(tTreeID,"package" & "/" & tMetadata) into tMetadataValue
      if tMetadataValue is empty or tMetadataValue begins with "xmlerr" then
         put empty into tMetadataValue
      end if
      split tMetadataKey by "."
      put tMetadataValue into tDataA[tMetadataKey]
   end repeat
   
   # Fetch properties
   local tProperties
   local tProperty
   local tName
   local tOrder = 0
   put revXMLChildNames(tTreeID,"package",return,"property",true) into tProperties
   repeat for each line tProperty in tProperties
      add 1 to tOrder
      put revXMLAttribute(tTreeID,"package" & "/" & tProperty,"name") into tName
      
      local tReadOnly
      get revXMLAttribute(tTreeID,"package" & "/" & tProperty,"set")
      if it is empty or it begins with "xmlerr" then
         put true into tReadOnly
      else
         put it into tDataA["property"][tName]["set"]
         put false into tReadOnly
      end if
      put tReadOnly into tDataA["property"][tName]["read_only"]
      
      put revXMLAttribute(tTreeID,"package" & "/" & tProperty,"get") into tDataA["property"][tName]["get"]
      put tOrder into tDataA["property"][tName]["order"]
   end repeat
   
   # Fetch extension dependencies
   local tRequires, tCount
   put 0 into tCount
   put revXMLChildNames(tTreeID,"package",return,"requires",true) into tRequires
   repeat for each line tDependency in tRequires
      add 1 to tCount
      put revXMLAttribute(tTreeID,"package" & "/" & tDependency,"name") into tName
      put tName into tDataA["requires"][tCount]
   end repeat
   
   # Fetch extension inclusions
   local tIncludes
   put 0 into tCount
   put revXMLChildNames(tTreeID,"package",return,"includes",true) into tIncludes
   repeat for each line tDependency in tIncludes
      add 1 to tCount
      put revXMLAttribute(tTreeID,"package" & "/" & tDependency,"name") into tName
      put tName into tDataA["includes"][tCount]
   end repeat
   
   # Fetch library handlers
   if tTargetType is "library" then
      local tHandlerList, tHandlerNodes
      put revXMLChildNames(tTreeID, "package",return,"handler",true) into tHandlerNodes
      repeat for each line tHandler in tHandlerNodes
         local tHandlerName
         put revXMLAttribute(tTreeID,"package" & "/" & tHandler,"name") into tHandlerName
         
         if tHandlerName is empty or tHandlerName begins with "xmlerr" then
            next repeat
         end if
         
         if tHandlerList is empty then
            put tHandlerName into tHandlerList
         else
            put return & tHandlerName after tHandlerList
         end if
      end repeat
      put tHandlerList into tDataA["handlers"]
   end if
   
   # User visible should default to true
   if tDataA["uservisible"] is empty then
      put true into tDataA["uservisible"]
   end if
   
   put tDataA into rDataA
   
   return empty for value
end __ParseManifest

function revIDEExtensionModuleFile pKind
   # Get the internal cache index
   local tCacheIndex
   put __extensionCacheID("name", pKind) into tCacheIndex
   
   return __extensionPropertyGet(tCacheIndex, "install_path") & slash & "module.lcm"
end revIDEExtensionModuleFile

command revIDEExtensionUnload pKind
   local tCacheIndex
   put __extensionCacheID("name", pKind) into tCacheIndex
   
   local tCopies
   put __extensionPropertyGet(tCacheIndex, "copies") into tCopies
   if the number of elements in tCopies <= 1 then
      delete variable sExtensions[tCacheIndex]
   else
      __extensionPropertySet tCacheIndex, "status", "uninstalled"
   end if
   
   # Check if it's loaded
   if pKind is among the lines of the loadedExtensions then
      unload extension pKind
   end if
   
   return the result
end revIDEExtensionUnload

function revIDEExtensionLibraryHandlers pLibraryID
   local tCacheIndex
   put __extensionCacheID("name", pLibraryID) into tCacheIndex
   
   return __extensionPropertyGet(tCacheIndex, "handlers")
end revIDEExtensionLibraryHandlers

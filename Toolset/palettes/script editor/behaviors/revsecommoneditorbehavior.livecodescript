script "com.livecode.scripteditor.behavior.editorcommon"
local sObjectId

# The following variables store information used for the undo / redo system.
local sTextOperationOffsets
local sTextOperationNewTexts
local sTextOperationOldTexts
local sTextOperationIndex

local sTextOperationTop

local sTextGroupLabels
local sTextGroupLengths
local sTextGroupIndex
local sTextGroupTop
local sTextFormatKeywordMap

local sTextMark
local sLastSelectedChunk
local sLastNonEmptySelection

# Stores an array of cached object scripts for switching back to objects with unsaved changes
local sScriptCache

# OK-2009-01-17 : Bug 7169 - Store whether scripts are "dirty" or not, i.e whether the user has actually
# modified them, as opposed to they were modified by the script editor. (This can happen in the case of template scripts)
local sDirty

# Stores requests to update the script editor in reponse to a selection changed
local sSelectionUpdateRequest

# Stores requests to update the script editor panes
local sPaneUpdateRequest

# Stores the id of the last request to update the gutter, if there is one pending.
local sGutterUpdateRequest

# Stores the id of the last autocomplete find request
local sLastFindMessageID

# We also need to store whether the last update request involved text changing and 
# whether it required the compilation errors to be updated. This is because it may be
# cancelled by a subsequent request that didn't require these things, resulting in the update
# being lost.
local sGutterUpdateRequestDetails

# Stores that an arrowKey is pressed from rawKeyDown
local sArrowKeyPressed

local sProviders
local sProvidersIncludingMsgPath
local sRegisteredProviders
local sProviderNames
local sPlaceholders
local sEditChunks
local sFoundProviders
local sScriptDescription

constant kAutocompletePlaceholderStart = "${"
constant kAutocompletePlaceholderEnd = "}"
constant kAutocompleteNameDelimiter = ":"
constant kAutocompleteClassDelimiter = "|"

constant kAutocompleteMaxProviders = 10
constant kAutocompleteVisibleProviders = 5

constant kAutocompleteScriptLocalPriority = "95"
constant kAutocompleteHandlerLocalPriority = "100"
constant kAutocompleteAvailableHandlerPriority = "80"
constant kAutocompleteScriptHandlerPriority = "90"
constant kAutocompleteUndeclaredGlobalPriority = "40"
constant kAutocompleteDocsPriority = "50"

constant kAutocompleteMatchAny = 0
constant kAutocompleteMatchLine = 1
constant kAutocompleteMatchToken = 2

constant kAutocompleteScopeAny = 0
constant kAutocompleteScopeScript = 1
constant kAutocompleteScopeHandler = 2

constant kAutocompleteBackgroundColor = "240,240,240"
constant kAutocompletePlaceholderSearchLines = 20

# OK-2009-01-17 : Bug 7169
command setDirty pObject, pValue
   put pValue into sDirty[pObject]
end setDirty

command getDirty pObject
   return sDirty[pObject]
end getDirty

command setObjectID pObjectID
   if pObjectID is not empty then
      local tRuggedID
      put revRuggedId(pObjectID) into tRuggedID
      if tRuggedID is not sObjectID then
         put tRuggedID into sObjectID
         put sRegisteredProviders into sProvidersIncludingMsgPath
         if exists(sObjectId) then
            __GenerateProvidersByIntrospectingMessagePath sObjectId, sProvidersIncludingMsgPath
         end if
      end if
   else
      put empty into sObjectID
   end if
end setObjectID

function getObjectID
   return sObjectID
end getObjectID

command updateObjectID pOldObjectID, pNewObjectID
   # If there was a previous object and we are changing its id, then we have to update all the script locals
   # that may contain references to the old object. This is rather ugly, but it allows things like undo to work
   # even when objects are moved.
   
   # Script cache, stores unapplied scripts when tabs are changed
   updateArrayKey sScriptCache, pOldObjectID, pNewObjectID
   
   # Undo stuff
   updateMultiItemArrayKey sTextOperationOffsets, pOldObjectID, pNewObjectID, 44, 1
   updateMultiItemArrayKey sTextOperationOldTexts, pOldObjectID, pNewObjectID, 44, 1
   updateMultiItemArrayKey sTextOperationNewTexts, pOldObjectID, pNewObjectID, 44, 1
   updateArrayKey sTextOperationTop, pOldObjectID, pNewObjectID
   updateArrayKey sTextOperationIndex, pOldObjectID, pNewObjectID
   
   updateMultiItemArrayKey sTextGroupLabels, pOldObjectID, pNewObjectID, 44, 1
   updateMultiItemArrayKey sTextGroupLengths, pOldObjectID, pNewObjectID, 44, 1
   updateArrayKey sTextGroupIndex, pOldObjectID, pNewObjectID
   updateArrayKey sTextGroupTop, pOldObjectID, pNewObjectID
   updateArrayKey sTextMark, pOldObjectID, pNewObjectID
end updateObjectID

# Parameters
#   pObjectId : reference to the object to set the script to. Must be one of the target objects of the script editor.
# Description
#   Clears the script cache for the specified object. This should be called when the object is being closed. The cache also
#   includes selection information.
command clearCache pObject, pDontCheckId
   local tObject
   if pDontCheckId then
      put pObject into tObject
   else
      put revRuggedId(pObject) into tObject
   end if
   delete variable sScriptCache[tObject]
end clearCache

# Parameters
#   pArray : reference to an array. This gets modified
#   pOldKey : one of the array keys
#   pNewKey : the new key to replace pOldKey with
# Description
#   Removes the element pOldKey from the array, and creates
#   a new element pNewKey with the same data. Essentially renaming the key.
#   If the element is empty, does nothing.
private command updateArrayKey @pArray, pOldKey, pNewKey
   local tData
   if pArray[pOldKey] is not empty then
      put pArray[pOldKey] into tData
      delete variable pArray[pOldKey]
      put tData into pArray[pNewKey]
   end if
end updateArrayKey

# Parameters
#   pArray : reference to an array. This gets modified
#   pOldKey : one of the array keys
#   pNewKey : the new key to replace pOldKey with
#   pDelimiter : an ascii char code that delimits dimensions in the array's key. If empty, comma is assumed.
#   pItemNumer : which item number of the key needs to match pOldKey
# Description
#   Removes all keys with the specified dimension matching pOldKey from the array
#   and replaces them with equivalent keys matching pNewKey.
private command updateMultiItemArrayKey @pArray, pOldKey, pNewKey, pDelimiter, pItemNumber
   local tData
   
   if pDelimiter is not empty then
      set the itemDelimiter to numToChar(pDelimiter)
   end if
   
   # Create a list of keys that need to be modified
   local tKeys
   repeat for each line tKey in the keys of pArray
      if item pItemNumber of tKey is pOldKey then
         put tKey & return after tKeys
      end if
   end repeat
   delete the last char of tKeys
   
   if tKeys is empty then
      exit updateMultiItemArrayKey
   end if
   
   # Apply the modification to the keys
   repeat for each line tKey in tKeys
      local tNewKey
      put tKey into tNewKey
      put pNewKey into item pItemNumber of tNewKey
      put pArray[tKey] into pArray[tNewKey]
      delete variable pArray[tKey]
   end repeat
end updateMultiItemArrayKey

command ResetProviders
   __AutoCompleteClearProviders
   __GenerateProvidersFromDocs
   put sRegisteredProviders into sProvidersIncludingMsgPath
   if exists(sObjectId) then
      __GenerateProvidersByIntrospectingMessagePath sObjectId, sProvidersIncludingMsgPath
   end if
end ResetProviders

command textInitialize
   if the number of elements of sRegisteredProviders is 0 and \
         "development" is in the environment then
      __GenerateProvidersFromDocs
   end if
   
   put empty into sTextOperationOffsets
   put empty into sTextOperationNewTexts
   put empty into sTextOperationOldTexts
   put 0 into sTextOperationIndex
   put 0 into sTextOperationTop
   
   put empty into sTextGroupLabels
   put empty into sTextGroupLengths
   put 0 into sTextGroupIndex
   put 0 into sTextGroupTop
   
   put empty into sTextMark
   
   textFormatInitialize
   
   textMark "Insert"
end textInitialize   

command getLastSelection
   return slastNonEmptySelection
end getLastSelection

command setLastSelectedChunk pSelection
   put pSelection into sLastSelectedChunk
end setLastSelectedChunk

command getLastSelectedChunk
   return sLastSelectedChunk
end getLastSelectedChunk

command getLastSelectedWord
   local tFrom, tTo
   put item 1 of sLastSelectedChunk into tFrom
   put item 2 of sLastSelectedChunk into tTo
   
   # If there is a non empty selection, just return that.
   if tTo > tFrom then
      return char tFrom to tTo of the text of getScriptField()
   end if
   
   # If the selection is in the middle of a word, then return that.
   # First loop back from the selected character to find the first part of the word. Keep going until we find a character
   # that is either whitespace, or a bracket.
   local tWordDivider
   put merge("^[\[[quote]]|\[|\]\(|\)|\s]$") into tWordDivider
   
   local tBefore
   repeat with x = tTo down to 1
      get char x of the text of getScriptField()
      if matchText(it, tWordDivider) then
         exit repeat
      end if
      put it before tBefore
   end repeat
   
   local tAfter
   repeat with x = tTo + 1 to the number of chars of the text of getScriptField()
      get char x of the text of getScriptField()
      if matchText(it, tWordDivider) then
         exit repeat
      end if
      put it after tAfter
   end repeat
   
   local tWord
   put tBefore & tAfter into tWord
   return tWord
end getLastSelectedWord

# Description
#   Returns whether or not undo is available in the current object. I.e. the script has been edited since it was opened in this
#   instance of the script editor.
command undoAvailable
   if sTextGroupIndex[sObjectId] is 0 then
      return false
   else
      return true
   end if
end undoAvailable

# Description
#   Returns whether or not redo is available in the current object. I.e. something has been undone since it was opened in
#   this instance of the script editor.
command redoAvailable
   if sTextGroupIndex[sObjectId] is sTextGroupTop[sObjectId] then
      return false
   else
      return true
   end if
end redoAvailable

on textMark pLabel
   put pLabel into sTextMark[sObjectId]
end textMark

on textBeginGroup pLabel, pObject
   local tObject
   if pObject is empty then
      put sObjectId into tObject
   else
      put pObject into tObject
   end if
   
   add 1 to sTextGroupIndex[tObject]
   
   put pLabel into sTextGroupLabels[tObject,sTextGroupIndex[tObject]]
   put 0 into sTextGroupLengths[tObject,sTextGroupIndex[tObject]]
   
   repeat with tIndex = sTextGroupIndex[tObject] + 1 to sTextGroupTop[tObject]
      delete variable sTextGroupLabels[tObject,tIndex]
      delete variable sTextGroupLengths[tObject,tIndex]
   end repeat
   
   repeat with tIndex = sTextOperationIndex[tObject] + 1 to sTextOperationTop[tObject]
      delete variable sTextOperationOffsets[tObject,tIndex]
      delete variable sTextOperationNewTexts[tObject,tIndex]
      delete variable sTextOperationOldTexts[tObject,tIndex]
   end repeat
   
   put sTextOperationIndex[sObjectId] into sTextOperationTop[tObject]
   put sTextGroupIndex[sObjectId] into sTextGroupTop[tObject]
   
   put empty into sTextMark[tObject]
end textBeginGroup

on textEndGroup
   if sTextGroupLengths[sObjectId,sTextGroupIndex[sObjectId]] = 0 then
      throw "empty_text_group_inserted"
   end if
   textMark "Insert"
end textEndGroup


-- Text Formatting Code
command textFormatInitialize
   -- permit use in environment witn no dependencies
   local tTabDepth = 3
   try
      put sePrefGet("editor,tabdepth") into tTabDepth
   end try
   
   put "0," & tTabDepth into sTextFormatKeywordMap["try"]
   put "0," & tTabDepth into sTextFormatKeywordMap["switch"]
   put "0," & tTabDepth into sTextFormatKeywordMap["if"]
   put -tTabDepth & ",0" into sTextFormatKeywordMap["endif"]
   put -tTabDepth & comma & tTabDepth into sTextFormatKeywordMap["elseif"]
   put "0," & tTabDepth into sTextFormatKeywordMap["repeat"]
   
   put "0," & tTabDepth into sTextFormatKeywordMap["on"]
   put "0," & tTabDepth into sTextFormatKeywordMap["function"]
   put "0," & tTabDepth into sTextFormatKeywordMap["setprop"]
   put "0," & tTabDepth into sTextFormatKeywordMap["getprop"]
   put "0," & tTabDepth into sTextFormatKeywordMap["command"]
   put "0," & tTabDepth into sTextFormatKeywordMap["private"]
   put "0," & tTabDepth into sTextFormatKeywordMap["before"]
   put "0," & tTabDepth into sTextFormatKeywordMap["after"]
   
   put -tTabDepth & comma & tTabDepth into sTextFormatKeywordMap["else"]
   put -tTabDepth & comma & tTabDepth into sTextFormatKeywordMap["case"]
   put -tTabDepth & comma & tTabDepth into sTextFormatKeywordMap["default"]
   put -tTabDepth & comma & tTabDepth into sTextFormatKeywordMap["catch"]
   put -tTabDepth & comma & tTabDepth into sTextFormatKeywordMap["finally"]
   put -tTabDepth & comma & tTabDepth into sTextFormatKeywordMap["catch"]
   --put -tTabDepth & comma & tTabDepth into sTextFormatKeywordMap["break"]
   put 0 & comma & 0 into sTextFormatKeywordMap["break"]
   
   put -tTabDepth & ",0" into sTextFormatKeywordMap["end"]
end textFormatInitialize

private function textFormatIndentLineAdds pLine
   local tToken
   put token 1 of pLine into tToken
   if tToken is "if" then
      if "else" is among the words of pLine then
         return 0
      else if token -1 of pLine is not "then" then
         return 0
      else
         return item 2 of sTextFormatKeywordMap["if"]
      end if
      
   else if tToken is "else" then
      if token 2 of pLine is "if" then
         if "else" is among the words of word 3 to -1 of pLine then
            return 0
         else if token -1 of pLine is not "then" then
            return 0
         else
            return item 2 of sTextFormatKeywordMap["elseif"]
         end if
      else if token 2 of pLine is not empty then
         return 0
      else
         return item 2 of sTextFormatKeywordMap["else"]
      end if
      
   else if token 1 of pLine is empty then
      return 0
      ## Bug 10467 - else in a comment was causing incorrect indentation
      ## Check for "else" in line without comments
      --else if token 1 of pLine is not "else" and "else" is among the words of pLine then
   else if token 1 of pLine is not "else" and "else" is among the words of lineStripComments(pLine) then
      -- permit use in environment witn no dependencies
      local tTabDepth = 3
      try
         put sePrefGet("editor,tabdepth") into tTabDepth
      end try
      return -tTabDepth
   else if token -1 of pLine is "then" then
      # Either a weirdly formatted if structure, or the condition of the if contained a line continuation character.
      # In this case, behave as though pLine is a normal if.
      return item 2 of sTextFormatKeywordMap["if"]
   else
      return item 2 of sTextFormatKeywordMap[tToken]
   end if
   return 0
end textFormatIndentLineAdds


private function textFormatIndentLineRemoves pPreviousLine, pLine
   local tToken
   put token 1 of pLine into tToken
   if tToken is "else" then
      if token 2 of pLine is "if" then
         if "then" is among the words of pPreviousLine and token -1 of pPreviousLine is not "then" then
            return 0
         else
            return item 1 of sTextFormatKeywordMap["elseif"]
         end if
         
      else
         if "then" is among the words of pPreviousLine and token -1 of pPreviousLine is not "then" then
            return 0
         else
            return item 1 of sTextFormatKeywordMap["else"]
         end if
      end if
   else if tToken is empty then
      # Comments and empty lines do not remove any formatting
      return 0
   else if tToken is "end" and token 2 of pLine is "switch" and token 1 of pPreviousLine is not "switch" then
      # Special case for end switch if there is a preceeding "break", "default" or other statement, we need to remove
      # double the normal indent.
      return (2 * item 1 of sTextFormatKeywordMap["end"])
   else if tToken is "case" then
      # A case statement removes indent from the previous line in all cases except if the
      # previous line was the beginning of the parent switch structure.
      if token 1 of pPreviousLine is "switch"  then
         return 0
      else
         return item 1 of sTextFormatKeywordMap["case"]
      end if
      # OK-2009-04-28 : Bug 8016 - Special case required for "default" to make switches format correctly.
   else if tToken is "default" then
      if token 1 of pPreviousLine is "switch" then
         return 0
      else
         return item 1 of sTextFormatKeywordMap["default"]
      end if
   else if tToken is "end" and token 2 of pLine is not among the words of "if switch repeat try" and not lineIsContinued(pLine) then
      # Handler ends always remove all indentation as they can't be nested
      # OK-2009-02-16 : Bug 7707 - We can't assume the previous line was correctly formatted or script may be deleted.
      # Instead we simplify this by simply chopping off whatever indentation it did have.
      --return min(-(the number of chars of textFormatGetLineIndent(pPreviousLine)), item 1 of sTextFormatKeywordMap[tToken])
      return item 1 of sTextFormatKeywordMap["end"]
   else
      # We can't assume that the previous line was correctly indented
      # because the script might have been edited from outside this script editor. Therefore
      # we have to ensure that a line doesnt try to remove more formating than the previous
      # line actually had. Otherwise non-whitespace chars may be deleted.
      if the number of chars of textFormatGetLineIndent(pPreviousLine) + the number of chars of textFormatGetLineIndent(pLine) + textFormatIndentLineAdds(pPreviousLine) < abs(item 1 of sTextFormatKeywordMap[tToken]) then
         return -(the number of chars of textFormatGetLineIndent(pPreviousLine))
      else
         return item 1 of sTextFormatKeywordMap[tToken]
      end if
   end if
end textFormatIndentLineRemoves

private function textFormatGetLineIndent pLine
   local tResult
   repeat for each char tChar in pLine
      if tChar is space then
         put space after tResult
      else
         return tResult
      end if
   end repeat
   return tResult
end textFormatGetLineIndent

private function lineIsContinued pLine
   if word -1 of pLine is "\" then
      return true
   else
      return false
   end if
end lineIsContinued

private function textFormatGetContinuationIndent pLastLineNumber
   # In order to calculate the indentation we need to loop back until we find the start of the continuation,
   # constructing a string which is the equivalent of the continued line in a single line. We then use this to calculate
   # the indent of the last line 
end textFormatGetContinuationIndent

private function combineContinuedLine pLastLineNumber, @pTextLines
   local tContinuation
   put pTextLines[pLastLineNumber] into tContinuation
   
   local tIndex
   repeat with tIndex = (pLastLineNumber - 1) down to 1
      if not lineIsContinued( pTextLines[tIndex]) then
         exit repeat
      end if
      
      put pTextLines[tIndex] before tContinuation
   end repeat
   replace "\" with empty in tContinuation
   return tContinuation
end combineContinuedLine

constant kContinuationIndent = 6

private function textFormatLine pLine, pTextLines, @xPreviousLine
   local tResult
   
   # OK-2009-01-30 : Bug 7051 - Deal better with continuation characters.
   local tCurrentLineIsContinued
   local tPreviousLineWasContinued
   local tPreviousPreviousLineWasContinued
   
   # Continuations can only happen with consecutive lines, there can't be comments or empty lines in between,
   # so we simply use the two previous lines to work out if they are continued or not. If these lines are empty
   # or are comments, then the result will be that they are not continuations anyway which is correct.
   put lineIsContinued(pTextLines[pLine - 1]) into tPreviousLineWasContinued
   put lineIsContinued(pTextLines[pLine - 2]) into tPreviousPreviousLineWasContinued
   
   put lineIsContinued(pTextLines[pLine]) into tCurrentLineIsContinued
   
   # Get the previous non-empty line
   if xPreviousLine is 0 and pLine > 1 then
      put pLine into xPreviousLine
      repeat while xPreviousLine > 1
         subtract 1 from xPreviousLine
         if token 1 of pTextLines[xPreviousLine] is not empty then
            exit repeat
         end if 
      end repeat
   end if
   
   local tPreviousLine
   if xPreviousLine > 0 then
      # This is the case where we have reached the end of a continued line. Here, we treat the continued line
      # as a single entity in order to calculate its indentation properties correctly for the line after it.
      if lineIsContinued(pTextLines[xPreviousLine - 1]) then
         put combineContinuedLine(xPreviousLine, pTextLines) into tPreviousLine
      else
         put pTextLines[xPreviousLine] into tPreviousLine
      end if
      
      # Get the current indent of the previous line
      local tPreviousLineIndent
      put textFormatGetLineIndent(tPreviousLine) into tPreviousLineIndent
   end if
   
   # Get the current indent of the line
   local tCurrentLineIndent
   put textFormatGetLineIndent(pTextLines[pLine]) into tCurrentLineIndent
   
   # Work out how much indentation the current line should remove from the previous line
   local tIndentCurrentLineRemoves
   if tPreviousLineWasContinued then
      put 0 into tIndentCurrentLineRemoves
   else
      put textFormatIndentLineRemoves(tPreviousLine, pTextLines[pLine]) into tIndentCurrentLineRemoves
   end if
   
   # Work out how much indentation the previous line should add to the current line.
   local tIndentPreviousLineAdds
   if xPreviousLine is 0 then
      put 0 into tIndentPreviousLineAdds
   else if tPreviousLineWasContinued then
      # we always add the continuation indent because we combined the continued lines
      put kContinuationIndent into tIndentPreviousLineAdds
   else
      put textFormatIndentLineAdds(pTextLines[xPreviousLine]) into tIndentPreviousLineAdds
   end if
   
   local tCurrentIndent
   repeat (the number of chars of tPreviousLineIndent + tIndentCurrentLineRemoves + tIndentPreviousLineAdds)
      put space after tCurrentIndent
   end repeat
   
   put ((the number of chars of tPreviousLineIndent + tIndentCurrentLineRemoves + tIndentPreviousLineAdds) - the number of chars of tCurrentLineIndent) & comma into tResult
   
   -- Finally, calculate the expected next indent.
   local tNewIndent
   put tCurrentIndent into tNewIndent
   
   local tIndentCurrentLineAdds
   if tCurrentLineIsContinued and tPreviousLineWasContinued then
      put 0 into tIndentCurrentLineAdds
   else if tCurrentLineIsContinued and (not tPreviousLineWasContinued) then
      put kContinuationIndent into tIndentCurrentLineAdds
   else if (not tCurrentLineIsContinued) and tPreviousLineWasContinued then
      put -kContinuationIndent into tIndentCurrentLineAdds
   else
      put textFormatIndentLineAdds(pTextLines[pLine]) into tIndentCurrentLineAdds
   end if
   
   if tIndentCurrentLineAdds < 0 then
      repeat -tIndentCurrentLineAdds times
         delete char 1 of tNewIndent
      end repeat
   else
      repeat tIndentCurrentLineAdds times
         put space after tNewIndent
      end repeat
   end if
   
   put tNewIndent after tResult
   
   if token 1 of pTextLines[pLine] is not empty then
      put pLine into xPreviousLine
   end if
   return tResult
end textFormatLine

# Returns
#   The chunk of pLine from the beginning of the first word to the end.
private function firstWordToEnd pLine
   local tOffset
   put offset(word 1 of pLine, pLine) into tOffset
   return char tOffset to -1 of pLine
end firstWordToEnd

# Formats the specified script snippet.
command scriptFormatSnippet pScript
   textFormatInitialize
   local tNewScript
   put textFormatSelection(pScript) into tNewScript
   return tNewScript
end scriptFormatSnippet

# Parameters
#   pText : the text to format
private function textFormatSelection pText
   local tResult
   local tPreviousLine = 0
   local tTextLines
   put pText into tTextLines
   split tTextLines by return
   
   get textFormatLine(1, tTextLines, tPreviousLine)
   put firstWordToEnd(tTextLines[1]) into tTextLines[1]
   put tTextLines[1] into tResult
   local tIndex
   repeat with tIndex = 2 to the number of elements of tTextLines
      put item 2 of it & firstWordToEnd(tTextLines[tIndex]) into tTextLines[tIndex]
      get textFormatLine(tIndex, tTextLines, tPreviousLine)
      
      if item 1 of it < 0 then
         repeat -(item 1 of it) times
            if char 1 of line -1 of tTextLines[tIndex] is space then
               delete char 1 of tTextLines[tIndex]
            end if
         end repeat
      else if item 1 of it > 0 then
         repeat item 1 of it times
            put space before tTextLines[tIndex]
         end repeat
      end if
      
      put return & tTextLines[tIndex] after tResult
   end repeat
   
   return tResult
end textFormatSelection

private function handlerTypes
   return "command,on,function,setprop,getprop,before,after"
end handlerTypes

private function textFormat pLineNumber, pLineCount, pText
   -- Find the range to format.
   -- 1. Search down until we find a handler (a) or the end of one (b).
   -- 2. Based on 1, in case a, search up until we find the end of any other handler, or the beginning of the script.
   --    In case b we need to search for the start of that handler.
   local tEnd
   
   local tText
   put pText into tText
   split tText by return
   put pLineNumber into tEnd
   
   # Search down to find what the handler name is and whether pLineNumber is the first line of the handler.
   local tHandler
   local tFirstLine
   put true into tFirstLine
   
   local tContinuation, tCurrentLineContinues
   put lineIsContinued(tText[pLineNumber-1]) into tContinuation
   
   local tLineIndex
   repeat with tLineIndex = pLineNumber to the number of elements of tText
      put lineIsContinued(tText[tLineIndex]) into tCurrentLineContinues
      if token 1 of tText[tLineIndex] is "end" and token 2 of tText[tLineIndex] is not among the items of "if,repeat,switch,try" and not tContinuation and not tCurrentLineContinues then
         put true into tHandler[token 2 of tText[tLineIndex]]
         if pLineCount < 0 then
            exit repeat
         end if
      else if token 1 of tText[tLineIndex] is among the items of handlerTypes() and not tFirstLine then
         if pLineCount < 0 then
            exit repeat
         end if
         exit repeat
      else if token 1 of tText[tLineIndex] is "private" and token 2 of tText[tLineIndex] is among the items of handlerTypes() and not tFirstLine then
         if pLineCount < 0 then
            exit repeat
         end if
         exit repeat
      else
         put tCurrentLineContinues into tContinuation
      end if
      if tFirstLine then put false into tFirstLine
      subtract 1 from pLineCount
      add 1 to tEnd
   end repeat
   
   # Search up to find the beginning of the handler, or the beginning of the script if not found.
   local tStart
   repeat with tLineIndex = pLineNumber down to 1
      put tLineIndex into tStart
      if tHandler is an array then
         if token 1 of tText[tLineIndex] is among the items of  handlerTypes() and tHandler[token 2 of tText[tLineIndex]] then
            exit repeat
         else if token 1 of tText[tLineIndex] is "private" and token 2 of tText[tLineIndex] is among the items of handlerTypes() and tHandler[token 3 of tText[tLineIndex]] then
            exit repeat
         end if
      else if token 1 of tText[tLineIndex] is "end" and token 2 of tText[tLineIndex] is not among the items of "if,repeat,switch,catch" then
         exit repeat
      end if
   end repeat
   
   if tHandler is not an array and tStart is not 1 then
      add 1 to tStart
   end if
   if tEnd > the number of elements of tText then
      put the number of elements of tText into tEnd
   end if
   
   -- Now format lines tStart to tEnd of pText, and return the result.
   local tStartChar
   if tStart is 1 then
      put 1 into tStartChar
   else
      put the number of chars of line 1 to (tStart - 1) of pText into tStartChar
      add 2 to tStartChar
   end if
   
   local tOldText
   put line tStart to tEnd of pText into tOldText
   
   local tResult
   put tStartChar into tResult["startchar"]
   put tOldText into tResult["oldtext"]
   put textFormatSelection(tOldText) into tResult["newtext"]
   
   return tResult
end textFormat

function textGetScript
   return the text of field "Script" of me
end textGetScript

function getScriptField
   return the long id of field "Script" of me
end getScriptField

on textSetSelection pAfterChar
   select after char pAfterChar of field "Script" of me
end textSetSelection

# Parameters
#   pOldText : the text replaced in an operation
#   pNewText : the replacing text in an operation
# Returns
#   Whether or not a new undo group is needed for the specified
#   operation.
private function textReplaceNewGroupNeeded pOldText, pNewText
   # If the invoker of the replacement operation has specified that an undo group
   # is needed, always create one
   if sTextMark[sObjectId] is not empty then
      return true
   end if
   
   # If the number of chars of either the string replaced or replacing string is above one
   # this means it must be a deletion of a selection or a cut or paste. This should always
   # require a new group
   if the number of chars of pOldText > 1 or the number of chars of pNewText > 1 then
      return true
   end if
   
   # If either the text being replaced or the replacing text contain return chars, new group
   if pOldText contains return or pNewText contains return then
      return true
   end if
   
   return false
end textReplaceNewGroupNeeded

# Parameters
#   pOffset : the char number of where the replacement should start
#   pOldText : the text that is being replaced
#   pNewText : the text that is being inserted
#   pObject : the long id of the object to replace in. If not given, the current object is assumed.
# Description
#   This is the point through which all standard editing operations on scripts are sent through.
#   Any change made via this function will be added to the undo system. This is called when the
#   user types keys, formats text, cuts, pastes etc.
command textReplace pOffset, pOldText, pNewText, pObject, pDontGroup
   __ClearHighlights
   
   local tObject
   if pObject is empty then
      put sObjectId into tObject
   else
      put pObject into tObject
   end if
   
   local tUUID
   put the linkText of char pOffset of field "Script" of me into tUUID
   
   local tBracketCompletionType
   __BracketCompletion  pOffset, pOldText, pNewText
   put it into tBracketCompletionType
   
   local tSelection
   if tBracketCompletionType is "wrap" then
      put the selectedChunk into tSelection
      add 1 to word 2 of tSelection
      add 1 to word 4 of tSelection
   end if
   
   if pDontGroup is not true and textReplaceNewGroupNeeded(pOldText, pNewText) then
      textBeginGroup sTextMark[tObject], tObject
   end if
   
   add 1 to sTextOperationIndex[tObject]
   add 1 to sTextGroupLengths[tObject,sTextGroupIndex[tObject]]
   
   put pOffset into sTextOperationOffsets[tObject,sTextOperationIndex[tObject]]
   put pOldText into sTextOperationOldTexts[tObject,sTextOperationIndex[tObject]]
   put pNewText into sTextOperationNewTexts[tObject,sTextOperationIndex[tObject]]
   
   # When the script has been edited, the breakpoints should be suspended until it is applied again.
   # Because this command is called as the user types, we could a send in time for this, as its not that urgent.
   try
      revDebuggerSuspendBreakpoints tObject
   end try
   
   # If the specified object to replace in is the current object being edited, we perform the replace
   # directly on the script editing field using textReplaceRaw. Otherwise we perform it on the
   # script cache stored for the object.
   if tObject is empty or revRuggedId(tObject) is sObjectId then
      textReplaceRaw pOffset, pOldText, pNewText
      if tBracketCompletionType is "pair" then
         select after char pOffset of field "script" of me
      else if tBracketCompletionType is "wrap" then
         select tSelection
      end if
   else
      local tCache
      put sScriptCache[revRuggedId(tObject)] into tCache
      if tCache is empty then
         put the script of tObject into tCache
      end if
      textReplaceRawInVariable tCache, pOffset, pOldText, pNewText
      put tCache into sScriptCache[revRuggedId(tObject)]
   end if
   
   set the caseSensitive to true
   if pOldText is not pNewText then
      try
         seSetObjectState tObject, "edited"
      end try
      # OK-2009-01-17 : Bug 7169 - Flag the object as dirty when it is modifed by this method only.
      # The textReplaceRaw etc functions should not do this as they do not represent a user modifying
      # the script.
      setDirty tObject, true
   end if
   
   __UpdateAutoCompleteList  tUUID
end textReplace

# Parameters
#   pOffset : the char number to begin the replacement at
#   @rScript : the text to perform the replacement in, gets mutated
#   @pOldText : the text that is to be replaced. This is not mutated, its a reference for efficiency reasons
#   @pNewText : the text to be inserted. This is not mutated, its a reference for efficiency reasons
# Description
#   Performs a raw replace exactly as textReplaceRaw, except in a variable instead of directly in the editing field.
#   This is used by replace-all, because it may need to replace text in the script of objects which are not open.
command textReplaceRawInVariable @rScript, pOffset, @pOldText, @pNewText
   local tOldLength
   put the length of pOldText into tOldLength
   put pNewText into char pOffset to pOffset + tOldLength - 1 of rScript
end textReplaceRawInVariable

# Parameters
#   pOffset : the char number to begin the replacement at
#   @pOldText : the text that is to be replaced. This is not mutated, its a reference for efficiency reasons
#   @pNewText : the text to be inserted. This is not mutated, its a reference for efficiency reasons
#   pDontUpdateBreakpoints : optional, defaults to false. If this is true, breakpoints in the gutter are not moved.
# Description
#   This is the raw replacement operation that performs a mutation on the script field without
#   saving any undo information. This should be called only from inside textReplace, when doing an undo or a redo
#   and when setting the script when a new object is loaded.
private command textReplaceRaw pOffset, @pOldText, @pNewText, pDontUpdateBreakpoints
   lock screen
   lock messages
   
   local tSelectedLine
   put word 2 of the selectedLine into tSelectedLine
   
   local tEndOffset
   put max(0, pOffset + the length of pOldText - 1) into tEndOffset

   _internal script replace char pOffset to tEndOffset of field "Script" of me with pNewText
   
   --Do some work to update the gutter.
   local tOldLines, tNewLines
   put the number of lines of pOldText into tOldLines
   if pOldText is not return and (char -1 of pOldText is return or pOldText is empty) then
      add 1 to tOldLines
   end if
   if pNewText is empty and pOldText is return then
      put 0 into tNewLines
   else
      put the number of lines of pNewText into tNewLines
      if char -1 of pNewText is return or pNewText is return or pNewText is empty then
         add 1 to tNewLines
      end if
   end if
   
   if pDontUpdateBreakpoints then
      updateGutterRequest empty, empty, tOldLines, tNewLines, false, false
   else
      updateGutterRequest pOffset, tSelectedLine, tOldLines, tNewLines, true, false
   end if
   
   unlock messages
   
   # OK-2008-09-10 : Bug 7132 - Update the panes  and handler list everytime the text of the field is changed.
   # OK-2009-01-19 : Don't do this here as it slows down the script editor on OS X. Instead do it in the individual
   # cases where it may be needed, cut, paste, return, delete, backspace, undo and redo
   --selectionUpdateRequest
   
   unlock screen
end textReplaceRaw

-- Sets the contents of the fields to pScript WITHOUT touching the undo queue. This should be done before any editing.
on textSetScriptRaw pScript
   --put empty into field "Script" of me
   local tOldText
   put the text of field "Script" of me into tOldText
   if tOldText is not pScript then
      textReplaceRaw 1, tOldText, pScript, true
   end if
end textSetScriptRaw

-- Sets the script within the undo queue.
on textSetScript pScript
   textReplace 1, the text of field "Script" of me, pScript
end textSetScript

# Description
#   Performs an undo operation on the current script
on textUndo
   undoAvailable
   if not the result then
      exit textUndo
   end if
   
   local tOperations
   put sTextGroupLengths[sObjectId,sTextGroupIndex[sObjectId]] into tOperations
   lock screen
   repeat with tIndex = sTextOperationIndex[sObjectId] down to sTextOperationIndex[sObjectId] - tOperations + 1
      local tNewText, tOldText
      put sTextOperationNewTexts[sObjectId,tIndex] into tNewText
      put sTextOperationOldTexts[sObjectId,tIndex] into tOldText
      textReplaceRaw sTextOperationOffsets[sObjectId,tIndex], tNewText, tOldText
   end repeat
   unlock screen
   
   subtract tOperations from sTextOperationIndex[sObjectId]
   subtract 1 from sTextGroupIndex[sObjectId]
   
   if there is a sObjectId then
      revDebuggerSuspendBreakpoints sObjectId
      seSetObjectState sObjectId, "edited"
   end if
   
   textMark "Insert"
end textUndo

# Description
#   Performs a redo operation on the current script
on textRedo
   redoAvailable
   if not the result then
      exit textRedo
   end if
   
   add 1 to sTextGroupIndex[sObjectId]
   
   local tOperations
   put sTextGroupLengths[sObjectId,sTextGroupIndex[sObjectId]] into tOperations
   lock screen
   repeat with tIndex = sTextOperationIndex[sObjectId] + 1 to sTextOperationIndex[sObjectId] + tOperations
      local tNewText, tOldText
      put sTextOperationOldTexts[sObjectId,tIndex] into tOldText
      put sTextOperationNewTexts[sObjectId,tIndex] into tNewText
      textReplaceRaw sTextOperationOffsets[sObjectId,tIndex], tOldText, tNewText
   end repeat
   unlock screen
   
   add tOperations to sTextOperationIndex[sObjectId]
   if there is a sObjectId then
      revDebuggerSuspendBreakpoints sObjectId
      seSetObjectState sObjectId, "edited"
   end if
   textMark "Insert"
end textRedo

# Description
#   This is a debugging command used to print the status of the undo queue when investigating
#   problems. It should not be called anywhere in the code.
on textPrint
   lock screen
   
   local tOperation
   put 1 into tOperation
   repeat with x = 1 to sTextGroupTop[sObjectId]
      
      put "Group(" & x & "):" && sTextGroupLabels[sObjectId,x] & return after message
      repeat sTextGroupLengths[sObjectId,x] times
         
         local tOldText, tNewText
         put sTextOperationOldTexts[sObjectId,tOperation] into tOldText
         put sTextOperationNewTexts[sObjectId,tOperation] into tNewText
         replace return with "\n" in tOldText
         replace return with "\n" in tNewText
         
         put tab & "[" & tOperation & "]:" && sTextOperationOffsets[tOperation], tOldText, tNewText & return after message
         
         if tOperation is sTextOperationIndex[sObjectId] then
            put tab & "--------" & return after message
         end if
         
         add 1 to tOperation
      end repeat
      
      if x is sTextGroupIndex[sObjectId] then
         put "--------" & return after message
      end if
   end repeat
   
   unlock screen
end textPrint

command cancelPendingMessages
   if sGutterUpdateRequest is not empty then
      cancel sGutterUpdateRequest
   end if
   
   if sSelectionUpdateRequest is not empty then
      cancel sSelectionUpdateRequest
   end if
   
   if sPaneUpdateRequest is not empty then
      cancel sPaneUpdateRequest
   end if
   
   if sLastFindMessageID is not empty then
      cancel sLastFindMessageID
   end if
end cancelPendingMessages


private command updateGutterMergeRequestDetails pOffset, pSelectedLine, pOldLines, pNewLines, pTextChanged, pUpdateCompilationErrors, pForceBreakpointRedraw
   # The offset and selected line are just overwritten providing they are not empty
   if pOffset is not empty then
      put pOffset into sGutterUpdateRequestDetails["offset"]
   end if
   
   if pSelectedLine is not empty then
      put pSelectedLine into sGutterUpdateRequestDetails["selectedLine"]
   end if
   
   # The old number of lines is not changed, however if its empty, we put the new value in
   if sGutterUpdateRequestDetails["oldLines"] is empty then
      put pOldLines into sGutterUpdateRequestDetails["oldLines"]
   end if
   
   # The new number of lines overwrites the previous setting, again providing that its not empty
   if pNewLines is not empty then
      put pNewLines into sGutterUpdateRequestDetails["newLines"]
   end if
   
   # The new text changed value is the logical OR of the new and old values
   # The same is done for the update compilation errors and the force breakpoint redraw 
   put (pTextChanged or sGutterUpdateRequestDetails["textChanged"]) into sGutterUpdateRequestDetails["textChanged"]
   put (pUpdateCompilationErrors or sGutterUpdateRequestDetails["updateCompilationErrors"]) into sGutterUpdateRequestDetails["updateCompilationErrors"]
   put (pForceBreakpointRedraw or sGutterUpdateRequestDetails["forceBreakpointRedraw"]) into sGutterUpdateRequestDetails["forceBreakpointRedraw"]
end updateGutterMergeRequestDetails

command deleteUpdateGutterRequestDetails
   delete variable sGutterUpdateRequestDetails
end deleteUpdateGutterRequestDetails

function getUpdateGutterRequestDetails 
   return sGutterUpdateRequestDetails
end getUpdateGutterRequestDetails

# Parameters
#   pOffset : the offset of the last text change
#   pSelectedLine : the selected line at the point of the last text change
#   pOldLines : the old number of lines in the script field at the point of the last text change
#   pNewLines : the new number of liens in the script field after the last text change
#   pTextChanged : whether text was changed or not since the last gutter update. If this is false, all the previous parameters are ignored.
#   pUpdateCompilationErrors : whether to update the gutter's compilation errors
# Description
#   Sends a request to update the gutter. This is called whenever the current script is edited, or the field
#   is scrolled etc. A request is sent using a short delay and any previous requests are cancelled.
#  The gutter's scroll is updated immediately however. Also a message is sent to the gutter to hide its
#  mutable objects (the breakpoint / compilation error images). These are show again when the update is
#  actually carried out.
command updateGutterRequest pOffset, pSelectedLine, pOldLines, pNewLines, pTextChanged, pUpdateCompilationErrors, pForceBreakpointRedraw
   updateGutterMergeRequestDetails pOffset, pSelectedLine, pOldLines, pNewLines, pTextChanged, pUpdateCompilationErrors, pForceBreakpointRedraw
   if sGutterUpdateRequest is not empty then
      cancel sGutterUpdateRequest
   end if
   
   # We always update the gutter's scroll immediately, as otherwise it looks bad. Other stuff is delayed though.
   if there is a group "Gutter" of me then
      send "updateScroll" to group "Gutter" of me
   end if
   send "updateGutterDo" to me in 5 milliseconds
   put the result into sGutterUpdateRequest
   
   __UpdateAutoCompleteList
end updateGutterRequest

# update gutter stubs
on updateGutterDo
end updateGutterDo

# Description
#   Sends a request to the script editor to update the panes. Requests are sent
#   only after a period of inactivity to prevent bombardment.
command paneUpdateRequest
   if sPaneUpdateRequest is not empty then
      cancel sPaneUpdateRequest
   end if
   
   -- allow environment with no dependencies
   local tDelay = 500
   try
      put sePrefGet("editor,paneupdatedelay") into tDelay
   end try
   send "paneUpdate" to me in tDelay milliseconds
   put the result into sPaneUpdateRequest
end paneUpdateRequest

# pane update stubs
command paneUpdate
end paneUpdate

-- This is sent by the engine
on selectionChanged
   if not handleEvent("selectionChanged", the long id of the target) then
      pass selectionChanged
   end if
   if not (sArrowKeyPressed) then
      handleSelectionChanged
   end if
   -- Unmark found results when clicking on the SE
   selectionUpdateRequest
end selectionChanged

on arrowKey pArrowKey
   local tHighlightedLine
   if the visible of group "completion info" of me and \
         pArrowKey is among the items of "up,down" then
      put the hilitedLine of field "completions" of group "completion info" of me into tHighlightedLine
      switch pArrowKey
         case "up"
            __DisplayCompletions max(1,tHighlightedLine-1)
            break
         case "down"
            __DisplayCompletions min(the number of lines of field "completions" of group "completion info" of me,tHighlightedLine+1)
            break
      end switch 
   else
      pass arrowKey
   end if
end arrowKey

on selectionChangedByArrowKey pArrowKey
   saveLastSelections
   put false into sArrowKeyPressed
   
   -- [[ Bug 18595 ]] We need this here otherwise the "it" var in the if block below is empty
   get the selectedChunk
   
   local tAt
   if word 2 of it > word 4 of it then
      put word 4 of it into tAt
   else
      -- It is a multiple selection, so we need to exit this.
      exit selectionChangedByArrowKey
   end if
   
   -- Single selection in the process of making a larger selection, so exit if shift is down.
   if the shiftKey is "down" then
      exit selectionChangedByArrowKey
   end if
   
   local tLine
   put word 2 of the selectedLine into tLine
   
   local tField
   put the long id of the selectedField into tField
   
   local tScript
   put the text of tField into tScript
   
   local tLineStart
   switch pArrowKey
      case "left"
         put the number of chars of line 1 to (tLine - 1) of tScript + 1 into tLineStart
         # OK-2008-03-03 : Only add offset of return if we are not on the first line of the script
         if tLine is not 1 then
            add 1 to tLineStart
         end if
         put caretPositionLeft(tLineStart, tAt + 1, tScript) into tAt
         
         lock messages
         select after char tAt of tField
         unlock messages
         break
      case "right"
         caretUpdate tField, tScript
         break
         if char (tAt + 1) of tScript is return then
            add 1 to tLine
         end if
         put the number of chars of line 1 to (tLine - 1) of tScript + 2 into tLineStart
         get line tLine of tScript
         put caretPositionRight(tLineStart, tAt + 1, it) into tAt
         break
      case "up"
      case "down"
         caretUpdate tField, tScript
         break
      case "empty"
      default
         caretUpdate tField, tScript
         break
   end switch
   
   textMark "Insert"
   selectionUpdateRequest
end selectionChangedByArrowKey
   
   
   
   -- PM-2016-09-22: [[ Bug 15887 ]] Distinguish between "selectionChanged" sent by the engine and \
         -- "selectionChangedByArrowKey pArrowKey"
on handleSelectionChanged
   saveLastSelections
   
   caretUpdate
end handleSelectionChanged

private command saveLastSelections
   if the selectedText of field "Script" of me is not empty then
      put the selectedText of field "Script" of me into sLastNonEmptySelection
   end if
   
   -- [[ Bug 18528 ]] We need this here otherwise the "it" var in the if block below is empty
   get the selectedChunk
   
   # OK-2008-10-22 : Bug 7343 - Must save the last selection point as its lost
   # when the user begins typing into the search field.
   if the long id of the focusedObject is the long id of field "Script" of me then
      put word 2 of it & comma & word 4 of it into sLastSelectedChunk
   end if
end saveLastSelections

private command selectionUpdateRequest
   if not handleEvent("selectionUpdateRequest", the long id of the target) then
      exit selectionUpdateRequest
   end if
   
   if sSelectionUpdateRequest is not empty then
      cancel sSelectionUpdateRequest
   end if
   
   -- handled by child behavior
   send "selectionUpdate" to me in 10 milliseconds
   put the result into sSelectionUpdateRequest
end selectionUpdateRequest

#selection update stubs
on selectionUpdate
   lock screen
   __CheckHighlights
   __ClearCurrentPlaceholder
   __UpdateSelection
   __UpdateAutoCompleteList
   unlock screen
end selectionUpdate

on mouseMove
   lock screen
   if there is a group "completion info" and \
         the visible of group "completion info" then
      __CancelFindProviders
   end if
   unlock screen
   pass mouseMove
end mouseMove

-- This calculates the position of the caret based on pPosition where the caret is (hypothetically).
private function caretPositionRight pLineStartChar, pProposedPosition, pLine
   local tFirstPosition
   put pLineStartChar - 1 into tFirstPosition
   repeat for each char tChar in pLine
      if tChar is space then
         add 1 to tFirstPosition
      else
         exit repeat
      end if
   end repeat
   
   return max(tFirstPosition, pProposedPosition)
end caretPositionRight

-- On moving the caret/backspace left, this returns the correct char position.
private function caretPositionLeft pLineStartChar, pCurrentPosition, pScript
   repeat with x = pCurrentPosition down to pLineStartChar
      if char x of pScript is not space then
         return (pCurrentPosition-1)
         break
      end if
   end repeat
   return pLineStartChar - 2
end caretPositionLeft

private command caretUpdate pField, pScript
   get the selectedChunk
   -- a text selection
   if word 2 of it <= word 4 of it then
      exit caretUpdate
   end if
   
   local tLine
   put word 2 of the selectedLine into tLine
   
   local tField
   if pField is empty then
      put the long id of the selectedField into tField
   else
      put pField into tField
   end if
   
   local tScript
   if pScript is empty then
      put the text of the selectedField into tScript
   else
      put pScript into tScript
   end if
   
   # The current line is the first then its first char is char 1, otherwise it is the number of
   # chars of all previous lines + 1 char for the return char and 1 for the first char of the line.
   local tLineStart
   if tLine is 1 then
      put 1 into tLineStart
   else
      put the number of chars of line 1 to (tLine - 1) of tScript + 2 into tLineStart
   end if
   
   lock messages -- dont cause selectionChanged loop
   
   select after char caretPositionRight(tLineStart, word 4 of the selectedChunk, line tLine of tScript) of tField
   
   unlock messages
end caretUpdate


# Offset between a field's top margin and the start of the text
constant kFudge = "-4"

# Parameters
#   pLineNumber : a line number in the script of the current object
# Returns
#   The vertical location of that line in the gutter or 0 if the line is not visible
function lineNumberToVerticalLoc pLineNumber
   local tField
   put getScriptField() into tField
   
   local tHeight
   put (pLineNumber - 1) * the effective textHeight of getScriptField() into tHeight
   
   # If the breakpoint is on a line earlier than the first one in the visible area then don't render it
   if tHeight < the vScroll of getScriptField() then
      return 0
   end if
   
   # If the breakpoint is on a line after the last one in the visible area the don't render it
   if tHeight > (the vScroll of getScriptField() + the height of getScriptField()) then
      return 0
   end if
   
   # Adjust the height to take the vScroll into account
   local tLoc
   put tHeight - the vScroll of getScriptField() into tLoc
   
   # Adjust the height so its relative to the start of the gutter
   add the top of me to tLoc
   
   # Adjust the the height to take the field's margins into account. This requires a little fudge...
   if the number of items of the margins of getScriptField() = 4 then
      add item 2 of the margins of getScriptField() + kFudge to tLoc
   else
      add the margins of getScriptField() + kFudge to tLoc
   end if
   
   # Adjust to the middle of the line
   add round(0.5 * the effective textHeight of getScriptField()) to tLoc
   
   return tLoc
end lineNumberToVerticalLoc

# Parameters
#   pVerticalLoc : a vertical location within the gutter's area
# Returns
#   The line number in the current script that is associated with the specified location.
#   If the location is beyond any lines in the script, or the line cannot have a breakpoint
#   on it, then 0 is returned.
function verticalLocToLineNumber pVerticalLoc
   # Add the vScroll of the script field so that the location is relative to the start of the text
   local tHeight
   put the vScroll of getScriptField() + pVerticalLoc into tHeight
   
   # Make it relative to 0 rather than the top of the gutter
   subtract the top of me from tHeight
   
   # Adjust the the height to take the field's margins into account. This requires a little fudge...
   if the number of items of the margins of getScriptField() = 4 then
      subtract item 2 of the margins of getScriptField() + kFudge from tHeight
   else
      subtract the margins of getScriptField() + kFudge from tHeight
   end if
   
   # Divide to calculate which line number it falls nearest. Always round up.
   local tLineNumber
   put (tHeight div the effective textHeight of getScriptField()) + 1 into tLineNumber
   return tLineNumber
end verticalLocToLineNumber

# Returns
#   Whether or not the script is locked
function scriptLocked
   return the lockText of field "Script" of me
end scriptLocked

on returnInField
   if the commandKey is "down" then
      # Pass to prevent conflict with command + return keyboard shortcut
      pass returnInField
   end if
   
   if not handleEvent("returnInField", the long id of the target) then
      pass returnInField
   end if
   
   if scriptLocked() then
      exit returnInField
   end if
   
   local tFrom, tTo
   get the selectedChunk
   put word 2 of it into tFrom
   put word 4 of it into tTo
   
   local tLine
   put word 2 of the selectedLine into tLine
   
   # Option+Return places a continuation char on the current line before the return.
   local tContinuationRequired
   put (optionKey() is "down") into tContinuationRequired
   
   local tAt, tLength, tReturn
   calculateReturnFormatting tTo, tFrom, tLine, tContinuationRequired, tAt, tLength, tReturn
   
   local tCaretOffset
   put tAt + the length of tReturn - 1 into tCaretOffset
   
   local tLineEnd
   put the number of chars of line 1 to tLine of textGetScript() + 1 into tLineEnd
   
   local tFollowingChars
   put char tAt to tLineEnd of textGetScript() into tFollowingChars
   
   local tWhitespaceAfter
   put matchText(tFollowingChars, "^\s*$") into tWhitespaceAfter
   
   -- allow environment with no dependencies
   local tAutoComplete = true
   try 
      put sePrefGet("editor,autocomplete") into tAutoComplete
   end try
   
   if tAutoComplete and tWhitespaceAfter then
      autoComplete tLine, tReturn
   end if
   
   # The return character should be grouped separately from the line that was entered before it (if there was one)
   # This copies the behavior of MS Visual Studio.
   if sTextGroupIndex[sObjectId] is not 0 then
      # OK-2008-07-29 : Bug 6825
      --textEndGroup
      textMark "Insert"
   end if
   
   textReplace tAt, char tAt to tAt + tLength - 1 of field "Script" of me, tReturn
   select after char tCaretOffset of field "Script" of me
   textEndGroup
   
   # OK-2009-01-19 : Update the handler list
   selectionUpdateRequest
end returnInField

# Parameters
# Description
#   Returns the specification of replace operation that represents the inserting of a
#   return character at the specified location in the current script. Includes formatting.
#   This command will also remove indentation from the previous line.
private command calculateReturnFormatting pTo, pFrom, pLine, pContinuationRequired, @rAt, @rLength, @rString
   local tReturnString
   if pContinuationRequired then
      put " \" & return into tReturnString
   else
      put return into tReturnString
   end if
   
   # If there is a non-empty selection, the inserted return char will replace this
   # and for now, no formatting is done.
   if pFrom <= pTo then
      put pFrom into rAt
      put pTo - pFrom + (the length of tReturnString) into rLength
      put tReturnString into rString
      exit calculateReturnFormatting
   end if
   
   # If the preference is not to use formatting, just return the specification of the basic 
   # insertion of a return character.
   -- allow environment with no dependencies
   local tAutoComplete = true
   try 
      put sePrefGet("editor,autocomplete") into tAutoComplete
   end try
   
   if not tAutoComplete then
      put pFrom into rAt
      put 0 into rLength
      put tReturnString into rString
      exit calculateReturnFormatting
   end if
   
   local tScript
   put textGetScript() into tScript
   
   local tPreviousChars
   repeat with x = pFrom - 1 down to 1
      if char x of tScript is empty or char x of tScript is return then
         exit repeat
      end if
      put char x of tScript after tPreviousChars
   end repeat
   
   local tWhitespaceBefore
   put matchText(tPreviousChars, "^\s*$") into tWhitespaceBefore
   
   if tWhitespaceBefore then
      local tIndent
      put textFormatGetLineIndent(line pLine of tScript) into tIndent
      
      # If the caret has somehow been placed in the middle of the indentation string we need to allow
      # for this by subtracting from tIndent
      local tCurrentChar
      put pFrom into tCurrentChar
      repeat until (char tCurrentChar of tScript is not space) or the number of chars of tIndent = 0
         delete char 1 of tIndent
         add 1 to tCurrentChar
      end repeat
      
      local tLength
      put 0 into tLength
      
      local tAt
      put pFrom into tAt
      
      local tReturn
      put return & tIndent into tReturn
   else
      local tFormatting
      local tPreviousLine = 0
      local tTextLines
      put tScript into tTextLines
      split tTextLines by return
      
      put textFormatLine(pLine, tTextLines, tPreviousLine) into tFormatting
      
      put (the number of chars of line 1 to (pLine - 1) of tScript) + 1 into tAt 
      if pLine <> 1 then 
         add 1 to tAt 
      end if
      
      if item 1 of tFormatting > 0 then
         repeat item 1 of tFormatting times
            put space after tIndent
         end repeat
         textReplace tAt, empty, tIndent
      else if item 1 of tFormatting < 0 then
         textReplace tAt, char tAt to (tAt - item 1 of tFormatting - 1) of tScript, empty
      end if
      
      put 0 into tLength
      put pFrom into tAt
      add item 1 of tFormatting to tAt
      put tReturnString & item 2 of tFormatting into tReturn
   end if
   
   put tAt into rAt
   put tLength into rLength
   put tReturn into rString
end calculateReturnFormatting

# Parameters
#   pLine : the line number we are inserting at (i.e word 2 of the selectedLine at the point which the return was pressed which triggered the autocomplete)
#   xString : the string to put the completion after. This is the string that is about to be appended to the script as a result of pressing return
# Description
#   Calculates the correct completion according to what is already on line pLine, including formatting, and places it after xString,
#   which can then be inserted into the script field.
private command autoComplete pLine, @xString
   local tScript
   put textGetScript() into tScript
   
   local tCurrentLine
   put line pLine of tScript into tCurrentLine
   
   # From the text in the current line, calculate what kind of structure the user is typing the start of (if any)
   local tStructureType, tStructureName
   get autoCompleteGetStructure(tCurrentLine)
   put line 1 of it into tStructureType
   put line 2 of it into tStructureName
   
   # Once we know what the structure is, lookup what the correct completion is for that structure.
   local tCompletion
   put autoCompleteGetCompletion(tStructureType, tStructureName) into tCompletion
   if tCompletion is empty then
      exit autoComplete
   end if
   
   if tCompletion is empty then
      exit autoComplete
   end if
   
   # Look down the script and work out if we actually need to complete this structure, i.e. find out if its
   # already been completed or not.
   if not autoCompleteCompletionRequired(pLine, tStructureType, tStructureName, tCompletion) then
      exit autoComplete
   end if
   
   # Format the completion, this is easy because the indentation of the complete will always match
   # that of pLine.
   local tIndent
   put textFormatGetLineIndent(tCurrentLine) before tCompletion
   put return & tCompletion after xString
end autoComplete

private function autoCompleteSearchContext @pScript, pLineNumber, pStructureType, pStructureName, pCompletion
   if pStructureName is not empty then
      return 1
   end if
   
   local tDepth
   put 0 into tDepth
   repeat with x = pLineNumber down to 1
      local tLine
      put line x of pScript into tLine
      
      if token 1 of tLine is "private" and token 2 of tLine is among the items of autoCompleteNamedStructures() then
         exit repeat
      else if token 1 of tLine is among the items of autoCompleteNamedStructures() then
         exit repeat
      end if
      
      if token 1 of tLine is pStructureType then
         add 1 to tDepth
      else if token 1 of tLine is "end" and token 2 of tLine is pStructureType then
         subtract 1 from tDepth
      end if
   end repeat
   
   return tDepth
end autoCompleteSearchContext

# Parameters
#   pLineNumber : the line that the structure to be completed starts on
#   pStructureType : the type of the structure to be completed this is either one of autoCompleteNamedStructures() or autoCompleteUnnamedStructures()
#   pStructureName : the name of the structure. (May be empty, not all structures have names, basically only handlers do)
#   pCompletion : what the completion of the structure would be (this is needed in order to see if its already there).
# Returns
#   True if a completion is required for this specification, false otherwise.
function autoCompleteCompletionRequired pLineNumber, pStructureType, pStructureName, pCompletion
   local tScript
   put textGetScript() into tScript
   
   local tInitialDepth
   put autoCompleteSearchContext(tScript, pLineNumber, pStructureType, pStructureName, pCompletion) into tInitialDepth
   put line pLineNumber + 1 to -1 of tScript into tScript
   
   # The nesting depth starts at 1 as we have just entered a structure
   local tNestingDepth
   put tInitialDepth into tNestingDepth
   repeat for each line tLine in tScript
      if token 1 of tLine is token 1 of pCompletion and token 2 of tLine is token 2 of pCompletion then
         subtract 1 from tNestingDepth
         if tNestingDepth = 0 then
            # The structure is already completed
            return false
         end if
      else if token 1 of tLine is "end" and token 2 of tLine is not among the items of autoCompleteUnnamedStructures() and token 2 of tLine is not "if" then
         # If a named structure is ending, but it doesn't match the structure we are looking for
         # then if the structure we're looking for is un-named, we return true
         if pStructureName is empty then
            return true
         end if
         
         # Else if we are looking for a named structure, then don't do the completion, because
         # its possible that the user is renaming a handler and we should be conservative here.
         if pStructureName is not empty then
            return false
         end if
      else
         get autoCompleteGetStructure(tLine)
         
         # If we have a matching structure being opened, increment the nesting depth
         if line 1 of it is pStructureType and line 2 of it is pStructureName then
            add 1 to tNestingDepth
         end if
         
         # If a new handler has started and we are completing an any structure then
         # we should return true now.
         if line 2 of it is not empty then
            return true
         end if
      end if
   end repeat
   
   return true
end autoCompleteCompletionRequired

# Returns
#   A comma separated list of the autocompleteable structures that have names. This is currently just handlers.
private function autoCompleteNamedStructures
   return handlerTypes()
end autoCompleteNamedStructures

# Returns
#   A comma separated list of the autocompleteable structures without names. Note that we don't complete IF statements
#   because there are too many possibilities, (else, else if, end if) and its better to not complete than risk forcing the user to delete stuff.
private function autoCompleteUnnamedStructures
   return "repeat,try,switch"
end autoCompleteUnnamedStructures

# Parameters
#   pLine : a line number in the current script
# Returns
#   A string describing the structure whose beginning is found on pLine. This is in the following format:
#     Line 1 : The structure's type, e.g. command, repeat, try
#     Line 2 : The structure's name if it has one, e.g. mouseUp
#   If pLine does not represent the beginning of a completable structure then the structure type will be empty.
private function autoCompleteGetStructure pLine
   local tLine
   put pLine into tLine
   
   # Disregard "private" if first token
   if token 1 of tLine is "private" then
      put token 2 to -1 of tLine into tLine
   end if
   
   local tStructureType, tStructureName
   
   # Establish what the structure type and name (if appropriate) are. We autocomplete handler declarations,
   # repeats, trys and switches, but not ifs (because they have too many different forms, might annoy the user).
   if token 1 of tLine is among the items of autoCompleteNamedStructures() then
      put token 1 of tLine into tStructureType
      put token 2 of tLine into tStructureName
   else if token 1 of tLine is among the items of autoCompleteUnnamedStructures() then
      put token 1 of tLine into tStructureType
      put empty into tStructureName
   end if
   
   return tStructuretype & return & tStructureName
end autoCompleteGetStructure

# Parameters
#   pStructureType : the type of a completeable structure
#   pStructureName : the name of a compleatable structure (may be empty)
# Returns
#   The completion of the stucture if one is known. E.g if pStructureType is "on" and pStuctureName is "mouseUp",
#   will return "end mouseUp"
private function autoCompleteGetCompletion pStructureType, pStructureName
   # Make sure we have something valid that can be completed
   if pStructureType is empty then
      return empty
   end if
   
   # Work out the completion
   local tCompletion
   if pStructureType is among the items of handlerTypes() then
      if pStructureName is not empty then
         put "end " & pStructureName into tCompletion
      end if
   else
      put "end " & pStructureType into tCompletion
   end if
   
   return tCompletion
end autoCompleteGetCompletion

private function getSelectedText
   local tFrom, tTo
   get the selectedChunk
   put word 2 of it into tFrom
   put word 4 of it into tTo
   
   local tText
   if tTo < tFrom then
      getCaretToken
      put the result into tText
   else
      put char tFrom to tTo of textGetScript() into tText
   end if
   
   return tText
end getSelectedText

# OK-2009-01-22 : Bug 7278 - Use the clickText instead of the selectedText for the context menu
# Also modified getCaretToken by adding optional pUseClick parameter.
function getClickText
   --   local tFrom, tTo
   --   get the clickChunk
   --   put word 2 of it into tFrom
   --   put word 4 of it into tTo
   
   local tText
   --   if tTo < tFrom then
   getCaretToken true
   put the result into tText
   --else
   --   put char tFrom to tTo of textGetScript() into tText
   --end if
   
   return tText
end getClickText

private function handleEvent pEvent, pTarget
   if the long id of pTarget is the long id of field "Script" of me then
      return true
   else
      return false
   end if
end handleEvent

# OK-2009-03-02 : Bug 7773
on optionKeyDown pKey
   if not handleEvent("optionKey", the long id of the target) then
      pass optionKeyDown
   end if
   
   # Block this message on OS X as it can cause weird characters to be entered into the field
   if the platform is not "MacOS" then
      pass optionKeyDown
   end if
   
   -- OK-2009-03-09 : But simulate the message as a normal keydown
   keyDown pKey
end optionKeyDown

on scrollBarDrag
   if not handleEvent("scrollBarDrag", the long id of the target) then
      pass scrollBarDrag
   end if
   
   updateGutterRequest empty, empty, empty, empty, false, true
end scrollBarDrag

on keyDown pChar
   if not handleEvent("keydown", the long id of the target) then
      pass keyDown
   end if
   
   if scriptLocked() then
      exit keyDown
   end if
   
   get the selectedChunk
   
   local tFrom, tTo
   put word 2 of it into tFrom
   put word 4 of it into tTo
   
   local tAt, tLength
   if tFrom > tTo then -- the caret is at the end
      put 0 into tLength
      put tFrom into tAt
   else
      put tFrom into tAt
      put tTo - tFrom + 1 into tLength
   end if
   textReplace tAt, char tAt to tAt + tLength - 1 of field "Script" of me, pChar
end keyDown

on backspaceKey
   if not handleEvent("backspaceKey", the long id of the target) then
      pass backspaceKey
   end if
   
   if scriptLocked() then
      exit backspaceKey
   end if
   
   get the selectedChunk
   
   local tFrom, tTo
   put word 2 of it into tFrom
   put word 4 of it into tTo
   
   local tAt, tLength
   if tFrom > tTo then
      -- Caret handling, for now, is only done for an "empty" selection.
      local tLine
      put word 2 of the selectedLine into tLine
      
      local tScript
      put the text of the selectedField into tScript
      
      local tLineStart
      put the number of chars of line 1 to (tLine - 1) of tScript + 1 into tLineStart
      -- Only add offset of return if we are not on the first line of the script
      if tLine is not 1 then
         add 1 to tLineStart
      end if
      
      # OK-2008-08-28 : Bug 6515 - Delete whole word with commandKey
      if the commandKey is "down" then
         local tWordFound
         put false into tWordFound
         repeat with x = tTo down to 1
            if not matchText(char x of tScript, "\s") then
               put true into tWordFound
            else
               if tWordFound then
                  exit repeat
               end if
            end if
         end repeat
         
         if x <> 1 then
            put x + 1 into tAt
         else
            put x into tAt
         end if
         
         put tTo - tAt + 1 into tLength
      else
         # OK-2008-08-05 : Bug 6867 - If autoformatting is turned off, simply delete the last selected character
         -- allow environment with no dependencies
         local tAutoFormat = true
         try 
            put sePrefGet("editor,autoformat") into tAutoFormat
         end try
         
         if tAutoFormat then
            put caretPositionLeft(tLineStart, tTo, tScript) + 1 into tAt
         else
            put tTo into tAt
         end if
         put tTo - tAt + 1 into tLength
      end if
   else
      put tTo - tFrom + 1 into tLength
      put tFrom into tAt
   end if
   
   textReplace tAt, char tAt to tAt + tLength - 1 of field "Script" of me, empty
   
   # If the user has deleted a selection of text rather than a single character, they will
   # expect this to be a single undoable operation. So we close the current group straight
   # after the deletion. in this case.
   if tTo > tFrom then
      textEndGroup
   end if
    
   # OK-2009-01-19 : Update the handler list
   selectionUpdateRequest
end backspaceKey

on deleteKey
   if not handleEvent("deleteKey", the long id of the target) then
      pass deleteKey
   end if
   
   if scriptLocked() then
      exit deleteKey
   end if
   
   get the selectedChunk
   
   local tFrom, tTo
   put word 2 of it into tFrom
   put word 4 of it into tTo
   
   local tAt, tLength
   if tFrom > tTo then
      put tFrom into tAt
      put 1 into tLength
   else
      put tFrom into tAt
      put tTo - tFrom + 1 into tLength
   end if
   
   textReplace tAt, char tAt to tAt + tLength - 1 of field "Script" of me, empty
   
   # If the user has deleted a selection of text rather than a single character, they will
   # expect this to be a single undoable operation. So we close the current group straight
   # after the deletion. in this case.
   if tTo > tFrom then
      textEndGroup
   end if
   
   # OK-2009-01-19 : Update the handler list
   selectionUpdateRequest
end deleteKey

on tabKey
   if not handleEvent("tabKey", the long id of the target) then
      pass tabKey
   end if
   
   # To prevent interference with the command+tab shortcut to cycle between tabs
   if the commandKey is "down" then
      pass tabKey
   end if
   
   if scriptLocked() then
      exit tabKey
   end if
   
   -- allow environment with no dependencies
   local tAutoFormat = true
   try 
      put sePrefGet("editor,autoformat") into tAutoFormat
   end try
   if tAutoFormat then
      local tDoFormat = true
      if the number of elements of sFoundProviders > 0 then
         __SetCompletionString sFoundProviders[the hilitedLine of field "completions" of group "completion info" of me]
         put not the result into tDoFormat
      else if the number of elements of sPlaceholders > 0 then
         __ClearCurrentPlaceholder
         
         local tChar, tLineChar, tLine, tToken, tLineTokens
         __CurrentTokens tToken, tLineTokens, tChar, tLine, tLineChar
         
         __SelectNextPlaceholder tLineChar, tLine, tLine + kAutocompletePlaceholderSearchLines
         put not the result into tDoFormat
      end if
      
      if tDoFormat then
         if the shiftKey is "down" then
            scriptFormat "script"
         else
            scriptFormat "handler"
         end if
      end if
   else
      get the selectedChunk
      
      local tFrom, tTo
      put word 2 of it into tFrom
      put word 4 of it into tTo
      
      local tAt, tLength
      if tFrom > tTo then
         put tFrom into tAt
         put 0 into tLength
      else
         put tFrom into tAt
         put tTo - tFrom into tLength
      end if
      
      textReplace tAt, char tAt to tAt + tLength - 1 of field "Script" of me, tab
   end if
end tabKey

# Key identifiers for a few important keys...
constant kKeyHome = "65360"
constant kKeyEnd = "65367"
constant kKeyLeftArrow = "65361"
constant kKeyRightArrow = "65363"
constant kKeyUpArrow = "65362"
constant kKeyDownArrow = "65364"
constant kKeyF1 = "65470"
constant kKeyF2 = "65471"
constant kKeyF3 = "65472"
constant kKeyF4 = "65473"
constant kKeyF5 = "65474"
constant kKeyF6 = "65475"
constant kKeyF7 = "65476"
constant kKeyF8 = "65477"
constant kKeyF9 = "65478"
constant kKeyF10 = "65479"
constant kKeyF11 = "65480"
constant kKeyF12 = "65481"
constant kKeyF13 = "65482"
constant kKeyNumLock = "65407"
constant kKeyPageUp = "65365"
constant kKeyPageDown = "65366"
# constant kKeyMenu = "80"

private command selectFromCurrentToLineStart
   local tAt
   put word 4 of the selectedChunk into tAt
   
   local tLineNumber
   put word 2 of the selectedLine into tLineNumber
   
   local tLineStart
   put the number of chars of line 1 to (tLineNumber - 1) of the text of getScriptField() + 1 into tLineStart
   # Only add offset of return if we are not on the first line of the script
   if tLineNumber is not 1 then
      add 1 to tLineStart
   end if
   
   select char tLineStart to tAt of field (the short name of getScriptField()) of me
end selectFromCurrentToLineStart

private command selectFromCurrentToLineEnd
   local tAt
   put word 4 of the selectedChunk into tAt
   
   local tLineNumber
   put word 2 of the selectedLine into tLineNumber
   
   local tLineEnd
   put the number of chars of line 1 to tLineNumber of the text of getScriptField() into tLineEnd
   
   select char (tAt + 1) to tLineEnd of field (the short name of getScriptField()) of me
end selectFromCurrentToLineEnd

-- Description
--   Implements a basic page up functionality for OS X, as this is not default field behavior.
private command pageUp
   local tLineNumber
   put word 2 of the selectedLine into tLineNumber
   
   -- Work out the number of lines in one "page" of the script editor field.
   local tLineCount
   put the height of getScriptField() div the textHeight of getScriptField() into tLineCount
   
   -- Work out which line number we need to scroll up to
   local tNewLineNumber
   put max(tLineNumber - tLineCount, 1) into tNewLineNumber
   
   -- Calculate the char that we need to reach to do the page up
   local tStartChar
   put the number of chars of line 1 to tNewLineNumber of the text of getScriptField() into tStartChar
   
   local tAt
   put word 4 of the selectedChunk into tAt
   
   if shiftKey() is "down" then
      select char tStartChar to tAt of field (the short name of getScriptField()) of me
   else
      select after char tStartChar of field (the short name of getScriptField()) of me
   end if
end pageUp

-- Description
--   Implements a basic page down functionality for OS X, as this is not default field behavior.
private command pageDown
   local tMultiSelection, tAt
   get the selectedChunk
   if word 4 of it > word 2 of it then
      put true into tMultiSelection
      put word 4 of it into tAt
   else
      put false into tMultiSelection
      put word 2 of it into tAt
   end if
   
   local tLineNumber
   if tMultiSelection then
      put word 4 of the selectedLine into tLineNumber
   else
      put word 2 of the selectedLine into tLineNumber
   end if
   
   -- Work out the number of lines in one "page" of the script editor field.
   local tLineCount
   put the height of getScriptField() div the textHeight of getScriptField() into tLineCount
   
   -- Work out which line number we need to scroll down to
   local tNewLineNumber
   put min(tLineNumber + tLineCount, the number of lines of the text of getScriptField()) into tNewLineNumber
   
   -- Calculate the char that we need to reach to do the page down
   local tEndChar
   put the number of chars of line 1 to tNewLineNumber of the text of getScriptField() into tEndChar
   
   if shiftKey() is "down" then
      select char tAt to tEndChar of field (the short name of getScriptField()) of me
   else
      select after char tEndChar of field (the short name of getScriptField()) of me
   end if
end pageDown


# Description
#   RawKeyDown is handled mainly because of the home and end keys. These need to be manually implemented on OS X
#   and both platforms after pressing the home key we have to ensure the caret ends up in the right place.
#   Other keys may be blocked here to prevent weird chars getting inserted into the script.
on rawKeyDown pKey
   if not handleEvent("rawKeyDown", the long id of the target) then
      pass rawKeyDown
   end if
   
   # For the beginning of line/paragraph action (there is no distinction in the S/E)
   # make sure we update the caret position after the field has had its go.
   
   # For Windows: Home (Windows / Linux)
   if pKey is kKeyHome and the platform is not "macos" then
      put true into sArrowKeyPressed
      send "selectionChangedByArrowKey" to me in 0 milliseconds
      pass rawKeyDown
   end if
   
   # For Mac: Ctrl-Left / Cmd-Left / Ctrl-A (Mac)
   if (pKey is kKeyLeftArrow and (the controlKey is "down" or the commandKey is "down") or \
         (pKey is 65 and the controlKey is "down" and the shiftKey is "up")) and the platform is "macos" then
      put true into sArrowKeyPressed
      send "selectionChangedByArrowKey" to me in 0 milliseconds
      pass rawKeyDown
   end if
   
   # For actions where we need to skip back, we need to ensure the caret is at the
   # start of the line if it is in the white-space prefix.
   
   # For Mac: Alt-Down
   if (pKey is kKeyUpArrow) and (the optionKey is "down" and the shiftKey is "up") and the platform is "macos" then
      local tScript
      put the text of the selectedField into tScript
      
      local tCaretChar
      get the selectedChunk
      put word 2 of it into tCaretChar
      try
         repeat while tCaretChar > 1 and (char (tCaretChar - 1) of tScript is space)
            subtract 1 from tCaretChar
         end repeat
      catch tError
         put tError
      end try
      if tCaretChar is not 1 and char tCaretChar - 1 of tScript is return then
         lock messages
         select before char tCaretChar of the selectedField
         unlock messages
      end if
   end if
   
   # optionKey is down
   local tKeyName
   if (pKey is kKeyLeftArrow or pKey is kKeyRightArrow) and the optionkey is down then
      put true into sArrowKeyPressed
      if pKey is kkeyRightArrow then
         send "selectionChangedByArrowKey" to me in 0 milliseconds
      else
         put "left" into tKeyName
         send "selectionChangedByArrowKey tKeyName" to me in 0 milliseconds
      end if
      pass rawKeyDown
   end if
   
   if pKey is not among the items of kKeyLeftArrow,kKeyRightArrow,kKeyUpArrow,kKeyDownArrow then
      pass rawKeyDown
   end if
   
   # for simple arrowKeys
   
   #  [[ Bug 18595 ]] "cursor should move to begin of text if click is left of text"
   # moved handling of arrowKey from rawKeyUp here to flag arrowKey in sArrowKeyPressed
   # before "selectionChanged" message is fired 
   
   switch pKey
      case kKeyLeftArrow
         put "left" into tKeyName
         break
      case kKeyRightArrow
         put "right" into tKeyName
         break
      case kKeyUpArrow
         put "up" into tKeyName
         break
      case kKeyDownArrow
         put "down" into tKeyName
         break
   end switch
   
   if not scriptLocked() then
      textMark "Insert"
      put true into sArrowKeyPressed
      send "selectionChangedByArrowKey tKeyName" to me in 0 milliseconds
   end if
   pass rawKeyDown
end rawKeyDown

-- Drag Drop Management
local sDragMode

on dragDrop
   if not handleEvent("dragDrop", the long id of the target) then
      pass dragDrop
   end if
   
   if scriptLocked() then
      exit dragDrop
   end if
   
   lock screen
   textBeginGroup "Drag"
   
   local tDropAt
   get the dropChunk
   put word 2 of it into tDropAt
   
   local tSelectFrom, tSelectTo
   get the selectedChunk
   put word 2 of it into tSelectFrom
   put word 4 of it into tSelectTo
   
   if tDropAt >= tSelectFrom and tDropAt <= tSelectTo then
      exit dragDrop
   end if
   
   if sDragMode is "cut" then
      -- Remove the selection. This will never happen on a drag that started outside the ScriptEditorPane.
      
      -- in this case, we cannot have tFrom > tTo
      textReplace tSelectFrom, char tSelectFrom to tSelectTo of control "Script" of me, empty
      
      if tDropAt > tSelectTo then
         subtract tSelectTo - tSelectFrom + 1 from tDropAt
      end if
   end if
   
   
   local tDroppedText
   put dragData["text"] into tDroppedText
   -- There is an issue with the very last return character, for now it seams sufficient to remove this.
   #  if char -1 of tDroppedText is return then
   #    delete char -1 of tDroppedText
   #  end if
   
   textReplace tDropAt, empty, tDroppedText
   
   textEndGroup
   unlock screen
end dragDrop

on dragStart
   if not handleEvent("dragStart", the long id of the target) then
      pass dragStart
   end if
   
   # OK-2008-08-01 : Bug 6709 - On Macs, the option key should result in a copying drag.
   if the platform is not "MacOS" then
      if the controlKey is "down" then
         put "copy" into sDragMode
      else
         put "cut" into sDragMode
      end if
   else
      if the optionKey is "down" then
         put "copy" into sDragMode
      else
         put "cut" into sDragMode
      end if
   end if
   
   pass dragStart
end dragStart

on dragEnd
end dragEnd

# Description
## Returns a line stripped of comments at the end of the line
private function lineStripComments pLine
   local tOffset,tCommentChar
   put offset("#", pLine) into tOffset
   if tOffset = 0 then
      put offset("--", pLine) into tOffset
      put "--" into tCommentChar
   else
      put "#" into tCommentChar
   end if
   
   if tCommentChar is empty then
      return pLine
   else
      return char 1 to tOffset of pLine
   end if
end lineStripComments

################################################################################

command actionCopy
   copy
end actionCopy

command actionCut
   if scriptLocked() then
      exit actionCut
   end if
   
   get the selectedChunk
   
   local tFrom, tTo
   put word 2 of it into tFrom
   put word 4 of it into tTo
   
   if tFrom <= tTo then -- something is selected
      textBeginGroup "Cut"
      copy -- set the clipboard (dont cut as we do not allow field modification here)
      textReplace tFrom, char tFrom to tTo of field "Script" of me, empty
      textEndGroup
      
      # OK-2009-01-19 : Update the handler list
      selectionUpdateRequest
   end if
end actionCut

command actionPaste
   if scriptLocked() then
      exit actionPaste
   end if
   
   get the selectedChunk
   
   local tFrom, tTo
   put word 2 of it into tFrom
   put word 4 of it into tTo
   
   lock screen
   textBeginGroup "Paste"
   textReplace tFrom, char tFrom to tTo of field "Script" of me, the clipboardData["text"]
   -- allow environment with no dependencies
   local tAutoFormat = true
   try 
      put sePrefGet("editor,autoformat") into tAutoFormat
   end try
   
   if tAutoFormat then
      scriptFormat "handler", true
   end if
   textEndGroup
   unlock screen
   
   # OK-2009-01-19 : Update the handler list
   selectionUpdateRequest
end actionPaste

command actionUndo
   if scriptLocked() then
      exit actionUndo
   end if
   textUndo
   # OK-2009-01-19 : Update the handler list
   selectionUpdateRequest
end actionUndo

command actionRedo
   if scriptLocked() then
      exit actionRedo
   end if
   textRedo
   # OK-2009-01-19 : Update the handler list
   selectionUpdateRequest
end actionRedo

command actionDeselectAll
   lock messages
   select empty
   unlock messages
end actionDeselectAll

command actionSelectAll
   lock messages
   
   if word 1 of the name of the focusedObject is "field" then
      select char 1 to -1 of the focusedObject
   end if
   unlock messages
end actionSelectAll

# Parameters
#   rStartLine : receives the line number that the current selection begins on
#   rEndLine : receices the line number that the current selection ends on
#   rStartChar : receives the char that the curent selection starts on
#   rText : receives the block of text that will be commented or uncommented.
# Description
#   This command obtains the details required to comment / uncomment a block of code
#   it is used by the scriptComment and scriptUncomment commands.
private command commentGetDetails @rStartLine, @rEndLine, @rStartChar, @rText
   # Calculate the chunk of text that the commenting will be applied to
   local tStartLine, tEndLine
   get the selectedLine
   put word 2 of it into tStartLine
   if word 3 of it is "to" then
      put word 4 of it into tEndLine
   end if
   
   # Adjust the chunk so that we have only complete lines by searching from the beginning
   # backwards to the next return char. Don't bother doing this for the end as this doesn't matter.
   get the selectedChunk
   local tCurrentStart
   put word 2 of it into tCurrentStart
   
   local tStartChar
   
   if tStartLine = 1 then
      put 1 into tStartChar
   else
      local tPreviousChars
      put char 1 to (tCurrentStart - 1) of field "Script" of me into tPreviousChars
      
      local tOffset
      put 0 into tOffset
      repeat with x = the number of chars of tPreviousChars down to 1
         if char x of tPreviousChars is return then
            exit repeat
         end if
         add 1 to tOffset
      end repeat
      #subtract 1 from tOffset
      
      put tCurrentStart - tOffset into tStartChar
   end if
   
   # Get the text and add in the comments
   local tText
   if tEndLine is empty then
      put line tStartLine of field "Script" of me into tText
   else
      put line tStartLine to tEndLine of field "Script" of me into tText
   end if
   
   put tStartChar into rStartChar
   put tStartLine into rStartLine
   put tEndLine into rEndLine
   put tText into rText
end commentGetDetails

# Description
#  Returns the last known token that the caret was placed into. This is not done properly
#  at the moment as it depends on the syntax, for now we just return something sensible.
command getCaretToken pUseClick
   local tScript
   put the text of getScriptField() into tScript
   
   # Don't return tokens in comments. For now we determine if the user is typing
   # in a comment by simple means, using proper tokenization is not yet possible.
   # This means that multi-line comments will break this.
   local tLine
   if pUseClick then
      put word 2 of the clickLine into tLine
   else
      put word 2 of the selectedLine of getScriptField() into tLine
   end if
   if token 1 of line tLine of tScript is empty then
      return empty
   end if
   
   local tSelectedText
   if pUseClick then
      put the clickText into tSelectedText
   else
      put the selectedText of getScriptField() into tSelectedText
      # OK-2008-06-22 : Bug 8054 - pUseClick is only set if we are building a context menu, so in this case
      # do the expansion anyway to try and get a whole token.
      if tSelectedText is not empty then
         return tSelectedText
      end if
   end if
   
   # This is expanded to include tokens that the caret was placed immediately before or after,
   # the reason for this is that it allows us to begin searching for tokens while the user is typing.
   local tFrom, tTo
   if pUseClick then
      get the clickChunk
   else
      get the selectedChunk
   end if
   put word 2 of it into tFrom
   put word 4 of it into tTo
   
   # We can't perfectly match tokens at the moment, so we just make a reasonable guess with a regular expression
   # to match any char that delimits a token.
   ## AL-2014-01-15: [[ Bug 11094 ]] Added # to the list of script editor token delimiters
   local tExpression 
   put "\s|[\%\^\&\*\(\)\-\+\=\]\]\;\,\\@\\\/\<\>\#]" into tExpression
   
   # Try looking backwards first
   local tText, tChar
   repeat with x = (tFrom - 1) down to 1
      put char x of tScript into tChar
      if matchText(tChar, tExpression) then
         exit repeat
      end if
      put tChar before tText
   end repeat
   
   # Try looking forwards
   repeat with x = tFrom to the number of chars of tScript
      put char x of tScript into tChar
      if matchText(tChar, tExpression) then
         exit repeat
      end if
      put tChar after tText
   end repeat
   
   return tText
end getCaretToken

# Description
#   Comments out the selected text
command scriptComment
   local tStartLine, tEndLine, tStartChar, tText
   commentGetDetails tStartLine, tEndLine, tStartChar, tText
   if tStartLine is empty then
      exit scriptComment
   end if
   
   lock screen
   
   -- allow environment with no dependencies
   local tCommentChar = "--"
   try 
      put sePrefGet("editor,commentchar") & space into tCommentChar
   end try
   
   local tCommentedText
   repeat for each line tLine in tText
      # Don't comment out empty lines as it looks messy
      if not matchText(tLine, "^\s*$") then
         put tCommentChar before tLine
      end if
      put tLine & return after tCommentedText
   end repeat
   delete the last char of tCommentedText
   
   # Apply the mutation to the field
   textMark "Insert"
   textReplace tStartChar, tText, tCommentedText
   
   # Restore the selection
   select char tStartChar to tStartChar + length(tCommentedText)  of field "Script"
   
   # OK-2009-03-03 : Bug 7537 - Reformat the handler after commenting, this may be flawed,
   # but the proper solution is rather time-consuming.
   -- allow environment with no dependencies
   local tAutoFormat = true
   try 
      put sePrefGet("editor,autoformat") into tAutoFormat
   end try
   
   if tAutoFormat then
      scriptFormat "handler"
   end if
   
   unlock screen
end scriptComment

# Desription
#   Uncomments the selected text
command scriptUncomment
   local tStartLine, tEndLine, tStartChar, tText
   commentGetDetails tStartLine, tEndLine, tStartChar, tText
   if tStartLine is empty then
      exit scriptUncomment
   end if
   
   lock screen
   -- allow environment with no dependencies
   local tCommentChar = "--"
   try 
      put sePrefGet("editor,commentchar") into tCommentChar
   end try
   
   local tUncommentedText
   
   local tCommentCharLength
   put the length of tCommentChar  into tCommentCharLength
   
   repeat for each line tLine in tText
      # Remove the first comment char that appears on the line
      local tOffset
      put offset(tCommentChar, tLine) into tOffset
      if tOffset is 0 then
         put tLine & return after tUncommentedText
         next repeat
      end if
      
      # Only remove the comment char if there is nothing significant before it
      # MM-2012-09-28: [[ Bug 10162 ]] Make sure we include lines with chars before the comment in the uncommented text.
      local tPreviousChars
      put char 1 to (tOffset - 1) of tLine into tPreviousChars
      if matchText(tPreviousChars, "^\s*$") then
         if char tOffset + tCommentCharLength of tLine is space then
            delete char tOffset + tCommentCharLength of tLine
         end if
         put char 1 to (tOffset - 1) of tLine & char (tOffset + tCommentCharLength) to -1 of tLine & return after tUncommentedText
      else
         put tLine & return after tUncommentedText
      end if
   end repeat
   delete the last char of tUncommentedText
   
   # Apply the mutation to the field
   textMark "Insert"
   textReplace tStartChar, tText, tUncommentedText
   
   # Restore the selection
   select char tStartChar to tStartChar + length(tUncommentedText)  of field "Script"
   
   # OK-2009-03-03 : Bug 7537 - Reformat the handler after commenting, this may be flawed,
   # but the proper solution is rather time-consuming.
   -- allow environment with no dependencies
   local tAutoFormat = true
   try 
      put sePrefGet("editor,autoformat") into tAutoFormat
   end try
   
   if tAutoFormat then
      scriptFormat "handler"
   end if
   
   unlock screen
end scriptUncomment

# Parameters
#   pOption : one of three possible strings, see below for details.
#   pValue : depends on pOption, details below.
# Description
#   Colorizes the current script. pOption is one of the following options.
#     "script" - colorize the whole script (default). pValue is ignored.
#     "line" - colorize a particular line, pValue is the line number
#     "handler" - colorize a particular handler, pValue is the handler name. Currently not implemented.
command scriptColorize pOption, pValue
   if pOption is "script" then
      _internal script colorize char 1 to (the number of chars of field "Script" of me) of field "Script" of me
   else if pOption is "line" then
      _internal script colorize line pValue to pValue of field "Script" of me
   end if
end scriptColorize

# Parameters
#   pScope : either "script" or "handler"
# Description
#   Formats the current script according to the pScope parameter. If pScope is "script", then
#   entire script is formatted. If pScope is handler, then the current handler is formatted.
#   Note, formatting the whole script could be quite slow.
command scriptFormat pScope, pDontGroup
   lock screen
   local tScroll
   put the vScroll of field "Script" of me into tScroll
   
   local tStart, tEnd
   get the selectedChunk
   put word 2 of it into tStart
   put word 4 of it into tEnd
   
   if pScope is "script" then
      local tStartChar
      put 1 into tStartChar
      
      local tOldText
      put the text of field "Script" of me into tOldText
      
      local tNewText
      put textFormatSelection(tOldText) into tNewText
      textReplace tStartChar, tOldText, tNewText, empty, pDontGroup
      
      if tStart is not empty then
         select char tStart to tEnd of field "Script" of me
      end if
      
   else # handler only
      local tLine
      put word 2 of the selectedLine into tLine
      
      local tScript
      put the text of the selectedField into tScript
      
      local tSelectionLineCount
      put the number of lines of char tStart to tEnd of tScript into tSelectionLineCount
      
      # Before doing the formatting, save the indent of the first and last line of the selection.
      # Once the formatting is done, we can compare this with the new indents in order to adjust the selection.
      local tOldFirstIndent
      put textFormatGetLineIndent(line tLine of tScript) into tOldFirstIndent
      
      local tOldLastIndent
      if tStart > tEnd then
         put tOldFirstIndent into tOldLastIndent
      else
         put textFormatGetLineIndent(line (tLine + tSelectionLineCount) of tScript) into tOldLastIndent
      end if
      
      local tCode
      put textFormat(tLine, tSelectionLineCount, tScript) into tCode
      textReplace tCode["startchar"], tCode["oldtext"], tCode["newtext"], empty, pDontGroup
      
      local tNewScript
      put the text of field "Script" of me into tNewScript
      
      # We know that formatting cannot change the number of lines of the field, so we can assume that
      # tLine will still be corrrect. (tStart and tEnd now no longer point to meaningful chars in the new script.)
      local tNewFirstIndent
      put textFormatGetLineIndent(line tLine of tNewScript) into tNewFirstIndent
      
      local tNewLastIndent
      if tStart > tEnd then
         put tNewFirstIndent into tNewLastIndent
      else
         # Note that we use the line count from the original selection, as we know this is correct, rather than calculating
         # it again for the new selection.
         put textFormatGetLineIndent(line (tLine + tSelectionLineCount) of tNewScript) into tNewLastIndent
      end if
      
      # The selection offsets are composed of two parts, the difference in the indent of the line that the selection started / ended on
      # and the difference in the number of chars before that line.
      local tFirstSelectionOffset
      put (the number of chars of tNewFirstIndent - the number of chars of tOldFirstIndent) + (the number of chars of line 1 to (tLine - 1) of tNewScript - the number of chars of line 1 to (tLine - 1) of tScript) into tFirstSelectionOffset
      
      local tLastSelectionOffset
      if tStart > tEnd then
         put tFirstSelectionOffset into tLastSelectionOffset
      else
         put (the number of chars of tNewLastIndent - the number of chars of tOldLastIndent) + (the number of chars of line 1 to (tLine + tSelectionLineCount) of tNewScript - the number of chars of line 1 to (tLine + tSelectionLineCount) of tScript) into tLastSelectionOffset
      end if
      
      if tStart is not empty then
         select char (tStart + tFirstSelectionOffset) to (tEnd + tLastSelectionOffset) of field "Script" of me
      end if
   end if
   
   set the vScroll of field "Script" of me to tScroll
   unlock screen
end scriptFormat

# Description
#   Returns the number of the selected line in the current script
command getSelectedLine
   return word 2 of the selectedLine
end getSelectedLine


# Parameters
#   pObject : the object to get the script of. Must be one of the current target objects
# Description
#   If pObject is not specified then returns the current script in the editor group,
#   otherwise returns the script of the specified object in the state it was last left in
#   by the user. I.e. if the script is not applied, the edited one is returned.
command scriptGet pObject
   if pObject is empty or revRuggedId(pObject) is revRuggedId(sObjectID) then
      return textGetScript()
   end if
   
   # If not the current script, we need to retrieve the script from a cache, as it
   # is no longer in the field.
   local tCachedScript
   put sScriptCache[revRuggedId(pObject)] into tCachedScript
   if tCachedScript is empty and exists(pObject) then
      return the script of pObject
   else
      return tCachedScript
   end if
end scriptGet

command scriptGetCache pObject
   return sScriptCache[revRuggedId(pObject)]
end scriptGetCache

command cacheScript pObject, pScript
   if exists(pObject) then
      put pScript into sScriptCache[revRuggedId(pObject)]
   end if
end cacheScript

# Description
#   Returns the number of lines of the current script
command scriptGetLineCount
   return the number of lines of field "Script" of me
end scriptGetLineCount

# Description
#   This command returns the current script as *real* html. The result of this command
#   is suitable for displaying in a browser, not in Revolution fields as htmlText. This command
#   requires the colorization scheme "Revolution Classic" to be used as it contains hard-coded 
#   replacements. For html suitable for printing or displaying in a Revolution field see scriptGetHtmlText.
command scriptGetAsHtml
   local tOldScript
   put the text of field "Script" of me into tOldScript
   
   # First wrap the script to the required width, this is a total hack as doing it properly would take quite a while.
   local tScript
   put tOldScript into tScript
   
   local tMaxCharCount
   put "65" into tMaxCharCount
   
   local tWrappedScript
   repeat for each line tLine in tScript
      # Ignore lines that don't need to be wrapped
      if the number of chars of tLine <= tMaxCharCount then
         put tLine & return after tWrappedScript
         next repeat
      end if
      
      # Find the word offset to wrap from. Only whole words can be wrapped
      local tWordOffset
      put (the number of words of char 1 to tMaxCharCount of tLine)  -1 into tWordOffset
      
      # The line could be a comment, in which case we need to find which comment char its using
      # wrap the line, and put the comment char in front of the wrapped part. This won't work with
      # multi-line comments etc.
      local tCommentChar
      if token 1 of tLine is empty then
         local tOffset
         put offset("#", tLine) into tOffset
         if tOffset = 0 then
            put offset("--", tLine) into tOffset
            put "--" into tCommentChar
         else
            put "#" into tCommentChar
         end if
         
         if tCommentChar is empty then
            put word 1 to tWordOffset of tLine & return & word tWordOffset + 1 to -1 of tLine & return after tWrappedScript
         else
            put word 1 to tWordOffset of tLine & return & tCommentChar & space & word tWordOffset + 1 to -1 of tLine & return after tWrappedScript
         end if
         next repeat
      end if
      
      # The line was not a comment. In this case we just wrap it with a continuation char
      # This of course may have issues if the line already has a continuation char, is inside a nested comment etc.
      if token 1 of tLine is not empty then
         put word 1 to tWordOffset of tLine & " \" & return & word tWordOffset + 1 to -1 of tLine & return after tWrappedScript
         next repeat
      end if
   end repeat
   delete the last char of tWrappedScript
   
   textReplace 1, tOldScript, tWrappedScript
   scriptFormat "script"
   
   local tHtml
   put the htmlText of field "Script" of me into tHtml
   
   local tNewHtml
   put "<div class=" & quote & "code" & quote & ">" & return into tNewHtml
   put "<pre>" & return after tNewHtml
   
   local tBody
   put tHtml into tBody
   replace "<p>" with empty in tBody
   replace "</p>" with empty in tBody
   
   replace "<font color=" & quote & "#000000" & quote & ">" with "<span class=" & quote & "normal" & quote & ">" in tBody
   replace "<font color=" & quote & "#0000FF" & quote & ">" with "<span class=" & quote & "command" & quote & ">" in tBody
   replace "<font color=" & quote & "#FF0000" & quote & ">" with "<span class=" & quote & "property" & quote & ">" in tBody
   replace "<font color=" & quote & "#68228B" & quote & ">" with "<span class=" & quote & "comment" & quote & ">" in tBody
   replace "<font color=" & quote & "#F88017" & quote & ">" with "<span class=" & quote & "function" & quote & ">" in tBody
   replace "<font color=" & quote & "#980517" & quote & ">" with "<span class=" & quote & "keyword" & quote & ">" in tBody
   replace "</font>" with "</span>" in tBody
   put tBody & return after tNewHtml
   
   put "</pre>" & return after tNewHtml
   put "</div>" after tNewHtml
   
   
   # Restore the original script
   textReplace 1, the text of field "Script" of me, tOldScript
   
   return tNewHtml
end scriptGetAsHtml

# Description
#   Returns the htmlText of the script field. This is suitable for printing, or displaying
#   in another Revolution field, not for putting on the net. For real html, see scriptGetAsHtml.
command scriptGetHtmlText
   return the htmlText of field "Script" of me
end scriptGetHtmlText

# Description
#   Returns the long id of the script field. This is required by the Revolution printing library,
#   the field ID is used to determine the properties require to make the printout look correct.
#   Please *do not* use this command to directly access the script field, doing so will break the 
#   script editor completely.
command scriptGetField
   return the long id of field "Script" of me
end scriptGetField

# Description
#   Returns the name of the current handler. This is the handler that the caret
#   is inside in edit mode, or that the current statement to execute is in in
#   debug mode.
command scriptGetCurrentHandler
   # Waiting for engine support for this function...
end scriptGetCurrentHandler


private command __BracketCompletion pOffset, pOldText, @xNewText
   try
      if sePrefGet("editor,autocomplete") is not true then
         return empty for value
      end if
   end try
   
   local tCompletionChar
   switch xNewText
      case quote
         if pOldText is empty then
            -- ensure we really want to insert an extra quote
            local tLine
            put the last line of (char 1 to pOffset of field "script" of me) & space into tLine
            split tLine by quote
            if (the number of elements in tLine -1) mod 2 is 0 then
               put space & the first line of (char pOffset to -1 of field "script" of me) into tLine
               split tLine by quote
               if (the number of elements in tLine -1) mod 2 is 0 then
                  put quote into tCompletionChar
               end if
            end if
         else
            put quote into tCompletionChar
         end if
         break
      case "["
         put "]" into tCompletionChar
         break
      case "("
         put ")" into tCompletionChar
         break
   end switch
   
   if tCompletionChar is not empty then
      if pOldText is empty then
         put tCompletionChar after xNewText
         return "pair" for value
      else
         put pOldText & tCompletionChar after xNewText
         return "wrap" for value
      end if
   end if
   return empty for value
end __BracketCompletion

constant kBracketBackgroundColor = "255,200,200"

local sHighlightedBrackets

private command __ClearHighlights
   if sHighlightedBrackets["open"] is not empty then
      set the backgroundColor of char sHighlightedBrackets["open"] of field "script" of me to empty
      set the backgroundColor of char sHighlightedBrackets["close"] of field "script" of me to empty
      delete variable sHighlightedBrackets
   end if
end __ClearHighlights

private command __CheckHighlights
   lock screen
   __ClearHighlights
   
   local tChunk
   put the selectedChunk into tChunk
   if word 4 of tChunk < word 2 of tChunk then
      local tChar, tCharNum
      put word 2 of tChunk into tCharNum
      put char tCharNum of field "script" of me into tChar
      if tChar is in "([])" then
         __HighlightBrackets tCharNum, tChar
      else
         put word 4 of tChunk into tCharNum
         put char tCharNum of field "script" of me into tChar
         if tChar is in "([])" then
            __HighlightBrackets tCharNum, tChar
         end if
      end if
   end if
   
   unlock screen
end __CheckHighlights

private command __HighlightBrackets pCharNum, pChar
   local tMatchedCharNum
   put pCharNum into tMatchedCharNum
   switch pChar
      case "["
         __LookForPair "]", "[", 1, tMatchedCharNum
         break
      case "("
         __LookForPair  ")", "(", 1, tMatchedCharNum
         break
      case "]"
         __LookForPair "[", "]", -1, tMatchedCharNum
         break
      case ")"
         __LookForPair "(",")", -1, tMatchedCharNum
         break
   end switch
   
   if it and pCharNum is not tMatchedCharNum then
      put pCharNum into sHighlightedBrackets["open"]
      set the backgroundColor of char pCharNum of field "script" of me to kBracketBackgroundColor
      put tMatchedCharNum into sHighlightedBrackets["close"]
      set the backgroundColor of char tMatchedCharNum of field "script" of me to kBracketBackgroundColor
   end if
end __HighlightBrackets

private command __LookForPair pChar, pPairChar, pStep, @xCharNum
   local tBracketCount = 0
   local tEndCondition
   
   local tScript
   local tScriptLine
   local tCharNum
   local tIndex
   if pStep < 0 then
      put 1 into tEndCondition
      put char 1 to xCharNum of field "script" of me into tScript
      split tScript by return
      put tScript[the number of elements of tScript] into tScriptLine
      
      repeat with tIndex = the number of elements in tScript-1 down to 1
         if lineIsContinued(tScript[tIndex]) then
            put tScript[tIndex] & return before tScriptLine
         else
            exit repeat
         end if
      end repeat
      
      put the length of tScriptLine into tCharNum
   else
      put char xCharNum+1 to -1 of field "script" of me into tScript
      split tScript by return
      put tScript[1] into tScriptLine
      
      repeat with tIndex = 1 to the number of elements in tScript
         if lineIsContinued(tScript[tIndex]) then
            put return & tScript[tIndex+1] after tScriptLine
         else
            exit repeat
         end if
      end repeat
      
      put the length of tScriptLine into tEndCondition
      put 0 into tCharNum
   end if
   
   if tScriptLine is empty then
      return false for value
   end if
   
   repeat
      add pStep to tCharNum
      add pStep to xCharNum
      local tChar
      put codepoint tCharNum of tScriptLine into tChar
      switch
         case tChar is pChar and tBracketCount is 0
            return true for value
            break
         case tChar is pPairChar
            add 1 to tBracketCount
            break
         case tChar is pChar
            subtract 1 from tBracketCount
            break
      end switch
      
      if tCharNum is tEndCondition then
         return false for value
      end if
   end repeat
end __LookForPair

-- autocompletion

private command __AutoCompleteClearProviders
   put empty into sRegisteredProviders
   put empty into sProvidersIncludingMsgPath
   put empty into sProviders
   put empty into sFoundProviders
   put empty into sProviderNames
end __AutoCompleteClearProviders

/*

Summary: Register autocomplete providers

Parameters:

pProviders (array):A numerically indexed array of providers
{
index (integer): The array index 1...N. each element is a provider specification array
{
"displayname" (string): the name to display to the user - should be one line
"symbolclass" (string): providers are prefiltered based on the symbol class required
"regex" (string): a regular expression for matching the provider
"completion" (optional string): completion strings are specified under the Completion Strings subsection
"list" (optional string): In some instances the provider may just be a list of variations or enum values. This would be the case for the statement.command.open.file.mode example above and possibly statement.command.open.for.
"priority" (optional integer): An integer in the range 0 to 100. Default value is 50. Where the number of autocompletion options that can be presented to the user is limited the options are sorted by priority. The framework would also only attempt to match providers with lower priority if there weren't enough matches from the higher priorities.
AutoCompleteProviderCallback
}
}

Description:
The AutoCompleteProviderCallback is the specified command name in the provider dispatched to the object ID in the provider or otherwise dispatched in the script editor scope.
It should return a completion string and is dispatched with the following parameters:

- pScript: the script being edited
- pCaret: the current caret offset
- pProvider: the provider array as specified as an element in the AutoCompleteRegisterProviders providers parameter.

*/
command AutoCompleteRegisterProviders pProviders
   repeat with tIndex =1 to the number of elements in pProviders
      local tHandler
      if pProviders[tIndex]["symbolclass"] contains "message" then
         put token 1 of pProviders[tIndex]["displayname"] into tHandler
      else
         put pProviders[tIndex]["displayname"] into tHandler
      end if
      
      if not sProviderNames[tHandler] then
         if pProviders[tIndex]["priority"] is not a number then next repeat
         if pProviders[tIndex]["symbolclass"] is empty then next repeat
         
         local tElementIndex
         put the number of elements of sRegisteredProviders[pProviders[tIndex]["priority"]][pProviders[tIndex]["symbolclass"]] + 1 into tElementIndex
         put pProviders[tIndex] into sRegisteredProviders[pProviders[tIndex]["priority"]][pProviders[tIndex]["symbolclass"]][tElementIndex]
         
         put true into sProviderNames[tHandler]
      end if
   end repeat
end AutoCompleteRegisterProviders

/*

Summary: Find the best matching providers. If no limit is specified a default limit will be applied.

Parameters:

pObject (string): The long ID of the object for introspection

pToken (string): The characters the user has typed. Likeley a minimum of 3 (perhaps a user preference option).

pLineTokens (string): The characters the user has typed. Likeley a minimum of 3 (perhaps a user preference option).

pCaret (string): The cursor offset in the script

pSymbolClass (optional string): The class or classes to search for

pUUID (optional string): A placeholder UUID if the caret is within a placeholder.

pCallbackObject (string): the long ID of an object to sent the callback to.

Description:

When complete AutoCompleteFoundProviders will be sent to the callbackObject with a numerically indexed array of provider arrays. 
If AutoCompleteFindProviders is called again before AutoCompleteFoundProviders is complete then the find will be cancelled and replaced.


*/

private command __AutoCompleteFindProviders pObject, pToken, pLineTokens, pLine, pSymbolClasses, pCallbackObject
   __AutoCompleteCancelFind
   send "__AutoCompleteFindProvidersDo pObject, pToken, pLineTokens, pLine, pSymbolClasses, pCallbackObject" to me in 200 milliseconds
   put the result into sLastFindMessageID
end __AutoCompleteFindProviders

private function __CurrentScope pObject, pLine
   if not exists(pObject) then
      return kAutocompleteScopeHandler
   end if
   
   local tScope
   if exists(pObject) then
      repeat for each key tHandler in sScriptDescription["handlers"]
         if pLine >= sScriptDescription["handlers"][tHandler]["start_line"] and \
               pLine <= sScriptDescription["handlers"][tHandler]["end_line"] then
            return kAutocompleteScopeHandler
         end if
      end repeat
   end if
   
   return kAutocompleteScopeScript
end __CurrentScope

private function __ProviderMatches @xProvider, pScope, pLineTokens, pToken
   if xProvider["scope"] is not pScope and \
         xProvider["scope"] is not kAutocompleteScopeAny then
      return false
   end if
   
   put false into xProvider["match_only_token"]
   
   if xProvider["matchtoken"] is kAutocompleteMatchLine then
      return xProvider["completion"] begins with pLineTokens and \
            pLineTokens is not xProvider["completion"]
   else
      local tMatches
      put false into tMatches
      
      local tMatchAny
      if xProvider["matchtoken"] is not kAutocompleteMatchAny then
         put pToken is not pLineTokens into tMatchAny
      else
         put xProvider["completion"] begins with pLineTokens into tMatches
         put true into tMatchAny
      end if
      
      if tMatches then
         return true
      end if
      
      if tMatchAny then
         put xProvider["completion"] begins with pToken and \
               pToken is not xProvider["completion"] into tMatches
         
         if tMatches then
            return true
         end if
         
         put xProvider["completion"] begins with the last token of pToken and \
               pToken is not xProvider["completion"] into tMatches
         
         if tMatches then
            put true into xProvider["match_only_token"]
            return true
         end if
         
         if xProvider["synonyms"] is an array then
            repeat for each element tSynonym in xProvider["synonyms"]
               put tSynonym begins with pToken into tMatches
               if tMatches then
                  return true
               end if
            end repeat
         end if
      end if
   end if
   
   return false
end __ProviderMatches

command __AutoCompleteFindProvidersDo pObject, pToken, pLineTokens, pLine, pSymbolClasses, pCallbackObject
   local tScope
   put __CurrentScope(pObject, pLine) into tScope
   
   local tMessageID
   if sLastFindMessageID is empty then
      exit __AutoCompleteFindProvidersDo
   else
      put sLastFindMessageID into tMessageID
   end if
   
   local tPriorities
   put the keys of sProviders into tPriorities
   sort tPriorities numeric descending
   
   repeat for each line tPriority in tPriorities
      local tClassList
      if pSymbolClasses is not an array then
         put the keys of sProviders[tPriority] into tClassList
         split tClassList by return
      else
         put pSymbolClasses into tClassList
      end if
      
      repeat for each element tClass in tClassList
         local tProvider
         repeat for each element tProvider in sProviders[tPriority][tClass]
            if __ProviderMatches(tProvider, tScope, pLineTokens, pToken) then
               local tFoundProviders
               __Push tProvider, tFoundProviders
               if the result is kAutocompleteMaxProviders then
                  dispatch "__AutoCompleteFoundProviders" to pCallbackObject with tFoundProviders
                  exit __AutoCompleteFindProvidersDo
               end if
            end if
            
            if sLastFindMessageID is not tMessageID then
               exit __AutoCompleteFindProvidersDo
            end if
            wait 0 with messages
         end repeat
      end repeat
   end repeat
   
   dispatch "__AutoCompleteFoundProviders" to pCallbackObject with tFoundProviders
end __AutoCompleteFindProvidersDo

private command __Push pElement, @xList
   local tSize
   put the number of elements of xList + 1 into tSize
   put pElement into xList[tSize]
   return tSize
end __Push

private command __ParseParams pParams, @xDisplayName, @xCompletion
   if the number of elements of pParams > 0 then
      repeat with tIndex = 1 to the number of elements of pParams
         put pParams[tIndex] & ", " after xDisplayName
         put "${" & pParams[tIndex] & ":expression}, " after xCompletion
      end repeat
      delete char -2 to -1 of xCompletion
      delete char -2 to -1 of xDisplayName
   end if
end __ParseParams

private command __GenerateProvidersByIntrospectingMessagePath pObject, @xProviders
   global gRevDevelopment
   
   local tProviders, tHandler, tVariable
   local tFound, tDescription
   put the effective revScriptDescription of pObject into tDescription
   repeat with tDescriptionIndex = 1 to the number of elements of tDescription
      if tDescription[tDescriptionIndex]["object"] is the long id of pObject or \
            ("development" is in the environment and \
            not gRevDevelopment and \
            revIDEObjectIsOnIDEStack(pObject)) then
         next repeat
      end if
      
      repeat for each key tHandler in tDescription[tDescriptionIndex]["description"]["handlers"]
         if tFound[tHandler] then
            next repeat
         end if
         
         put true into tFound[tHandler]
         
         __AddHandlerProvider \
               tHandler, \
               tDescription[tDescriptionIndex]["description"]["handlers"][tHandler], \
               kAutocompleteAvailableHandlerPriority, \
               xProviders
      end repeat
      
   end repeat
   
   local tGlobals
   put the globalNames into tGlobals
   
   if not gRevDevelopment then
      filter items of tGlobals without "gRev*"
   end if
   
   local tClass
   put "statement.command.undeclared.global" into tClass
   repeat for each item tGlobal in tGlobals
      local tIndex
      put the number of elements of xProviders[kAutocompleteUndeclaredGlobalPriority][tClass] + 1 into tIndex
      put "global" && tGlobal into xProviders[kAutocompleteUndeclaredGlobalPriority][tClass][tIndex]["displayname"]
      put "global" && tGlobal into xProviders[kAutocompleteUndeclaredGlobalPriority][tClass][tIndex]["completion"]
      put tClass into xProviders[kAutocompleteUndeclaredGlobalPriority][tClass][tIndex]["symbolclass"]
      put kAutocompleteMatchLine into xProviders[kAutocompleteUndeclaredGlobalPriority][tClass][tIndex]["matchtoken"]
      put kAutocompleteScopeAny into xProviders[kAutocompleteUndeclaredGlobalPriority][tClass][tIndex]["scope"]
   end repeat
end __GenerateProvidersByIntrospectingMessagePath

command AutoCompleteUpdateIntrospectedProviders pObject
   put sProvidersIncludingMsgPath into sProviders
   __GenerateProvidersByIntrospection pObject, word 2 of the selectedLine, sProviders
end AutoCompleteUpdateIntrospectedProviders

private command __GenerateProvidersByIntrospection pObject, pLine, @xProviders
   local tProviders, tHandler, tVariable
   
   put the revScriptDescription of pObject into sScriptDescription
   
   local tClass, tNames, tIndex
   
   repeat for each item tType in "local,global"
      put "expression.variable.script." & tType into tClass
      
      put sScriptDescription[tType&"s"] into tNames
      
      repeat for each element tName in tNames
         put the number of elements of xProviders[kAutocompleteScriptHandlerPriority][tClass] + 1 into tIndex
         put tName into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["displayname"]
         put tName into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["completion"]
         put tClass into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["symbolclass"]
         put kAutocompleteScopeHandler into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["scope"]
         put kAutocompleteMatchToken into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["matchtoken"]
      end repeat
   end repeat
   
   -- script constants are key -> value
   put "expression.variable.script.constant" into tClass
   
   put sScriptDescription["constants"] into tNames
   
   repeat for each key tName in tNames
      put the number of elements of xProviders[kAutocompleteScriptHandlerPriority][tClass] + 1 into tIndex
      put tName into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["displayname"]
      put tName into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["completion"]
      put tClass into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["symbolclass"]
      put kAutocompleteScopeHandler into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["scope"]
      put kAutocompleteMatchToken into xProviders[kAutocompleteScriptHandlerPriority][tClass][tIndex]["matchtoken"]
   end repeat
   
   repeat for each key tHandler in sScriptDescription["handlers"]
      local tHandlerInfo
      put sScriptDescription["handlers"][tHandler] into tHandlerInfo
      
      if tHandlerInfo["start_line"] <= pLine and \
            tHandlerInfo["end_line"] >= pLine then
         
         repeat for each item tType in "parameter,local,global,constant"
            put "expression.variable.handler." & tType into tClass
            
            put tHandlerInfo[tType & "s"] into tNames
            
            repeat for each element tName in tNames
               put the number of elements of xProviders[kAutocompleteHandlerLocalPriority][tClass] + 1 into tIndex
               put tName into xProviders[kAutocompleteHandlerLocalPriority][tClass][tIndex]["displayname"]
               put tName into xProviders[kAutocompleteHandlerLocalPriority][tClass][tIndex]["completion"]
               put tClass into xProviders[kAutocompleteHandlerLocalPriority][tClass][tIndex]["symbolclass"]
               put kAutocompleteScopeHandler into xProviders[kAutocompleteHandlerLocalPriority][tClass][tIndex]["scope"]
               put kAutocompleteMatchToken into xProviders[kAutocompleteHandlerLocalPriority][tClass][tIndex]["matchtoken"]
            end repeat
         end repeat
         
         -- special case exit and pass <handler>
         put the number of elements of xProviders[kAutocompleteHandlerLocalPriority]["statement.command"] + 1 into tIndex
         put "exit" && tHandler into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["displayname"]
         put "exit" && tHandler into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["completion"]
         put "statement.command" into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["symbolclass"]
         put kAutocompleteMatchLine into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["matchtoken"]
         put kAutocompleteScopeHandler into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["scope"]
         
         add 1 to tIndex
         put "pass" && tHandler into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["displayname"]
         put "pass" && tHandler into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["completion"]
         put "statement.command" into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["symbolclass"]
         put kAutocompleteMatchLine into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["matchtoken"]
         put kAutocompleteScopeHandler into xProviders[kAutocompleteHandlerLocalPriority]["statement.command"][tIndex]["scope"]
      else
         __AddHandlerProvider \
               tHandler, \
               tHandlerInfo, \
               kAutocompleteScriptHandlerPriority, \
               xProviders
      end if
   end repeat
end __GenerateProvidersByIntrospection

private command __AddHandlerProvider pHandler, pHandlerInfo, pPriority, @xProviders
   local tCompletion, tMatchToken, tParams, tIndex, tClass, tDisplayName
   
   put pHandler into tDisplayName
   switch pHandlerInfo["type"]
      case "setprop"
      case "getprop"
         put "expression.property.custom" into tClass
         put pHandler && "of ${object:expression.chunk.object}" into tCompletion
         put kAutocompleteMatchToken into tMatchToken
         break
      case "function"
         put "expression.function.script" into tClass
         put pHandler & "(" into tCompletion
         put "(" after tDisplayName
         __ParseParams pHandlerInfo["parameters"], tDisplayName, tCompletion
         put ")" after tDisplayName
         put ")" after tCompletion
         put kAutocompleteMatchToken into tMatchToken
         break
      default
         put "statement.command.script" into tClass
         put pHandler & space into tCompletion
         put space after tDisplayName
         __ParseParams pHandlerInfo["parameters"], tDisplayName, tCompletion
         put kAutocompleteMatchLine into tMatchToken
         break
   end switch
   
   if pHandlerInfo["is_private"] then
      put ".private" after tClass
   end if
   
   if not sProviderNames[pHandler] then
      put the number of elements of xProviders[pPriority][tClass] + 1 into tIndex
      put tDisplayName into xProviders[pPriority][tClass][tIndex]["displayname"]
      put tCompletion into xProviders[pPriority][tClass][tIndex]["completion"]
      put tClass into xProviders[pPriority][tClass][tIndex]["symbolclass"]
      put tMatchToken into xProviders[pPriority][tClass][tIndex]["matchtoken"]
      put kAutocompleteScopeHandler into xProviders[pPriority][tClass][tIndex]["scope"]
   end if
end __AddHandlerProvider

/*

Summary: Cancel the current provider search 

*/

private command __AutoCompleteCancelFind
   if sLastFindMessageID is not empty then
      cancel sLastFindMessageID
      put empty into sLastFindMessageID
   end if
end __AutoCompleteCancelFind

private command __CurrentTokens @rToken, @rLineTokens, @rChar, @rLine, @rLineChar
   put word 4 of the selectedChunk into rChar
   put word 2 of the selectedLine into rLine
   local tLine
   put the last line of (char 1 to rChar of field "Script" me) into tLine
   put the last word of tLine into rToken
   put word 1 to -1 of tLine into rLineTokens
   put the number of chars of tLine into rLineChar
end __CurrentTokens

private command __CancelFindProviders
   if there is a group "completion info" of me then
      set the visible of group "completion info" of me to false
   end if
   __AutoCompleteCancelFind
   delete variable sFoundProviders
end __CancelFindProviders

private command __UpdateAutoCompleteList pUUID
   local tChar, tLineChar, tLine, tToken, tLineTokens
   __CurrentTokens tToken, tLineTokens, tChar, tLine, tLineChar
   
   if tLineTokens is not empty and char 1 of tToken is not quote then
      local tSymbolClasses
      put sPlaceholders[pUUID]["classes"] into tSymbolClasses
      __AutoCompleteFindProviders \
            sObjectID, \
            tToken, \
            tLineTokens, \
            tLine, \
            tSymbolClasses, \
            the long id of me 
   else
      __CancelFindProviders
   end if
end __UpdateAutoCompleteList

private function __IconForSymbolClass pSymbolClass
   switch
      case pSymbolClass contains "command"
         return "<b>C</b>"
      case pSymbolClass contains "function"
         return "<b>F</b>"
      case pSymbolClass contains "property"
         return "<b>P</b>"
      case pSymbolClass contains "operator"
         return "<b>?</b>"
      case pSymbolClass contains "comment"
         return "<b>~</b>"
      case pSymbolClass contains "constant"
         return "<b><i>k</i></b>"
      case pSymbolClass contains "variable.handler.parameter"
         return "<b><i>p</i></b>"
      case pSymbolClass contains "variable.handler.local"
         return "<b><i>t</i></b>"
      case pSymbolClass contains "variable.script.local"
         return "<b><i>s</i></b>"
      case pSymbolClass contains "global"
         return "<b><i>g</i></b>"
      case pSymbolClass contains "object"
         return "<b>O</b>"
      default
         return "<b>" & toUpper(char 1 of pSymbolClass) & "</b>"
   end switch
end __IconForSymbolClass

on __AutoCompleteFoundProviders pProviders
   if the number of elements of pProviders is 0 then
      __CancelFindProviders
      exit __AutoCompleteFoundProviders
   end if
   
   if there is not a group "completion info" of me then
      create invisible group "completion info" in me
      create field "completions" in it
      set the listBehavior of it to true
      set the lockText of it to true
      set the dontWrap of it to true
      set the autoHilite of it to true
      set the backColor of it to 245,245,245
      set the borderColor of it to 235,235,235
      set the tabStops of it to 16
      set the hiliteColor of it to the effective hiliteColor of field "script" of me
      create field "summary" in group "completion info" of me
      set the lockText of it to true
      set the autoHilite of it to false
      set the backColor of it to 250,250,250
      set the borderColor of it to 235,235,235
   end if
   
   local tList
   repeat for each element tProvider in pProviders
      put tab & tProvider["displayname"] & return after tList
   end repeat
   delete the last char of tList
   
   lock screen
   set the text of field "completions" of group "completion info" of me to tList
   _internal script colorize \
         char 1 to (the number of chars of field "completions" of group "completion info" of me) \
         of field "completions" of group "completion info" of me
   
   put the htmlText of field "completions" of group "completion info" of me into tList
   
   local tIndex
   repeat with tIndex = 1 to the number of elements in pProviders
      if pProviders[tIndex]["deprecated"] then
         put "<p>" & __IconForSymbolClass(pProviders[tIndex]["symbolclass"]) & \
               "<strike>" & char 4 to -5 of line tIndex of tList & "</strike></p>" into line tIndex of tList
      else
         put "<p>" & __IconForSymbolClass(pProviders[tIndex]["symbolclass"]) & \
               char 4 to -1 of line tIndex of tList into line tIndex of tList
      end if
   end repeat
   set the htmlText of field "completions" of group "completion info" of me to tList
   
   put pProviders into sFoundProviders
   __DisplayCompletions 1
   unlock screen
end __AutoCompleteFoundProviders

private command __DisplayCompletions pIndex
   lock screen
   
   local tChar, tLineChar, tLine, tToken, tLineTokens
   __CurrentTokens tToken, tLineTokens, tChar, tLine, tLineChar
   
   local tRect
   local tTokenNum
   if sFoundProviders[pIndex]["match_only_token"] then
      put the number of tokens of tLineTokens into tTokenNum
      put the formattedRect of token tTokenNum of line tLine of field "script" of me into tRect
   else
      put the number of words of tLineTokens into tTokenNum
      if sFoundProviders[pIndex]["matchtoken"] is kAutocompleteMatchLine then
         put the formattedRect of word 1 to tTokenNum of line tLine of field "script" of me into tRect
      else
         put the formattedRect of word tTokenNum of line tLine of field "script" of me into tRect
      end if
   end if
   
   local tHeight
   if the number of elements of sFoundProviders > kAutocompleteVisibleProviders then
      put the formattedHeight of field "completions" of group "completion info" of me / \
            the number of elements of sFoundProviders * kAutocompleteVisibleProviders + 3 into tHeight
   else
      put the formattedHeight of field "completions" of group "completion info" of me into tHeight
   end if
   
   set the rect of field "completions" of group "completion info" of me to item 1 of tRect - 4, \
         item 4 of tRect, \
         the right of field "script" of me - the scrollbarWidth of field "script" of me,  \
         min(item 4 of tRect + tHeight, \
         the bottom of field "script" of me - the scrollbarWidth of field "script" of me)
   
   set the hilitedLine of field "completions" of group "completion info" of me to pIndex
   
   if sFoundProviders[pIndex]["summary"] is not empty then
      set the text of field "summary" of group "completion info" of me to sFoundProviders[pIndex]["summary"]
      set the width of field "summary" of group "completion info" of me to \
            the width of field "completions" of group "completion info" of me
      set the rect of field "summary" of group "completion info" of me to \
            the left of field "completions" of group "completion info" of me, \
            the bottom of field "completions" of group "completion info" of me - 4,  \
            the right of field "completions" of group "completion info" of me, \
            min(the bottom of field "completions" of group "completion info" of me - 4 + \
            the formattedHeight of field "summary" of group "completion info" of me, \
            the bottom of field "script" of me - the scrollbarWidth of field "script" of me)
      set the visible of field "summary" of group "completion info" of me to true
   else
      set the visible of field "summary" of group "completion info" of me to false
   end if
   set the visible of group "completion info" of me to true
   
   unlock screen
end __DisplayCompletions

private command __ClearCurrentPlaceholder
   lock screen
   
   local tChunk
   if the number of elements of sEditChunks > 0 then
      repeat for each element tChunk in sEditChunks
         delete variable sPlaceholders[char tChunk["start"] to tChunk["end"] of field "script" of me]
         set the linkText of char tChunk["start"] to tChunk["end"] of field "script" of me to empty
         set the backgroundColor of char tChunk["start"] to tChunk["end"] of field "script" of me to empty
      end repeat
      delete variable sEditChunks
   end if
   
   __CancelFindProviders
   unlock screen
end __ClearCurrentPlaceholder

private command __SetCompletionString pProvider
   local tChar, tLineChar, tLine, tToken, tLineTokens
   __CurrentTokens tToken, tLineTokens, tChar, tLine, tLineChar
   
   if not __ProviderMatches( \
         pProvider, \
         __CurrentScope(sObjectId, tLine), \
         tLineTokens, \
         tToken) then
      return false
   end if
   
   if the number of lines of pProvider["completion"] > 1 then
      -- add the current line indent to the lines
      local tIndent
      put textFormatGetLineIndent(line tLine of field "script" of me) into tIndent
      repeat with tIndex = 2 to the number of lines of pProvider["completion"]
         put tIndent before line tIndex of pProvider["completion"]
      end repeat
   end if
   lock screen
   lock messages
   
   local tPlaceholders
   local tPlaceholder
   
   local tStartOffset = 0
   repeat forever
      local tOffset
      put offset(kAutocompletePlaceholderStart, pProvider["completion"], tStartOffset) into tOffset
      if tOffset is 0 then
         exit repeat
      end if
      
      add tOffset to tStartOffset
      
      local tEndOffset
      put offset(kAutocompletePlaceholderEnd, pProvider["completion"], tStartOffset+1) into tOffset
      if tOffset is 0 then
         -- error start but no end...
         exit repeat
      end if
      put tOffset + tStartOffset+1 into tEndOffset
      
      put character tStartOffset + 2 to (tEndOffset - 1) of pProvider["completion"] into tPlaceholder
      
      split tPlaceholder with kAutocompleteNameDelimiter
      if tPlaceholder[2] is not empty then
         split tPlaceholder[2] with kAutocompleteClassDelimiter
      end if
      
      local tLength
      put the length of tPlaceholder[1] into tLength
      
      put tPlaceholder[1] into character tStartOffset to tEndOffset of pProvider["completion"]
      
      local tPlaceholderNum
      put the number of elements of tPlaceholders[tPlaceholder[1]]["instances"] + 1 into tPlaceholderNum
      
      if tPlaceholderNum is 1 then
         put uuid() into tPlaceholders[tPlaceholder[1]]["uuid"]
         put tPlaceholder[2] into sPlaceholders[tPlaceholders[tPlaceholder[1]]["uuid"]]["classes"]
      end if
      
      put tStartOffset into tPlaceholders[tPlaceholder[1]]["instances"][tPlaceholderNum]["start"]
      add tLength-1 to tStartOffset
      put tStartOffset into tPlaceholders[tPlaceholder[1]]["instances"][tPlaceholderNum]["end"]
   end repeat
   
   set the linkText of the selectedChunk to empty
   
   local tChunkOffset
   if pProvider["matchtoken"] is kAutocompleteMatchLine then
      put tChar - the length of tLineTokens + 1 into tChunkOffset
      
      textReplace tChunkOffset, tLineTokens, pProvider["completion"]
   else
      if pProvider["match_only_token"] then
         put the last token of tToken into tToken
         put tChar - the length of tToken + 1 into tChunkOffset
      else
         put tChar - the length of tToken + 1 into tChunkOffset
      end if
      textReplace tChunkOffset, tToken, pProvider["completion"]
   end if
   
   local tPlaceholderType
   repeat for each element tPlaceholderType in tPlaceholders
      repeat for each element tPlaceholder in tPlaceholderType["instances"]
         set the linkText of character tPlaceholder["start"] +tChunkOffset-1 \
               to tPlaceholder["end"]+tChunkOffset-1 of field "script" of me to tPlaceholderType["uuid"]
         set the backgroundColor of character tPlaceholder["start"] +tChunkOffset-1 \
               to tPlaceholder["end"]+tChunkOffset-1 of field "script" of me to kAutocompleteBackgroundColor
      end repeat
   end repeat
   
   __CancelFindProviders
   __SelectNextPlaceholder tLineChar, tLine, tLine + kAutocompletePlaceholderSearchLines
   
   return the result
end __SetCompletionString


private command __SelectNextPlaceholder pChar, pFromParagraph, pToParagraph
   local tStyle
   
   put the styledText of line pFromParagraph to pToParagraph of field "script" of me into tStyle
   local tParagraphIndex
   repeat with tParagraphIndex = 1 to the number of elements of tStyle
      local tRunOffset
      put 0 into tRunOffset
      local tRunIndex
      repeat with tRunIndex = 1 to the number of elements of tStyle[tParagraphIndex]["runs"]
         if tParagraphIndex > 1 or (tParagraphIndex is 1 and (tRunOffset + 1) >= pChar) then
            if tStyle[tParagraphIndex]["runs"][tRunIndex]["style"]["linkText"] is not empty then
               __SelectPlaceholder tStyle[tParagraphIndex]["runs"][tRunIndex]["style"]["linkText"], pFromParagraph, pToParagraph, tStyle
               return true
            end if
         end if
         add the length of tStyle[tParagraphIndex]["runs"][tRunIndex]["text"] to tRunOffset
      end repeat
   end repeat
   
   select after line pFromParagraph of field "script" of me
   
   return false
end __SelectNextPlaceholder

private command __SelectPlaceholder pUUID, pFromParagraph, pToParagraph, pStyledText
   if pFromParagraph is empty then
      put 1 into pFromParagraph
   end if
   
   if pToParagraph is empty then
      put -1 into pToParagraph
   end if
   
   local tOffset
   put 0 into tOffset
   if pStyledText is empty then
      put the styledText of line pFromParagraph to pToParagraph of field "script" of me into pStyledText
   else
      put the number of chars of line 1 to pFromParagraph-1 of field "script" of me + 1 into tOffset
   end if
   
   local tScroll
   put the vScroll of field "script" of me into tScroll["v"]
   put the hScroll of field "script" of me into tScroll["h"]
   lock screen
   
   delete variable sEditChunks
   
   local tParagraphIndex
   repeat with tParagraphIndex = 1 to the number of elements of pStyledText
      local tRunIndex
      repeat with tRunIndex = 1 to the number of elements of pStyledText[tParagraphIndex]["runs"]
         if pUUID is pStyledText[tParagraphIndex]["runs"][tRunIndex]["style"]["linkText"]  then
            put the effective hiliteColor of field "Script" of me \
                  into pStyledText[tParagraphIndex]["runs"][tRunIndex]["style"]["backgroundColor"]
            local tPlaceholderNum
            put the number of elements of sEditChunks + 1 into tPlaceholderNum
            put tOffset+1 into sEditChunks[tPlaceholderNum]["start"]
            put tOffset+the length of pStyledText[tParagraphIndex]["runs"][tRunIndex]["text"] into sEditChunks[tPlaceholderNum]["end"]
         else if pStyledText[tParagraphIndex]["runs"][tRunIndex]["style"]["linkText"] is not empty then
            put kAutocompleteBackgroundColor into pStyledText[tParagraphIndex]["runs"][tRunIndex]["style"]["backgroundColor"]
         end if
         add the length of pStyledText[tParagraphIndex]["runs"][tRunIndex]["text"] to tOffset
      end repeat
      add 1 to tOffset
   end repeat
   
   set the styledText of line pFromParagraph to pToParagraph of field "script" of me to pStyledText
   set the vScroll of field "script" of me to tScroll["v"]
   set the hScroll of field "script" of me to tScroll["h"]
   
   if the number of elements of sEditChunks > 0 then
      -- select the first chunk
      select char sEditChunks[1]["start"] to sEditChunks[1]["end"] of field "script" of me
   end if
end __SelectPlaceholder

private command __UpdateSelection
   lock screen
   lock messages
   local tChunk
   put the selectedChunk into tChunk
   if tChunk is empty then exit __UpdateSelection
   local tUUID
   put the linkText of tChunk into tUUID
   if tUUID is not empty then
      __SelectPlaceholder tUUID
   end if
end __UpdateSelection

private command __GenerateProvidersFromDocs
   if there is not a stack "revIDEDocumentationLibrary" then
      exit __GenerateProvidersFromDocs
   end if
   
   local tProviders
   
   #functions
   local theDocs
   put ideDocsFetchLCSElementsOfType("function") into theDocs
   
   local theDoc
   repeat for each element theDoc in theDocs
      local theSyntax
      repeat for each element theSyntax in theDoc["syntax"]
         replace "[" with empty in theSyntax
         replace "]" with empty in theSyntax
         replace "{" with empty in theSyntax
         replace "}" with empty in theSyntax
         
         -- parameters
         local theFunctionName, theParameters
         put empty into theFunctionName
         put empty into theParameters
         if theSyntax contains "(" then
            if MatchText(theSyntax,"(?i)^(.*)\((<.*)\)",theFunctionName,theParameters) then
               put replaceText(theParameters, "\(.*\)", "") into theParameters
               
               put "(" after theFunctionName
               
               local theBody
               put theFunctionName into theBody
               
               if theParameters is not empty then
                  replace "<" with "" in theParameters
                  replace ">" with "" in theParameters
                  split theParameters with comma
                  repeat with theIndex = 1 to the number of elements of theParameters
                     split theParameters[theIndex] with "|"
                     replace space with empty in theParameters[theIndex][1]
                     put "${"&theParameters[theIndex][1]&":expression}, "  after theBody
                     put theParameters[theIndex][1] & ", " after theFunctionName
                  end repeat
                  put ")" into char -2 to -1 of theFunctionName
                  put ")" into char -2 to -1 of theBody
               else
                  put ")" after theBody
               end if
               __AddProvider \
                     tProviders, \
                     theFunctionName, \
                     theBody, \
                     "expression.function.global", \
                     kAutocompleteScopeHandler, \
                     kAutocompleteDocsPriority, \
                     kAutocompleteMatchToken, \
                     theDoc
            else
               __AddProvider \
                     tProviders, \
                     theSyntax, \
                     theSyntax, \
                     "expression.function.global", \
                     kAutocompleteScopeHandler, \
                     kAutocompleteDocsPriority, \
                     kAutocompleteMatchToken, \
                     theDoc
            end if
            
         else
            
            local theOptions, theParameter
            
            if theSyntax contains "of" then
               put word 2 to -4 of theSyntax into theOptions
               put word -3 of theSyntax into theFunctionName
               put word -1 of theSyntax into theParameter
               replace "<" with "" in theParameter
               replace ">" with "" in theParameter
               put " of ${"&theParameter&":expression}"  into theParameter
            else
               put empty into theParameter
               put word 2 to -2 of theSyntax into theOptions
               put word -1 of theSyntax into theFunctionName
            end if
            
            if theOptions contains "|" then
               split theOptions with "|"
               repeat with theIndex = 1 to the number of elements of theOptions
                  -- trim
                  put word 1 to -1 of theOptions[theIndex] into theOptions[theIndex]
                  if theOptions[theIndex] is not empty then
                     put space after theOptions[theIndex]
                  end if
                  __AddProvider \
                        tProviders, \
                        theOptions[theIndex] & theFunctionName, \
                        theOptions[theIndex] & theFunctionName & theParameter, \
                        "expression.function.global", \
                        kAutocompleteScopeHandler, \
                        kAutocompleteDocsPriority, \
                        kAutocompleteMatchToken, \
                        theDoc
               end repeat
            end if
         end if
      end repeat
   end repeat
   
   # messages
   put ideDocsFetchLCSElementsOfType("message") into theDocs
   
   local tTabDepth = 3
   try
      put sePrefGet("editor,tabdepth") into tTabDepth
   end try
   
   local tIndent
   repeat for tTabDepth
      put space after tIndent
   end repeat
   
   repeat for each element theDoc in theDocs
      repeat for each element theSyntax in theDoc["syntax"]
         replace "<" with "" in theSyntax
         replace ">" with "" in theSyntax
         
         local theMessageName
         put word 1 of theSyntax into theMessageName
         put word 2 to -1 of theSyntax into theParameters
         put theMessageName into theSyntax
         split theParameters by comma
         repeat with theIndex = 1 to the number of elements of theParameters
            if theParameters[theIndex] contains "|" then
               -- unfortunately some of the syntax definitions describe a set of possible values
               -- or parameter types and this simplifies things considerably...
               put "Value" into theParameter
            else
               -- trim
               put word 1 of theParameters[theIndex] into theParameter
            end if
            put space & theParameter & comma after theSyntax
         end repeat
         if the last char of theSyntax is comma then
            delete the last char of theSyntax
         end if
         
         put "on" && theSyntax & return & tIndent & "${-- code:statement}" & return & "end" && theMessageName into theBody
         __AddProvider \
               tProviders, \
               theSyntax, \
               theBody, \
               "message", \
               kAutocompleteScopeScript, \
               kAutocompleteDocsPriority, \
               kAutocompleteMatchLine, \
               theDoc
      end repeat
   end repeat
   
   # properties
   put ideDocsFetchLCSElementsOfType("property") into theDocs
   
   repeat for each element theDoc in theDocs
      
      local tClass
      if theDoc["associations"] is an array then
         put "expression.property.object" into tClass
      else
         put "expression.property.global" into tClass
      end if
      
      repeat for each element theSyntax in theDoc["syntax"]
         -- strip off set|put the
         replace "[" with "" in theSyntax
         replace "]" with "" in theSyntax
         
         local theSnippet
         put theSyntax into theSnippet
         
         replace "<" with "" in theSyntax
         replace ">" with "" in theSyntax
         
         local tStartChar, tEndChar
         repeat while matchChunk(theSnippet, "(\{.*?\})", tStartChar, tEndChar)
            local tOptions
            put char tStartChar+1 to tEndChar-1 of theSnippet into tOptions
            local tNewOptions
            put empty into tNewOptions
            repeat for each word tOption in tOptions
               if tOption is "|" then
                  next repeat
               end if
               
               if tNewOptions is not empty then
                  put "OR" after tNewOptions
               end if
               if tOption begins with "<" then
                  put char 2 to -2 of tOption after tNewOptions
               else
                  put tOption after tNewOptions
               end if
            end repeat
            put "$<" & tNewOptions & ":expression>" into char tStartChar to tEndChar of theSnippet
         end repeat
         
         replace "$<" with "${" in theSnippet
         replace ":expression>" with ":expression}" in theSnippet
         
         repeat while matchChunk(theSnippet, "(\<.*?\>)", tStartChar, tEndChar)
            put "${" & char tStartChar+1 to tEndChar-1 of theSnippet & ":expression}" into char tStartChar to tEndChar of theSnippet
         end repeat
         
         set the itemDelimiter to comma
         if word 1 of theSyntax is among the items of "get,put" then
            __AddProvider \
                  tProviders, \
                  word 3 to -1 of theSyntax, \
                  word 3 to -1 of theSnippet, \
                  tClass, \
                  kAutocompleteScopeHandler, \
                  kAutocompleteDocsPriority, \
                  kAutocompleteMatchToken, \
                  theDoc
         else
            __AddProvider \
                  tProviders, \
                  theSyntax, \
                  theSnippet, \
                  tClass, \
                  kAutocompleteScopeHandler, \
                  kAutocompleteDocsPriority, \
                  kAutocompleteMatchLine, \
                  theDoc
         end if
      end repeat
   end repeat
   
   # keywords
   put ideDocsFetchLCSElementsOfType("keyword") into theDocs
   
   repeat for each element theDoc in theDocs
      repeat for each element theSyntax in theDoc["syntax"]
         -- strip off set|put the
         if theSyntax is "[]" then next repeat
         if theSyntax is "\" then next repeat
         __AddProvider \
               tProviders, \
               theSyntax, \
               theSyntax, \
               "keyword", \
               kAutocompleteScopeHandler, \
               kAutocompleteDocsPriority, \
               kAutocompleteMatchToken, \
               theDoc
      end repeat
   end repeat
   
   # constants
   put ideDocsFetchLCSElementsOfType("constant") into theDocs
   
   repeat for each element theDoc in theDocs
      repeat for each element theSyntax in theDoc["syntax"]
         __AddProvider \
               tProviders, \
               theSyntax, \
               theSyntax, \
               "constant", \
               kAutocompleteScopeHandler, \
               kAutocompleteDocsPriority, \
               kAutocompleteMatchToken, \
               theDoc
      end repeat
   end repeat
   
   # objects
   put ideDocsFetchLCSElementsOfType("object") into theDocs
   
   repeat for each element theDoc in theDocs
      repeat for each element theSyntax in theDoc["syntax"]
         if theSyntax begins with "ios" or theSyntax begins with "Android" then
            next repeat
         end if
         
         __AddProvider \
               tProviders, \
               theSyntax, \
               theSyntax, \
               "expression.chunk.object", \
               kAutocompleteScopeHandler, \
               kAutocompleteDocsPriority, \
               kAutocompleteMatchToken, \
               theDoc
      end repeat
   end repeat
   
   # operators
   put ideDocsFetchLCSElementsOfType("operator") into theDocs
   
   repeat for each element theDoc in theDocs
      repeat for each element theSyntax in theDoc["syntax"]
         replace "&gt;" with ">" in theSyntax
         replace "&lt:" with "<" in theSyntax
         
         if the number of chars of word 1 of theSyntax is 1 then
            next repeat
         end if
         if the number of chars of word 1 of theSyntax < 5 and the number of words in theSyntax is 2 then
            next repeat
         end if
         repeat for each line theSnippet in __ParseSyntaxDefinition(theSyntax)
            if theSnippet is empty then next repeat
            
            local checkAn
            put 2 into checkAn
            if word checkAn of theSnippet is "not" then
               add 1 to checkAn
            end if
            if word checkAn of theSnippet is "an" and char 1 of word checkAn+1 of theSnippet is not among the chars of "aeiou" then
               next repeat
            end if
            if word checkAn of theSnippet is "a" and char 1 of word checkAn+1 of theSnippet is among the chars of "aeiou" then
               next repeat
            end if
            
            local theParsedSyntax
            put theSnippet into theParsedSyntax
            replace "<" with "" in theParsedSyntax
            replace ">" with "" in theParsedSyntax
            
            replace "<" with "${" in theSnippet
            replace ">" with "}" in theSnippet
            
            set the itemDelimiter to "}"
            repeat with theIndex = 1 to the number of items of theSnippet-1
               put ":expression" after item theIndex of theSnippet
            end repeat
            
            __AddProvider \
                  tProviders, \
                  theParsedSyntax, \
                  theSnippet, \
                  "operator", \
                  kAutocompleteScopeHandler, \
                  kAutocompleteDocsPriority, \
                  kAutocompleteMatchToken, \
                  theDoc
         end repeat
      end repeat
   end repeat
   
   # commands
   put ideDocsFetchLCSElementsOfType("command") into theDocs
   
   set the itemDelimiter to comma
   repeat for each element theDoc in theDocs
      repeat for each element theSyntaxDefinition in theDoc["syntax"]
         local tScope
         if word 1 of theSyntaxDefinition is among the items of "local,constant,global" then
            put kAutocompleteScopeAny into tScope
         else
            put kAutocompleteScopeHandler into tScope
         end if
         
         repeat for each line theSyntax in __ParseSyntaxDefinition(theSyntaxDefinition)
            if theSyntax is empty then next repeat -- not sure why we are geting empty lines
            put theSyntax into theParameters
            replace "<" with "" in theSyntax
            replace ">" with "" in theSyntax
            
            split theParameters with "<"
            repeat with theIndex = 1 to the number of elements of theParameters
               if theIndex is 1 then
                  put theParameters[theIndex] into theBody
               else
                  split theParameters[theIndex] with ">"
                  put "${"&theParameters[theIndex][1]&":expression}"&theParameters[theIndex][2] after theBody
               end if
            end repeat
            __AddProvider \
                  tProviders, \
                  theSyntax, \
                  theBody, \
                  "statement.command", \
                  tScope, \
                  kAutocompleteDocsPriority, \
                  kAutocompleteMatchLine, \
                  theDoc
         end repeat
      end repeat
   end repeat
   
   -- extra stuff
   __AddProvider \
         tProviders, \
         "-- comment", \
         "-- ${comment:expression}", \
         "comment.line", \
         kAutocompleteScopeAny, \
         kAutocompleteDocsPriority, \
         kAutocompleteMatchAny
   
   __AddProvider \
         tProviders, \
         "/* block comment */", \
         "/*" & return & "${comment:expression}" & return & "*/", \
         "comment.block", \
         kAutocompleteScopeAny, \
         kAutocompleteDocsPriority, \
         kAutocompleteMatchLine 
   
   __AddProvider \
         tProviders, \
         "/* comment */", \
         "/* ${comment:expression} */", \
         "comment.block", \
         kAutocompleteScopeHandler, \
         kAutocompleteDocsPriority, \
         kAutocompleteMatchToken
   
   __AddProvider \
         tProviders, \
         "// comment", \
         "// ${comment:expression}", \
         "comment.line", \
         kAutocompleteScopeAny, \
         kAutocompleteDocsPriority, \
         kAutocompleteMatchAny
   
   local tLCDoc
   put "/**" & return & \
         "Summary: ${summary:expression}" & \
         return & return & \
         "Example:" & return & "${example:expression}" & \
         return & return & \
         "Description:" & return &"${description:expression}" & \
         return & return & \
         "Parameters:"& return & "${parameters:expression}" & \
         return & return & \
         "Returns:"& return & "${returns:expression}" & \
         return & return & \
         "Tags: ${tags:expression}" & \
         return & "**/" into tLCDoc
   
   __AddProvider \
         tProviders, \
         "/** lcdoc comment **/", \
         tLCDoc, \
         "comment.block.lcdoc", \
         kAutocompleteScopeScript, \
         kAutocompleteDocsPriority, \
         kAutocompleteMatchAny
   
   AutoCompleteRegisterProviders tProviders
end __GenerateProvidersFromDocs

private function __ParseOptionalSyntax pSyntaxDefinition
   local foundStartChar, foundEndChar
   put 0 into foundStartChar
   put 0 into foundEndChar
   put offset("[",pSyntaxDefinition,foundStartChar) into foundStartChar
   -- answer files broken and making me hit recurstion limits
   if char 1 to foundStartChar of pSyntaxDefinition contains "]" then
      replace "]" with empty in char 1 to foundStartChar of pSyntaxDefinition
      put offset("[",pSyntaxDefinition,0) into foundStartChar
   end if
   if foundStartChar > 0 then
      repeat
         local theChar
         put offset("]",pSyntaxDefinition,foundEndChar) into theChar
         put foundEndChar + theChar into foundEndChar
         if foundEndChar = 0 then
            -- unmatched pairs
            replace "[" with "" in pSyntaxDefinition
            exit repeat
         end if
         
         local theOption
         put char foundStartChar+1 to foundEndChar-1 of pSyntaxDefinition into theOption
         -- nested optional syntax...
         if "[" is not in theOption then
            exit repeat
         else
            local theBracketCount
            -- check for matching pairs
            put 0 into theBracketCount
            repeat with X = 1 to the number of chars of theOption
               if char X of theOption is "[" then
                  add 1 to theBracketCount
               else if char X of theOption is "]" then
                  subtract 1 from theBracketCount
               end if
            end repeat
            if theBracketCount is 0 then
               exit repeat
            end if
         end if
      end repeat

      if foundEndChar <> 0 then
         -- we found some optional syntax so we need to split the syntax defintion into two
         local theOption1, theOption2
         put pSyntaxDefinition into theOption1
         delete char foundEndChar of theOption1
         delete char foundStartChar of theOption1
         put pSyntaxDefinition into theOption2
         delete char foundStartChar to foundEndChar of theOption2
         put __ParseOptionalSyntax(theOption1) into theOption1
         put __ParseOptionalSyntax(theOption2) into theOption2
         return theOption1 & cr & theOption2
      end if
   end if

   return pSyntaxDefinition
end __ParseOptionalSyntax

private function __ParseVariationSyntax pSyntaxDefinition
   local foundStartChar, foundEndChar
   put 0 into foundStartChar
   put 0 into foundEndChar

   put offset("{",pSyntaxDefinition,foundStartChar) into foundStartChar
   if foundStartChar <> 0 then
      put offset("}",pSyntaxDefinition,foundEndChar) into foundEndChar
      if foundEndChar = 0 then
         exit repeat
      end if
      
      local theVariations
      put char foundStartChar+1 to foundEndChar-1 of pSyntaxDefinition into theVariations

      if foundEndChar <> 0 then
         -- we found an array of variable syntax
         set the itemDelimiter to "|"
         repeat for each item theVariation in theVariations
            local theSyntax, theSyntaxes
            put pSyntaxDefinition into theSyntax
            put theVariation into char foundStartChar to foundEndChar of theSyntax
            put __ParseVariationSyntax(theSyntax) & cr after theSyntaxes
         end repeat
         return theSyntaxes
      end if
   end if
    
   return pSyntaxDefinition
end __ParseVariationSyntax

private function __ParseSyntaxDefinition pSyntaxDefinition
   local theSyntaxes
   replace ", ..." with "" in pSyntaxDefinition
   replace "..." with "" in pSyntaxDefinition
   
   put __ParseOptionalSyntax(pSyntaxDefinition) into theSyntaxes
   local theParsedSyntaxes
   repeat for each line theSyntax in theSyntaxes
      put __ParseVariationSyntax(theSyntax) & cr after theParsedSyntaxes
   end repeat
   
   return theParsedSyntaxes
end __ParseSyntaxDefinition

private command __AddProvider @xProviders, pName, pCompletion, pSymbolClass, pScope, pPriority, pMatchToken, pDoc
   local tIndex
   put the number of elements of xProviders + 1 into tIndex
   if pPriority is empty then 
      put 50 into pPriority
   end if
   
   -- we want a completion that matches the entire line to be listed first
   if pMatchToken is kAutocompleteMatchLine then
      add 1 to pPriority
   end if
   
   put pPriority into xProviders[tIndex]["priority"]
   put replaceText(pName," +"," ") into xProviders[tIndex]["displayname"]
   put replaceText(pCompletion," +"," ") into xProviders[tIndex]["completion"]
   put pSymbolClass into xProviders[tIndex]["symbolclass"]
   put pScope into xProviders[tIndex]["scope"]
   if pMatchToken is empty then 
      put kAutocompleteMatchToken into xProviders[tIndex]["matchtoken"]
   else
      put pMatchToken into xProviders[tIndex]["matchtoken"]
   end if
   put pDoc["synonyms"] into xProviders[tIndex]["synonyms"]
   
   replace return with space in pDoc["summary"]
   
   local tRegex, tStart, tEnd
   put "\<([^\>]*)\>" into tRegex
   set the itemdelimiter to "|"
   local tSummary, tReplacement
   repeat while matchChunk(pDoc["summary"], tRegex, tStart, tEnd)
      put char 1 to tStart - 2 of pDoc["summary"] after tSummary
      put char tStart to tEnd of pDoc["summary"] into tReplacement
      if item 2 of tReplacement is not empty then
         put item 2 of tReplacement into tReplacement
      end if	
      put tReplacement after tSummary
      delete char 1 to tEnd + 1 of pDoc["summary"]
   end repeat
   
   put tSummary & pDoc["summary"] into xProviders[tIndex]["summary"]
   
   put pDoc["deprecated"] is not empty into xProviders[tIndex]["deprecated"]
end __AddProvider

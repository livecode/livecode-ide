	{
	"name":"extending_livecode",
	"display name":"Extending LiveCode",
	"data":"\n\n# Introduction\n\nLiveCode 8.0 is the most exciting release in the history of the technology. It provides a simple way to extend the functionality or control set of LiveCode.\n\nOur focus in LiveCode 8.0 is extensibility. You can now build and share widgets (custom controls) and libraries that are treated by LiveCode as engine level elements.\n\nLiveCode 8.0 can be thought of as a version 7.0 with a new module allowing extensions to be plugged into the engine. As a result, 8.0 should be as functional and stable as LiveCode 7.0.\n\nThis guide will take you through the process of installing and using these new widgets and libraries and for the adventurous among you, provide a guide to building and sharing your own extensions. \n\n## LiveCode Script vs LiveCode Builder\nTo make it possible to create extensions and plug them into the LiveCode engine we've created a new flavour of our language called ***LiveCode Builder***. LiveCode Builder looks a lot like LiveCode Script so should feel familiar for any seasoned LiveCode developer. There is lots of new syntax which exposes parts of the LiveCode engine that were only previously available to those who were skilled c/c++ developers.\n\nTo learn more about LiveCode Builder and creating extensions, read on.\n\n> *Warning:* It is important to stress right at the start that ***no aspect of LiveCode Builder should considered final***. ***Every piece of syntax in LiveCode Builder is subject to change***.\n\n## IDE\nA number of palettes have been replaced and new ones added in order to support extensions. The tools palette, message box and property inspector have been rewritten. An extension manager stack has been added to keep track of installed extensions, and a plugin added to help users create their own extensions.\n\n## Installers\n\nInstallers for the first alpha of LiveCode 8 can be found at:\n\nhttp://downloads.livecode.com/\n\n# Installing Extensions\n\n## 1) Open the extension manager\nTo install an extension open the extension manager from the *Tools* menu: ```Tools > Extension Manager```\n\n![](images/extensions-manager.png)\n\nNotice the extension manager has three tabs:\n\n* Widgets - Displays locally widgets\n* Libraries - Displays installed libraries\n* Extension Store - Displays the extension portal through which you can download any extension shared by another developer\n\n> Note: Only open source (free) extensions can be shared and downloaded in this release. We will be adding commercial (paid) extensions in future releases\n\n## 2) Go to the extension store\nGo to the extension by clicking on the extension store tab and wait for it to load (Internet connectivity is required).\n\n![enter image description here](images/extensions-home.png)\n\nYou can browse by category or search for an extension.\n\n## 3) Select an extension\nClick on any of the extensions to load full details and installation options.\n\n![enter image description here](images/extensions-clock.png)\n\n## 4) Install the extension\nClick on the install button to begin the download and installation of the extension. It should only take a matter of seconds to download and install.\n\n![enter image description here](images/extensions-installed.png)\n\n## 5) Try out your extension\n\n**Widgets**\nIf you downloaded a widget it will appear in your list of installed widgets and also in your Tools Palette. Using the widget is no different from any of the classic LiveCode controls you've been used to. Simply drag it onto a stack and start interacting with it as you could any another control.\n\n![enter image description here](images/extensions-widgets.png)\n\nYou can reference the widget in script as a control:\n\n```\nset the name of the last control to \"clock\"\n```\n\nOr more specifically as a widget:\n\n```\nset the tooltip of widget 1 to \"This is my nice new clock widget\"\n```\n\n**Libraries**\nIf you downloaded a library it will appear in your list of installed libraries. A library adds new functions and commands to the LiveCode engine which become available automatically to you in LiveCode script, just like the standard syntax. Open the documentation stack to view a full list of the new functions provided by a newly installed extension.\n\n## 6) Extension Documentation\nExtensions can provide an API (Dictionary) and User Guide as part of the installed package. They are installed and viewable through the LiveCode Dictionary stack.\n\n**API (Dictionary)**\n\n![enter image description here](images/extensions-documentation.png)\n\n1. Open the documentation stack from the menubar\n2. API chooser - Choose which API to view. By default, LiveCode 8.0 comes with the LiveCode Script API and the new LiveCode Builder API. Any extension that contains an API is displayed here.\n3. Category Filter - Click on the tags to filter the API entries. \n4. Search Filter - Enter a text string to filter the API entries by a specific search string\n5. History - Move back and forward through your API navigation history\n6. Entry List - Select the entry to display from this list\n7. Entry - The entry describing the syntax\n\n**User Guide**\n\n![enter image description here](images/extensions-guides.jpg)\n\n1. Click on the \"Guide\" tab at the top of the documentation stack\n2. Select the guide you wish to view\n\n> Note: In LiveCode 8.0 we'll be including an updated version of the LiveCode Script User Guide. The version currently included with LiveCode has not yet been updated.\n\n# Creating Extensions\n\nWe have provided a new \"Widget Builder\" plugin to help make development and packaging of extensions as easy as possible. \n\n> **Note:** LiveCode Builder is a different flavour of LiveCode so it is not possible to edit LiveCode Builder scripts in the main LiveCode Script IDE.\n\n## Widget Builder Plugin\n\nOpen the \"Widget Builder\" plugin for the development menu:\n\n```\nDevelopment > Plugins > Widget Builder\n```\n\n![enter image description here](images/extensions-plugin-overview.png)\n\n1. Select the extension you wish the develop or click the \"open\" icon in the header back to locate an extension you've not loaded before. All LiveCode authored widgets in the application package at: /contents/extensions/. To play with one of these extensions we recommend copying the folder from the application package to your desktop and loading it from there. Changing the extension id in the source code will also mean it doesn't conflict with the existing extension.\n2. Data that the builder was able to parse from the directory such as icons, resources, API's the user guides.\n3. Console: Shows status, error and log messages.\n4. Test: Creates a stack, compiles the extensions and creates an instance.\n5. Script: Opens the lcb script in an external default editor.\n6. Insall: Installs the extension into the IDE\n7. Uninstall: Uninstalls the extension from the IDE\n8. Package: Creates a .lce package which can uploaded to the extension store. It is placed in the extension directory\n\n> **Note:** A great way to get started is to tweak the script of one of our widgets examples.\n> \n##Create your Own\n### Simple Widget\nA widget and a library are identical, except that a widget draws to a canvas. As a result, the authoring process is much the same for both extension types.\n\n### Create a .lcb file\nStart by creating a plain text file and save it do disk with the extension \"lcb\":\n\n```\n/Desktop/widgettest/main.lcb\n```\n\nNow open the plugin as shown above and click on the load icon to load your freshly created ***.lcb*** file into the builder. You can now start authoring your first extension.\n\n### Declare Type and Identifier\nStart by declaring the type of extension, either \"widget\" or \"library\" followed by your identifier (See \"Select A Developer ID\" below).\n```\nwidget community.livecode.beaumont.pinkCircle\n   # Code for your widget\nend widget\n```\nThis is the unique identifier by which your extension will be referred to by the LiveCode Engine.\n\n### Declare Meta Data\nNext, provide meta data to help LiveCode display your product correctly in product and in the online portal.\n\n```\nwidget community.livecode.beaumont.pinkCircle\n\nmetadata title is \"My Pink Circle\"\nmetadata author is \"Benjamin Beaumont\"\nmetadata version is \"1.0.0\"\n\nend widget\n```\n\n### Importing libraries\nThe LiveCode builder syntax is broken down into **modules**. There are 3 classes of module:\n\nType|Description\n---|---\nDefault|The module is part of LiveCode builder and is included by default. Their syntax is always available to you as a LiveCode developer.\nOptional|The module is created and distributed by LiveCode Ltd and must be imported by the extension developer in order to make use of the syntax.\nCustom|This module is created and distributed through the online portal and must be imported by the extension developer in order to make use of the syntax.\n\nLiveCode builder contains the following modules:\n\nModule|Type|Description\n---|---|---\ncom.livecode.canvas|Optional|Provides the syntax and types for 2D drawing allowing developers to draw to a canvas. Required if creating a widget.\ncom.livecode.Widget|Optional|Contains syntax specific to widget building such as \"my width\" and \"the mouse position\".\ncom.livecode.Engine|Optional|Contains syntax for all extension building such as \"dispatch\" and \"log\".\ncom.livecode.stream|Default|\ncom.livecode.file|Default|\ncom.livecode.mathfoundation|Default|\ncom.livecode.array|Default|\ncom.livecode.list|Default|\ncom.livecode.arithmetic|Default|\ncom.livecode.binary|Default|\ncom.livecode.bitwise|Default|\ncom.livecode.byte|Default|\ncom.livecode.char|Default|\ncom.livecode.date|Default|\ncom.livecode.logic|Default|\ncom.livecode.math|Default|\ncom.livecode.sort|Default|\ncom.livecode.string|Default|\ncom.livecode.system|Default|\ncom.livecode.type|Default|\n\n> **Warning!** Module names are subject to change.\n\nThe new LiveCode dictionary has a full list of all available syntax as well as the module each belongs to. As a general rule we recommend importing all three optional module whenever developing widgets.\n\n```\nwidget community.livecode.beaumont.pinkCircle\n\nuse com.livecode.canvas\nuse com.livecode.widget\nuse com.livecode.engine\n\nmetadata title is \"My Pink Circle\"\nmetadata author is \"Benjamin Beaumont\"\nmetadata version is \"1.0.0\"\n\nend widget\n```\n\n\n### Core Handlers\n\nThere are three core handlers that any widget developer should implement:\n\nHandler|Description\n------|------\nonPaint|The *onPaint* message is sent to your widget whenever LiveCode requires it to redraw. The performance of you widget is tied primarily to this handler and should be kept as efficient as possible.\nonCreate|The *onCreate* message is sent to your widget when it is first created by LiveCode. This can be used to initialise default data and where applicable, reduce the burden for calculating constants etc in the onPaint handler.\nonGeometryChanged| The *onGeometryChanged* message is sent when the control is changed in size.\nonSave| The *onSave* message is sent when your widget is about to be destroyed and enables the widget to save data set on the widget.\nonLoad| The *onLoad* message is sent when your widget is created and enables the widget to retrieve data saved on the widget.\n\nFor the most basic example, only the onPaint() handler is required.\n\n```\nwidget community.livecode.beaumont.pinkCircle\n\nmetadata title is \"My Pink Circle\"\nmetadata author is \"Benjamin Beaumont\"\nmetadata version is \"1.0.0\"\n\npublic handler OnPaint()\n   // Draw widget\nend handler\n\nend widget\n```\n\n### Draw a Pink Circle\n\n```\nwidget community.livecode.beaumont.pinkCircle\n\nmetadata title is \"My Pink Circle\"\nmetadata author is \"Benjamin Beaumont\"\nmetadata version is \"1.0.0\"\n\nuse com.livecode.canvas\n\npublic handler OnPaint()\n   // Create a path with a radius of half the width of the canvas\n   // Set the paint to a solid pink color\n   // Fill the path\n   variable tCirclePath as Path\n   put circle path centered at point [my width / 2, my height / 2] with radius (my width/2) into tCirclePath\n   set the paint of this canvas to solid paint with color [1, 0, 1]\n   fill tCirclePath on this canvas\nend handler\n\nend widget\n```\n\n### Test the Code\n\n![enter image description here](images/extensions-widget-first.png)\n\n1. Notice that I'm using textWrangler\n2. Click test\n3. Your widget should be displayed on the new stack. If you can't see it, check behind the extension plugin.\n\n> Note: There is a colorising script for textWrangler here: https://github.com/runrev/livecode/tree/develop/contrib/TextWrangler. It should be placed in /Application Support/TextWrangler/Language Modules/\n\n\n### Properties\nIn order to make a widget useful to end users it is likely that you'll want to expose properties that allow them to specify how your widget should behave. \n\nTo specify a property you must provide a name and the method to get and set the property.\n```\nproperty <name> get <variable/handler> set <variable/handler>\n```\n\nThe simplest properties to get/set are numbers or strings. So lets create a circleMargin property that allows users to define a margin.\n\n```\nproperty circleMargin get mMargin set setMargin\n```\n\nIn the above example, when the ***circleMargin*** property is requested, the variable \"mMargin\" is returned, when set, the handler \"setMargin\" is called. To have LiveCode Builder handle the getting/setting of data, provide the variable name, to take full control over the getting/setting process define handlers. In our case we're taking a mixed approach.\n\n```\nprivate variable mMargin as real\n```\n\nWe'll define a member variable to store the value for the margin. LiveCode Builder is type so you must also specify the type of your variable. Remember, the canvas you are drawing to has subpixel precision so our margin can be a decimal number. As a result, we've chosen the specify our margin as a real number. For a full list of types available in LiveCode builder please see the [Typing](#Typing) section of the language specification guide below. We also suggest a nameing convension for variable in the section on [variable and case sensitivity](#Case-Sensitivity).\n\nWe also need to insatiate our circleMargin to a default value. We do this by adding an onCreate handler which is called when the widget is first created.\n\n```\npublic handler setMargin(in pMargin as real) as undefined\n\tput pMargin into mMargin\n\tredraw all\nend handler\n```\n\nFinally we have to implement our setMargin handler.\n```\npublic handler onCreate() \n\tput 0 into mMargin\nend handler\n```\n\nImplementing the \"setter\" ourselves provides us with a little more flexibility. In this case when the property is set we want our pink circle to immediately redraw to reflect the property change. We do this by calling \"redraw all\".\n\nTo test the property click \"test\" and from the message box set the property.\n\n```\nset the cicleMargin of widget 1 to 15\n```\n\n**Full Example**\n```\nwidget community.livecode.beaumont.pinkCircle\n\nmetadata title is \"My Pink Circle\"\nmetadata author is \"Benjamin Beaumont\"\nmetadata version is \"1.0.0\"\n\nuse com.livecode.canvas\nuse com.livecode.widget\nuse com.livecode.engine\n\n// Properties\nproperty circleMargin get mMargin set setMargin\n\n// Local variables\nprivate variable mMargin as real\n\npublic handler onCreate() \n\tput 0 into mMargin\nend handler\n\npublic handler OnPaint()\n   // Create a path with a radius of half the width of the canvas\n   // Set the paint to a solid pink color\n   // Fill the path\n   variable tCirclePath as Path\n   put circle path centered at point [my width / 2, my height / 2] with radius ((my width - mMargin)/2) into tCirclePath\n   set the paint of this canvas to solid paint with color [1, 0, 1]\n   fill tCirclePath on this canvas\nend handler\n\npublic handler setMargin(in pMargin as real) as undefined\n\tput pMargin into mMargin\n\tredraw all\nend handler\n\t\nend widget\n```\n\n### Loading and Saving widget data\nWhen you widget is created you are sent a *OnSave* message. It has the following structure and expects and array return type. You can fill this array with whatever widget data you have. LiveCode saves this data along with instances of the widget in the stack file.\n\n```\npublic handler OnSave(out rProperties as Array)\n\tput the empty array into rProperties\n\t\n\tput mMargin into rProperties[\"margin\"]\n\t\n\treturn rProperties\nend handler\n```\n\nThis same array will be returned to you when the widget is next opened.\n\n```\npublic handler OnLoad(in pProperties as Array)\n\tput pProperties[\"margin\"] into mMargin\nend handler\n```\n\n### Understanding Error Messages\nClicking on the \"test\" button causes the extension builder to compile your source code file (***.lcb***) and produce a compiled module file (***.lcm***). If an error is encountered it is output in the \"console\" section of the builder:\n\n```\nError: <source path>: <line number>: <char number>: <error message>\n```\n\n* *source path* - The path the .lcb file that is being compiled\n* *line number* - The line number in the script on which the error occurred.\n* *char number* - The character number on which the error occurred. \n* *error message* - The description of the error.\n\n### LiveCode Builder API\nTo start creating more complex widgets see the LiveCode Builder api in the documentation stack in the IDE.\n\n![enter image description here](images/extensions-canvas-docs.png)\n\n1. Open the dictionary\n2. API chooser\n3. Choose the \"LiveCode Builder\" API\n4. The list of all the syntax available\n\n### Creating Libraries\nA extension library is written in much the same way as the above widget. The only difference is that all the public handlers implemented are loaded into the engine on startup.\n\n### Loading and Creating Widgets Manually\nTo load a compiled library file call:\n\n```\nload extension <filepath.lcm>\n```\n\nTo create a widget from script call:\n\n```\ncreate widget <name> as <identifier>\n\ne.g.\n\ncreate widget \"myWidget\" as \"com.livecode.extensions.waddingham.clock\" \n```\n\n## Documenting Your Extension\n### Adding API Markup\nAny extension can include an API. To do so, either add a file called *api.lcdoc* to your widget folder alongside the other widget files or markup your source code inline.\n\nMarking up your scripts is simple and follows a similar model to other documentation formats.\n\nConsider the following handler\n```\npublic handler myHandler(in pString as String, in pNumber as Number)\n   # Code \nend handler\n```\n\nTo add an entry to the API for this handler, place a formatted comment above the handler definition:\n\n```\n/*\nsummary: Use this handler to do an action\npString: This parameter does x\npNumber: This parameter does y\ndescription:\n# Markdown Title\nHere is a full description in markdown for how this function works. Once again, any GitHub flavoured markdown is accepted.\n*/\npublic handler myHandler(in pString as String, in pNumber as Number)\n   # Code \nend handler\n```\n\nThe LiveCode API parser will combine the comment items with other data pulled directly from your handler definition such as name, type and some parameter details.\n\nFor a full list of acceptable documentation elements please see the documentation section in the specifications below.\n\n> **Important:** Documentation is only added to the LiveCode dictionary when a full extension package is installed. Currently, this is only possible through the extension manager / online extensions portal.\n\n### Adding a User Guide\nAny extension can include a user guide. To do so, add a markdown file called *guide.md* to your widget folder alongside the other widget files.\n\nAll GitHub flavoured markdown is accepted.\n\n# Packaging Extensions\nPackaging extensions is easy. Simply open the \"Widget Builder\" plugin:\n\n```\nDevelopment > Plugins > ExtensionBuilder\n```\n\nLoad your ***.lcb*** file and click \"Build Package\". A new file will appears in the same directory as your main file with the extension ***.lce***. This is your final package file ready for upload to the extensions portal.\n\n## Package requirements\nA valid package can be built from a minimum set of files:\n\n```\nwidget.lcb // Widget source file\nsupport/icon.png // 20x40 png image\nsupport/icon@extra-high.png // 40x80 png image\n```\n\n# Sharing Extensions\nOnce you've created a ***.lce*** package you are ready to upload it to the extensions portal.\n\n## 1) Login\nGo to http://ng.livecode.com/login/ and login. The user credentials are the same ones you use on the main LiveCode website or when activating a commercial LiveCode license.\n\n![enter image description here](images/extensions-site-login.png)\n\n## 2) Select a Developer ID\nIn order to ensure that every extension publisher has a unique ID we use a reverse domain name notation. You will be required to select a unique developer ID that will be associated with your account:\n\n```\ncommunity.livecode.<developer_name>\n```\n\nFor example:\n```\ncommunity.livecode.beaumont.pinkcircle.1.0.0\n```\n\nWhen logging in for the first time you will be asked to choose a unique *developer_name*. This is a one time step which will be added to your user account and used for all subsequent visits. \n\n![enter image description here](images/extensions-id.png)\n\n> **Note:** When uploading a package to the online portal it must have a matching identifier. So if you chose the developer name \"mickey\", it must start \"community.livecode.mickey\".\n\n> **Future:** We plan to add the ability to register your own domains in future. This will allow you to upload widgets with custom identifiers: \"com.beaumont.pinkcircle.1.0.0\".\n\n\n\n## 3) Add a New Extension\n\nOnce logged in you will be taken to your extensions account page:\n\n![enter image description here](images/extensions-site-account.png)\n\n1. To upload a new package click on the \"Add New Extension\" button\n2. A list of extensions you've previously uploaded are listed here. \n\n> Note: if you created a new version of an existing extension, follow the same upload steps. Your package will be recognised as a new version of the existing widget.\n\n## 4) Upload Your Package\n\n![enter image description here](images/extensions-site-upload.png)\n\n1. Click to browse to your package file.\n2. Drag your package file anywhere within the grey dashed box\n\n# Specifications\n## Documentation Markup\n\nDocumentation for a LiveCode API or documentation entry consists of a series of elements and their values, in the following form:\n\n*elementName* : *content*\n\nAn API for an extension is automatically added to the library dropdown menu in the dictionary.\n\nThere are several standard types of *content*; which one may be used depends on the *elementName*.\n\n### Element names\n\nElements are optional unless otherwise specified.\n\n#### Name (required)\nThe name of the API entry. The name must be a single word.\n>*Note:* For inline docs, the name element is automatically generated\n\n#### Synonyms\nA comma-delimited list of synonyms for this API entry.\n\n#### Type (required)\nThe type of this API entry. One of the following:\n(API-level)\n\t* command\n\t* function\n\t* property\n\t* message\n\t* constant\n\t* keyword\n\t* control structure\n\t* operator\n\t* statement\n\t* expression\n\t\n(Glossary-level)\n\t* library\n\t* widget\n\t* glossary\n\t* object\n\nThe glossary-level entries have part of their content generated from the API-level entries.\n\n>*Note:* For inline docs, the type element is automatically generated\n\n#### Syntax (required for API-level entries)\nA description of how to use or call this facet of the API. May just be the name itself, for keywords etc.\nAn entry may have a number of Syntax elements, if there are variations within the same entry.\n\n>*Note:* For inline docs, the Syntax elements are automatically generated\n\n#### Summary (required)\nA summary of the API entry being documented. The summary should be a single line. Anything more in-depth should be included in the description.\n\n#### Associated\nA comma-delimited list of names of other API or docs entries. Each one must be of type **object**, **glossary**, **library**, or **widget**. It is used to generate the docs for the entries to which it is associated.\n\nIn particular, every API entry in a library should have that library name in its Associated list.\n\n#### Introduced\nThe LiveCode version in which the API entry was first available.\n\n#### OS\nA comma-delimited list specifying which operating systems the API entry is available for. One or more of the following:\n\n* mac\n* windows\n* linux\n* iOS\n* android\n* RPi\n\n#### Platforms\nA comma-delimited list specifying which platforms the API entry is available for. One or more of the following:\n\n* desktop\n* server\n* web\n* mobile\n\n### Example\nExample elements should show how API entries are used in context. Each example with be displayed in the documentation viewer as a multiline code block. Where possible, an example should be entirely self contained, so that it is runnable as a block of code without any additions.\n\nAn API entry can have any number of Example elements. \n\n#### Parameters\nThe parameters element itself does not do anything, but can be helpful for readability as a precursor to the parameter elements themselves.\nParameter elements are specified in the following way:\n*paramName* (*paramType*) : *paramDescription*\n\nThe param type is optional, although may be helpful to include, and is required for further formatting of parameter descriptions to take place. The three types that will instigate further formatting are:\n\n* enum\n* set\n* array\n\nA parameter of **enum** type is one that expects one of a specified list of values. Similarly, a parameter of **set** type is one that expects a comma-delimited list of one or more of a specified list of values. After the param description of the **enum** or **set** type, these values should be listed in the following way\n```\n\t- value1 : description of value1\n\t- value2 : description of value2\n\t- ...\n```\netc.\n\nAfter the description parameter of **array** type, the format of the array may optionally be specified in the following way:\n\n```\n{ \n\tkey1 (keyType) : description of key1\n\tvalue1 (valueType) : description of value1\n\tkey2 (keyType) : description of key2\n\tvalue2 (valueType) : description of value2\n\t...\n}\n```\nThe key type and value type are optional. If one of the values is a sub-array, and the **array** type is specified, then the array specification may be nested as follows:\n\n```\n{ \n\tkey1 (keyType) : description of key1\n\tvalue1 (array) : description of value1\n\t{\n\t\tkey2 (keyType) : description of key2\n\t\tvalue2 (valueType) : description of value2\n\t\t...\n\t}\n\t...\n}\n```\nThe indentation is not necessary, but is helpful for readability.\n\n#### Value and return parameters\nFor simple return parameters, i.e. the direct return value of a function, use the Returns element.\nWhen a value is both an input and output value, for example the value of a property, use the Value element.\nThe Returns and Value elements are mutually exclusive.\n\nSome functions and commands in LiveCode change the value of 'the result' and the 'it' variable. In these cases there are also special return parameter elements It and The result.\n\nAll of these elements can have a type specified in brackets before the colon, as for parameter elements. The same comments about formatting apply to return parameters.\n\n#### Description (required)\nA full description of the API entry. The description may have markdown elements which will be rendered in the documentation viewer.\n\n### References\nA comma-delimited list of other API or docs entries that are referenced. The references element is essential for linking around the documentation viewer.\n\nThe references list should be in the form:\n>*entryName* (*entryType*), *entryName* (*entryType*), *entryName* (*entryType*), ...\n\n#### Tags\nA comma-delimited list of tags for this entry. The documentation viewer can filter entries by tag.\n\n### Other documentation syntax\nThe Description element is the only one that allows standard markdown. There is only (essentially) one other syntactic form allowed in API documentation, which is enclosing text in angle brackets <>. There are three purposes of the angle brackets syntax:\n\n* Specifying occurrences of the name of the current API entry.\n* Specifying occurrences of the names of parameters.\n* Specifying links to other API entries or documentation.\n\nIn the first two cases, applying the syntax merely consists in enclosing the relevant occurrences in angle brackets, eg to reference a parameter *pParam* in the entry named *thisEntry*,\n>This is a sentence in which &lt;pParam&gt; ought to be marked as being a parameter in the API entry for &lt;thisEntry&gt;\n\nTo specify a link to another API or docs entry, the latter **must** be included in the References element. If there is only one item in the References element with a matching name, then it suffices to enclose the referencing text in angle brackets.\n>This will link correctly to the &lt;other&gt; function's API entry provided the References element contains only one item with the name \"other\".\n\nIf the referencing text is different from the name of the entry, such as if it is pluralised or possessive, include the referenced entry name as a label inside the angle brackets.\n> This will also link correctly to &lt;other|other's&gt; API entry, but display as \"other's\" in the documentation viewer.\n\nIf the target name is shared by two references, then the link should be disambiguated by including the type in brackets:\n> We might want to link to the &lt;other(function)&gt; function and the &lt;other(command)&gt; command in the same entry, if the references contain \"other (function)\" and \"other (command)\".\n\nIt is possible to do both of the above at the same time:\n> This sentence contains links to &lt;other(function)|other's&gt; and &lt;other(command)|other's&gt; dictionary entries.\n\n### Separate docs files\nTo specify the documentation for a library in one separate file, it must have the following structure:\n\nLibrary: *libraryName*\n\nSummary: *librarySummary*\n\nDescription:\n*libraryDescription*\n\nName: *entryName*\n\nType: *entryType*\n\nSyntax: *entrySyntax*\n\nSummary: *entrySummary*\n\n...other elements associated with *entryName*...\n\nName: *anotherEntryName*\netc.\n\n### Inline documentation\nDocumentation for LiveCode script and LiveCode extensions can be done in-line. In this case, the Name, Type, Syntax and Associated elements are auto-generated. \n\nThe code-block enclosed in /* */ immediately preceding the handler or syntax definition is used for the other elements of the documentation for that entry. In LiveCode extensions, the types of parameters are also pulled from the associated handler.\n\n### Separate docs files examples\n\n#### Dictionary example\nHere is the dictionary document for the *textEncode* function:\n\n```\nName: textEncode\n\nType: function\n\nSyntax: textEncode(<stringToEncode>, <encoding>)\n\nSummary: Converts from text to binary data.\n\nIntroduced: 7.0\n\nOS: mac,windows,linux,ios,android\n\nPlatforms: desktop,server,web,mobile\n\nExample:\ntextEncode(\"A\",\"UTF16\")\n\nExample:\nput textEncode(field \"output\",\"UTF-8\") into tOutput\nput tOutput into url (\"file:output.txt\")\n\nParameters:\nstringToEncode (string): Any string, or expression that evaluates to a string.\nencoding (enum): the encoding to be used\n- \"ASCII\"\n- \"ISO-8859-1\": Linux only\n- \"MacRoman\": OS X only\n- \"Native\": ISO-8859-1 on Minux, MacRoman on OS X, CP1252 on Windows\n- \"UTF-16\"\n- \"UTF-16BE\"\n- \"UTF-16LE\"\n- \"UTF-32\"\n- \"UTF-32BE\"\n- \"UTF-32LE\"\n- \"UTF-8\"\n- \"CP1252\"\n\nReturns: Returns the <stringToEncode> as binary data.\n\nDescription:\nConverts from text to binary data.\n\nThe <textEncode> function takes text, and returns it as binary data, encoded with the specified encoding.\n\nIt is highly recommended that any time you interface with things outside LiveCode (files, network sockets, processes, etc) that you explicitly textEncode any text you send outside LiveCode and <textDecode> all text received into LiveCode. If this doesn't happen, a platform-dependent encoding will be used (which normally does not support Unicode text).\n\nIt is not, in general, possible to reliably auto-detect text encodings so please check the documentation for the programme you are communicating with to find out what it expects. If in doubt, try UTF-8.\n\nReferences: textDecode.function\n```\n\n#### Library example\n\n```\nModule: com.livecode.sort\n\nType: library\n\nDescription: This library consists of the sorting operations provided by the standard library of LiveCode Builder\n\n\nName: SortListDescendingText\n\nType: statement\n\nSyntax: sort <Target> in descending [text] order\n\n\nSummary: Sorts <Target> in descending text order.\nParameters:\nTarget (inout list): An expression that evaluates to a list of strings. \nExample:     \n\tvariable tTestList as List\n    put the empty list into tTestList\n\n    push \"abcd\" onto tTestList\n    push 1 onto tTestList\n    push \"xyz\" onto tTestList\n    push 2 onto tTestList\n\n    sort tTestList in descending order -- tTestList is [\"xyz\", \"abcd\", 1, 2]\n\n\nDescription: Text sort is performed by comparing string elements on a codepoint by codepoint basis. Non-string elements come after all string elements in the sort order. The sort is stable, so that non-string elements are not re-ordered relative to each other.\n\n\nTags: Sorting\n\nName: SortListAscendingText\n\nType: statement\n\nSyntax: sort <Target> in ascending [text] order\n```\n### Inline examples\n\nIn general, writing inline docs has fewer requirements since several of the elements are auto-generated.\n\n#### LiveCode Builder syntax example\n\n```\n/*  \nThis library consists of the operations on lists included in the standard library of LiveCode Builder.\n*/\n\nmodule com.livecode.list\n\n/*\nSummary:        Returns the first element of <Target>.\nTarget:         An expression which evaluates to a list.\noutput:\t\t\tThe first element of <Target>\n\nExample:\n\tvariable tVar as List\n\tput the empty list into tVar\n\tpush \"first element\" onto tVar\n\t\n\tvariable tResult as Boolean\n\tif the head of tVar is \"first element\" then\n\t\tput \"success\" into tResult\n\tend if\n\t\nDescription:\nReturns the first element of the list <Target> without modifying <Target>.\n\\`\\`\\`\tthe head of tVar\\`\\`\\`\nis equivalent to using the <IndexedElementOfList> operator with index -1,\n\\`\\`\\`\ttVar[1]\\`\\`\\`\n\t\nReferences: IndexedElementOfList(operator)\n\nTags: Lists\n*/\n\nsyntax HeadOfList is prefix operator with precedence 1\n    \"the\" \"head\" \"of\" <Target: Expression>\nbegin\n    MCListEvalHeadOf(Target, output)\nend syntax\n\nend module\n```\n\n#### LiveCode Builder handler example\n```\n/*\nSummary: Logs the result of a test to the <xResults> list\n\nParameters:\npModule: The name of the module this test comes from.\npTest: The name of the test.\npResult: The result of the test\nxResults: The ongoing list of test results\n\nDescription:\nPushes either the string \"SUCCESS : <pModule>_<pTest>\" or the string \"FAILURE : <pModule>_<pTest>\" onto the results list,\ndepending on the value of <pResult>\n\n*/\n\npublic handler testLog(in pModule as String, in pTest as String, in pResult as Boolean, inout xResults as List)\n    variable tStringResult as String\n    if pResult then\n        put \"SUCCESS\" into tStringResult\n    else\n        put \"FAILURE\" into tStringResult\n    end if\n\n    push tStringResult && \":\" && pModule & \"_\" & pTest onto xResults\nend handler\n```\n#### LiveCode script handler example\n```\n/*\nSummary: Extracts the inline docs from a .lcb file\n\npFile: The path to the .lcb file to extract docs from\n\nReturns (string): A string consisting of all the docs for the library, and the syntax and handlers present in the .lcb file\n\nDescription:\n<revDocsGenerateDocsFileFromModularFile> is used when packaging a widget to create its API documentation.\nIt generates the Library and Type elements from the declaration in the <pFile> (either widget or library), and extracts\nthe comment block that precedes any initial declaration for use as the library-level Description element.\nIt then extracts the comment blocks that precede syntax and handler definitions in <pFile>, and generates the \nName, Type, Syntax, and Associated elements for each entry, as well as the parameter types.\n\nTags: Package building\n*/\n\nfunction revDocsGenerateDocsFileFromModularFile pFile\n...\nend revDocsGenerateDocsFileFromModularFile\n```\n\n## IDE Changes\n\n### Property Inspector\n\nThe property inspector has been rewritten to allow properties of widgets to be inspected and edited. It has been implemented with flexibility and extensibility in mind, since it must be able to control the values of widget properties in any way required by the widget developer. Each property now has a number of attributes which affect how it appears in the inspector.\n\n#### Property Attributes\n\nThe following is the list of property attributes:\n\n##### default\nThe default value of the property. If there is no default value (for example the 'loc' property does not have one), the string \"no_default\" can be used. The property inspector pops up a contextual menu when editors are right-clicked allowing the user to set the property back to a default value.\n\n##### editor\nThe editor that will be used to display the value of the property and allow it to be edited. See the dedicated section below for details on property inspector editors. \n\n##### group\nProperties are grouped by themselves in the inspector by default. If a particular group name is specified for a set of properties, their editors are placed next to each other in the inspector.\n\n##### label\nThe label to use for this property.\n\n##### options\nFor properties whose value is a choice from a set of options, that set should be specified as a comma delimited list for the options attribute. Default editors are provided for 'enum' type properties (choice of exactly one from a set) and 'set' type properties (choice of zero or more from a set). \n\nLists of options can be generated using LiveCode Script for the inspector at run-time, by using the 'execute' syntax - for example the options for the textFont property are generated using\n`execute: get the fontNames; sort it`\nWhatever remains in the 'it' variable after executing the specified script is used as the list of options.\n\n##### section\nThe section attribute controls which tab of the property inspector contains the property in question. Currently this is required to be one of the following\n* Basic\n* Data Grid \n* Custom \n* Table \n* Colors \n* Effects\n* Icons\n* Position\n* Text\n\nBut in the future it may be possible to specify custom sections.\n\n##### user_visible\nProperties are visible in the property inspector by default. Set the user_visible attribute to false to hide a given property from the user.\n\n### read_only\nRead only properties will be displayed in the property inspector but the corresponding editor will have its \"editorEnabled\" property set to false. See the Editors section below for more details on enabled/disabled editors.\n\n#### Widget Properties\n\nWidget metadata is used to control the display of widget properties in the inspector. Items of metadata which determine property attributes are of the form:\n\nmetadata <property>.<attribute> is \"<value>\"\n\nThese are stored as property data for the widget at load time. The <attribute> can be any of those specified in the Property Attributes section above. If the attributes are not specified, their values are as follows:\n* default - \"no_default\"\n* editor - \"com.livecode.pi.number\" for Integer/Real properties, \"com.livecode.pi.<type>\" for properties of type <type>.\n* group - the name of the property\n* label - the name of the property\n* options - empty\n* section - \"Basic\"\n* user_visible - true\n* read_only - true if there is no specified 'set' handler or variable for the property, false otherwise.\n\n#### Script Object Properties\nScript-level properties of objects (including widgets) are specified in files in the Toolset/resources/supporting_files/property_definitions folder. The propertyInfo.txt file specifies the default values for all the property attributes. Each object type then has a specification of which properties should be displayed in the inspector when it is the selected object, and any options/default/group values which override the defaults.\n\n#### Editors\n\nCurrently an editor must be a stack consisting of a group named \"template\" and a button named \"behavior\". The property inspector looks up the specified editor for a given property, clones the template group, and sets its behavior to the long id of the button. \n\nThe behavior script must at a minimum implement the following three handlers:\n\non editorInitialize\non editorUpdate\non editorResize\n\nThere are a number of properties available to any editor:\n* editorMinWidth\n* editorMaxWidth\n* editorEnabled\n* editorEffective\n* editorValue\n\nThese should be set or got appropriately. For example, if an editor consists of a text field, the editorUpdate handler should update the value of the field with 'the editorValue of me'. Similarly, if the content of the field changes, the field should call a function in the behavior which sets 'the editorValue of me' to the content of the field.\n\nThe editorEnabled and editorEffective properties are set by the generic behavior depending on the property info and the values of the properties. The editorEffective is true if the value of the property in question is empty but there is an effective value in play. The editor should alter the display of its value accordingly.\n\nEditors can specify their min and max width if required.\n\nThe following editors are built-in, and available to use for widget properties with common types:\n\n* com.livecode.pi.array - a Tree View widget\n* com.livecode.pi.boolean - a check box\n* com.livecode.pi.color - a color swatch and dialog\n* com.livecode.pi.colorwithalpha - a color swatch and dialog, and alpha value slider\n* com.livecode.pi.enum - an option menu\n* com.livecode.pi.file - a file selector\n* com.livecode.pi.number - a single-line field with increment/decrement twiddle\n* com.livecode.pi.pattern - a pattern selector\n* com.livecode.pi.set - a field with multi-select list behavior\n* com.livecode.pi.string - a single-line field\n* com.livecode.pi.text - a multi-line field\n\nThere are also some bespoke editors for particular object properties:\n\n* com.livecode.pi.customprops\n* com.livecode.pi.datagrid \n* com.livecode.pi.textalign\n* com.livecode.pi.textstyle\n\nIt is our intention that ultimately a widget alone will be able to function as a property editor, however currently this feature is not available.\n\n## Livecode Builder Language Guide\n\n### Overview\n\nLiveCode Builder is a variant of the current LiveCode scripting language (LiveCode Script) which has been designed for 'systems' building. It is statically compiled with optional static typing and direct foreign code interconnect (allowing easy access to APIs written in other languages).\n\nUnlike most languages, LiveCode Builder has been designed around the idea of extensible syntax. Indeed, the core language is very small - comprising declarations and control structures - with the majority of the language syntax and functionality being defined in modules.\n\n> **Note:** It is an eventual aim that control structures will also be extensible, however this is not the case in the current incarnation).\n\nThe syntax will be familiar to anyone familiar with LiveCode Script, however LiveCode Builder is a great deal more strict - the reason being it is intended that it will eventually be compilable to machine code with the performance and efficiency you'd expect from any 'traditional' programming language. Indeed, over time we hope to move the majority of implementation of the whole LiveCode system over to being written in LiveCode Builder.\n\n> **Note:** One of the principal differences is that type conversion is strict - there is no automatic conversion between different types such as between number and string. Such conversion must be explicitly specified using syntax (currently this is using things like *... parsed as number* and *... formatted as string*.\n\n### Tokens\n\nThe structure of tokens is similar to LiveCode Script, but again a little stricter. The regular expressions describing the tokens are as follows:\n\n - **Identifier**: [A-Za-z_][A-Za-z0-9_.]*\n - **Integer**: [0-9]+\n - **Real**: [0-9]+\".\"[0-9]+([eE][-+]?[0-9]+)?\n - **String**: \"[^\\n\\r\"]*\"\n - **Separator**: Any whitespace containing at least one newline\n\n> **Note:** The presence of '.' in identifiers are used as a namespace scope delimiter.\n\n> **Note:** Eventually strings will use '\\' as an escaping character allowing things such as \\n for newline and \\q for quote.\n\n#### Case-Sensitivity\n\nAt the moment, due to the nature of the parser being used, identifiers and keywords are all case-sensitive and keywords are reserved. The result of this is that, using all lower-case identifiers for names of definitions should be avoided.\n\n> **Aside:** The current parser and syntax rules for LiveCode Builder are constructed at build-time of the LiveCode Builder compiler and uses *bison* (a standard parser generator tool) to build the parser. Unfortunately, this means that any keywords have to be reserved as the parser cannot distinguish the use of an identifier in context (whether it is a keyword at a particular point, or a name of a definition).\n\nIt is highly recommended that the following naming conventions be used for identifiers:\n\n - **tVar** - for local variables\n - **pVar** - for in parameterns\n - **rVar** - for out parameters\n - **xVar** - for inout parameters\n - **mVar** - for global variables in widgets\n - **sVar** - for global variables in libraries\n - **kConstant** - for constants\n - Use identifiers starting with an uppercase letter for handler and type names.\n\nBy following this convention, there will not be any ambiguity between identifiers and keywords. (All keywords are all lower-case).\n\n> **Note:** The intent is that LiveCode Builder scripts will be case-insensitive like LiveCode Script; however this will require the Open Language parser infrastructure which is being developed for the next major version of LiveCode Builder.\n\n### Typing\n\nLiveCode Builder is a typed language, although typing is completely optional in most places (the only exception being in foreign handler declarations). If a type annotation is not specified it is simply taken to be the most general type *optional any* (meaning any value, including undefined).\n\nThe range of core types is relatively small, comprising the following:\n\n - **undefined**: the single value *undefined*\n - **boolean**: one of *true* or *false*\n - **integer**: any integral numeric value (size limitations apply)\n - **real**: any numeric value (size and accuracy limitations apply)\n - **number**: any integer or real value\n - **string**: a sequence of UTF-16 code units\n - **data**: a sequence of bytes\n - **list**: a sequence of any values\n - **array**: a mapping from strings to values\n - **any**: a value of any type\n\nAdditionally, all types can be annotated with **optional**. An optional annotation means the value may be the original type or the undefined value.\n\n> **Note:** As it stands *any* does not include the undefined type and so *optional any* makes sense. There is an argument, however, that *any* should be implicitly optional as (technically) the undefined type is also a type. It is possible this aspect might be revised.\n\n> **Note:** The current compiler does not do type-checking; all type-checking happens at runtime. However, this is being worked on so there will soon be a compiler which will give you type errors at compile-time.\n\n### Modules\n\n    Module\n        : 'module' <Name: Identifier> SEPARATOR\n            { Metadata SEPARATOR }\n            { Import SEPARATOR }\n            { Definition SEPARATOR }\n          'end' 'module'\n\nThe smallest compilable unit of LiveCode Builder is the module. Each module is uniquely named using reverse DNS notation, and the names of modules are considered to live in a global namespace.\n\nA module is a collection of public and private definitions, including constants, variables, types and handlers.\n\nA module may depend on another module through import. An imported modules public definitions become accessible to the importing module.\n\n> **Note:** For integration with the existing LiveCode system, there are two module variants which may be used. Widgets (use 'widget' instead of 'module') and Libraries (use 'library' instead of 'module'). A widget appears in LiveCode as a control, whilst a library adds all its public handlers to the bottom of the message path.\n\n### Metadata\n\n    Metadata\n        : 'metadata' <Name: Identifier> 'is' <Value: String>\n\nThe metadata clauses allow a set of key-values to be encoded in the compiled module. These are not used in compilation or execution, but may be used by the system loading and using the module.\n\nAt the moment, the following keys are understood:\n\n - title: a human-readable name for the module\n - description: a simple description of the module's purpose\n - version: a string in the form X.Y.Z (with X, Y and Z integers) describing the modules version\n - author: the name of the author of the module\n\n> **Note:** The current metadata mechanism is unlikely to remain part of the language. It is intended that it will be replaced by a package description file, which will allow modules to be grouped together with other resources.\n\n### Imports\n\n    Import\n        : 'use' <Name: Identifier>\n\nThe use clauses allow a module to refer to another module by importing all the target module's public definitions into its namespace.\n\nThe name of the module specified must be its full name, e.g. com.livecode.canvas.\n\nA module may use any other module, as long as doing so does not cause a cycle in the dependency graph.\n\n> **Note:** The current IDE and extension installation system does not yet implement arbitrary dependencies - the only dependencies it understands are those which are builtin to the system (e.g. com.livecode.canvas). However, you can still write and test out modules with dependencies locally - they just cannot be uploaded to the extensions portal.\n\n## Definitions\n\n    Definition\n      : ( 'public' | 'private' ) ConstantDefinition\n      | ( 'public' | 'private' ) TypeDefinition\n      | ( 'public' | 'private' ) VariableDefinition\n      | ( 'public' | 'private' ) HandlerDefinition\n      | ( 'public' | 'private' ) ForeignHandlerDefinition\n      | PropertyDefinition\n      | EventDefinition\n\nDefinitions are what are used to define usable entities in the language. All definitions are named using a unique identifier (so you cannot have two definitions with the same name).\n\nDefinitions can be either *public* or *private* (the default is private - so there is no need to explicitly specify that). Public definitions are available when the module is used by another module whereas private definitions can only be used within the module.\n\n> **Note**: Properties and events are, by their nature, always public as they define things which only make sense to access from outside.\n\n> **Note**: When writing a library module, all public handlers are added to bottom of the message path in LiveCode Script.\n\n#### Constants\n\n    ConstantDefinition\n      : 'constant' <Name: Identifier> is <Value: Expression>\n\nA constant definition defines a named constant. The value can be any expression which depends on only on constant values to evaluate.\n\n> **Note:** Constants are not currently implemented, although the syntax is recognised.\n\n#### Types\n\n    TypeDefinition\n      : 'type' <Name: Identifier> 'is' <TypeOf: Type>\n\nA type definition defines an alias, it names the given type with the given Name, allowing the name to be used instead of the type.\n\n    Type\n      : <Name: Identifier>\n      | 'optional' <Target: Type>\n      | 'any'\n      | 'boolean'\n      | 'integer'\n      | 'real'\n      | 'number'\n      | 'string'\n      | 'data'\n      | 'array'\n      | 'list'\n      | 'undefined'\n      | 'pointer'\n\nA type clause describes the kind of value which can be used in a variable or parameter.\n\nIf a type is an identifier, then this is taken to be a named type defined in a type definition clause.\n\nAn optional type means the value can be either the specified type or undefined.\n\nThe remaining types are as follows:\n\n - **any**: any value\n - **boolean**: a boolean value, either the value *true* or *false*.\n - **integer**: any integer number value\n - **real**: any real number value\n - **number**: any number value\n - **string**: a sequence of UTF-16 code units\n - **data**: a sequence of bytes\n - **array**: a map from string to any value (i.e. an associative array, just like in LiveCode Script)\n - **list**: a sequence of any value\n - **undefined**: a single value *undefined* (this is used to describe handlers with no return value - i.e. void)\n - **pointer**: a low-level pointer (this is used with foreign code interconnect and shouldn't be generally used).\n\n> **Note:** *integer* and *real* are currently the same as *number*.\n\n> **Note:** In a subsequent update you will be able to specify lists and arrays of fixed types. For example, *list of string*.\n\n> **Note:** In a subsequence update you will be able to define record types (named collections of values - like structs in C) and handler types (allowing dynamic handler calls through a variable - like function pointers in C).\n\n#### Variables\n\n    VariableDefinition\n      : 'variable' <Name: Identifier> [ 'as' <TypeOf: Type> ]\n\nA variable definition defines a module-scope variable. In a widget module, such variables are per-widget (i.e. instance variables). In a library module, there is only a single instance (i.e. a private global variable).\n\nThe type specification for the variable is optional, if it is not specified the type of the variable is *optional any* meaning that it can hold any value, including being undefined.\n\n#### Handlers\n\n    HandlerDefinition\n      : 'handler' <Name: Identifier> '(' [ ParameterList ] ')' [ 'as' <ReturnType: Type> ] SEPARATOR\n          { Statement }\n        'end' 'handler'\n\nHandler definitions are used to define functions which can be called from LiveCode Builder code, invoked as a result of events triggering in a widget module, or called from LiveCode Script if public and inside a library module.\n\nThere is no distinction between handlers which return a value and ones which do not, apart from the return type. Handlers can be called either in expression context, or in statement context. If a handler which returns no value (its return type is *undefined*) is called in expression context then its value is *undefined*.\n\n\tParameterList\n\t  : { Parameter , ',' }\n\n    Parameter\n      : ( 'in' | 'out' | 'inout' ) <Name: Identifier> [ 'as' <ParamType: Type>\n\nThe parameter list describes the parameters which can be passed to the handler. Handlers must be called with the correct number of parameters, using expressions which are appropriate to the mode.\n\nAn in parameter means that the value from the caller is copied to the parameter variable in the callee handler.\n\nAn out parameter means that no value is copied from the caller (the parameter variable in the callee handler starts as *undefined*), and the value on exit of the callee handler is copied back to the caller on return.\n\n> **Note:** It is a checked runtime error to return from a handler without ensuring all non-optional 'out' parameters have been assigned a value.\n\nAn inout parameter means that the value from the caller is coped to the parameter variable in the callee handler on entry, and copied back out again on exit.\n\nThe type of parameter is optional, if no type is specified it is taken to be *optional any* meaning it can be of any type.\n\n> **Note:** Only assignable expressions can be passed as arguments to inout or out parameters. It is a checked compile-time error to pass a non-assignable expression to such a parameter.\n\n#### Foreign Handlers\n\n    ForeignHandlerDefinition\n      : 'foreign' 'handler' <Name: Identifier> '(' [ ParameterList ] ')' [ 'as' <ReturnType: Type> ] 'binds' 'to' <Binding: String>\n\n    ForeignType\n      : Type\n      | 'bool'\n      | 'int'\n      | 'uint'\n      | 'float'\n      | 'double'\n\nA foreign handler definition binds an identifier to a handler defined in foreign code.\n\nForeign handler definitions can contain more types in their parameters than elsewhere - those specified in the ForeignType clause. These allow low-level types to be specified making it easier to interoperate.\n\nForeign types map to high-level types as follows:\n\n - bool maps to boolean\n - int and uint map to integer (number)\n - float and double map to real (number)\n\nThis mapping means that a foreign handler with a bool parameter say, will accept a boolean from LiveCode Builder code when called.\n\nAt present, only C binding is allowed and follow these rules:\n\n - any type passes an MCValueRef\n - boolean type passes an MCBooleanRef\n - integer type passes an MCNumberRef\n - real type passes an MCNumberRef\n - number type passes an MCNumberRef\n - string type passes an MCStringRef\n - data type passes an MCDataRef\n - array type passes an MCArrayRef\n - list type passes an MCProperListRef\n - undefined type passes an MCNullRef\n - pointer type passes a void *\n - bool type passes a bool (i.e. an int - pre-C99).\n - int type passes an int\n - uint type passes an unsigned int\n - float type passes a float\n - double type passes a double\n\nModes map as follows:\n\n - in mode is just pass by value\n - out mode passes a pointer to a variable of one of the above types, the variable is uninitialized on entry\n - inout mode passes a pointer to a variable of one of the above types, the variable is initialized to a value on entry\n\nIf the return type is of a Ref type, then it must be a copy.\n\nIf an out parameter is of a Ref type, then it must be a copy (on exit)\n\nIf an inout parameter is of a Ref type, then its existing value must be released, and replaced by a copy (on exit).\n \nThe binding string for foreign handlers has the following form:\n\n    [lang:][library>][class.]function[!calling]\n\nHere *lang* specifies the language (must be 'c' at the moment)\n\nHere *library* specifies the name of the library to bind to (if no library is specified a symbol from the engine executable is assumed).\n\nHere *class* is currently unused.\n\nHere *function* specifies the name of the function symbol to bind to (on Windows, the symbol must be unadorned, and so exported from the library by listing it in a DEF module).\n\nHere *calling* specifies the calling convention which can be one of:\n\n - default\n - stdcall\n - thiscall\n - fastcall\n - cdecl\n - pascal\n - register\n\nAll but 'default' are Win32-only, and on Win32 'default' maps to 'cdecl'. If a Win32-only calling convention is specified on a non-Windows platform then it is taken to be 'default'.\n\nForeign handler's bound symbols are resolved on first use and an error is thrown if the symbol cannot be found.\n\n> **Note:** The current foreign handler definition is an initial version, mainly existing to allow binding to implementation of the syntax present in the standard language modules. It will be expanded and improved in a subsequent version to make it very easy to import and use functions (and types) from other languages including Objective-C (on Mac and iOS) and Java (on Android).\n\n#### Properties\n\n    PropertyDefinition\n      : 'property' <Name: Identifier> 'get' <Getter: Identifier> [ 'set' <Setter: Identifier> ]\n\nProperty definitions can only appear in widget modules. They define a property which can be accessed from LiveCode Script in the usual way (e.g. *the myProperty of widget 1*).\n\nBoth getter and setter clauses can use either a variable or handler identifier. If a variable identifier is used, then the property value is fetched (and stored) from that variable. If a handler identifier is used then a handler is called instead.\n\nA getter handler must take no arguments and return a value. A setter handler must take a single argument and return no value.\n\nThe set clause is optional. If it is not present then the property is read-only.\n\n#### Events\n\n    EventDefinition\n      : 'event' <Name: Identifier> '(' [ ParameterList ] ')' [ 'as' <ReturnType: Type> ]\n\nEvent definitions define a callable handler which calls back to the environment.\n\n> **Note**: Whilst events can be defined they currently cannot be used. To send a message to the LiveCode Script environment use the *dispatch* command which allows sending messages to arbitrary LiveCode Script objects.\n\n### Statements\n\n    Statement\n      : VariableStatement\n      | IfStatement\n      | RepeatStatement\n      | ThrowStatement\n      | ReturnStatement\n      | PutStatement\n      | SetStatement\n      | GetStatement\n      | CallStatement\n\nThere are a number of built-in statements which define control flow, variables, and basic variable transfer. The remaining syntax for statement is defined in auxiliary modules.\n\n#### Variable Statements\n\n    VariableStatement\n      : 'variable' <Name: Identifier> [ 'as' <TypeOf: Type> ]\n      \nA variable statement defines a handler-scope variable. Such variables can be used after the variable statement, but not before.\n\n> **Note:** Variables are currently not block-scoped, they are defined from the point of declaration to the end of the handler - this might change in a subsequent revision.\n\nVariables are initially undefined, and if of non-optional type, must be assigned a value before they can be used.\n\n> **Note:** It is a checked runtime error to attempt to use a non-optionally typed variable before it has a value.\n\nThe type specification for the variable is optional, if it is not specified the type of the variable is *optional any* meaning that it can hold any value, including being undefined.\n\n#### If Statements\n\n    IfStatement\n      : 'if' <Condition: Expression> 'then' SEPARATOR\n          { Statement }\n        [ { 'else' 'if' <Condition: Expression> 'then' SEPARATOR\n            { Statement } ]\n        [ 'else' SEPARATOR\n            { Statement } ]\n        'end' 'if'\n\nThe if statement enables conditional execution based on the result of an expression which evaluates to a boolean.\n\n> **Note:** It is a checked runtime error to use an expression which does not evaluate to a boolean in any condition expression.\n\n#### Repeat Statements\n\n    RepeatStatement\n      : RepeatHeader SEPARATOR\n          { Statement }\n        'end' 'repeat'\n      | 'next' 'repeat'\n      | 'exit' 'repeat'\n\n    RepeatHeader\n      : 'repeat' 'forever'\n      | 'repeat' <Count: Expression> 'times'\n      | 'repeat' 'while' <Condition: Expression>\n      | 'repeat' 'until' <Condition: Expression>\n      | 'repeat' 'with' <Counter: Identifier> 'from' <Start: Expression> ( 'up' | 'down' ) 'to' <Finish: Expression> [ 'by' <Step: Expression> ]\n      | 'repeat' 'for' 'each' <Iterator> 'in' <Container: Expression>\n\nThe repeat statements allow iterative execute of a sequence of statements.\n\nThe **repeat forever** form repeats the body continually. To exit the loop, either an error must be thrown, or **exit repeat** must be executed.\n\nThe **repeat times** form repeats the body Count number times. If Count evaluates to a negative integer, it is taken to be zero.\n\n> **Note:** It is a checked runtime error to use an expression not evaluating to a number as the Count.\n\nThe **repeat while** form repeats the body until the Condition expression evaluates to false.\n\n> **Note:** It is a checked runtime error to use an expression not evaluating to a boolean as the Condition.\n\nThe **repeat until** form repeats the body until the Condition expression evaluates to true.\n\n> **Note:** It is a checked runtime error to use an expression not evaluating to a boolean as the Condition.\n\nThe **repeat with** form repeats the body until the Counter variable reaches or crosses (depending on iteration direction) the value of the Finish expression. The counter variable is adjusted by the value of the Step expression on each iteration. The start, finish and step expressions are evaluated before the loop starts and are not re-evaluated. The Counter variable must be declared before the repeat statement.\n\n> **Note:** It is a checked runtime error to use expressions not evaluating to a number as Start, Finish or Step.\n\nThe **repeat for each** form evaluates the Container expression, and then iterates through it in a custom manner depending on the Iterator syntax. For example:\n\n    repeat for each char tChar in \"abcdef\"\n      -- do something with tChar\n    end repeat\n\nThe **next repeat** statement terminates the current iteration of the enclosing loop and starts the next iteration of the loop, or exits if currently on the last iteration.\n\nThe **exit repeat** statement terminates the current iteration of the enclosing loop, continuing execution at the statement after the enclosing loop's **end repeat**.\n\n#### Throw Statements\n\n    ThrowStatement\n      : 'throw' <Error: Expression>\n\nThe **throw** statement causes an error to be raised. This causes execution to terminate, and the error is passed back to environment.\n\nThe Error expression must be an expression that evaluates to a string.\n\n> **Note:** There is currently no try / catch mechanism in LiveCode Builder, so throwing an error will cause the error to be raised in LiveCode Script in the appropriate context.\n\n### Return Statements\n\n    ReturnStatement\n      : 'return' [ <Value: Expression> ]\n\nThe **return** statement causes execution of the current handler to end, and control return to the caller.\n\nIf a Value expression is specified, it is evaluated and returned as the result of the handler call.\n\n> **Note:** It is a checked runtime error for a value returned from a handler to not match the return type of the handler it is in.\n\n#### Transfer Statements\n\n    PutStatement\n      : 'put' <Value: Expression> into <Target: Expression>\n    \n    SetStatement\n      : 'set' <Target: Expression> 'to' <Value: Expression>\n\nThe **put** and **set** statements evaluate the Value expression and assign the resulting value to the Target expression.\n\nThe target expression must be assignable.\n\n> **Note:** It is a checked runtime error for the source value's type to not be compatible with the target expression's type.\n\n    GetStatement\n      : 'get' <Value: Expression>\n\nThe **get** statement evaluates the Value expression and returns it as the result of the statement. The value is subsequently available by using **the result** expression.\n\n#### Call Statements\n\n    CallStatement\n      : <Handler: Identifier> '(' [ <Arguments: ExpressionList> ] ')'\n\nThe call statement executes a handler with the given arguments.\n\nThe Handler identifier must be bound to either a handler or foreign handler definition.\n\nThe Arguments are evaluated from left to right and passed as parameters to the variable.\n\n> **Note:** It is a checked runtime error for the types of 'in' and 'inout' arguments to not match the declared types of the handler's parameters.\n\nAny parameters of 'out' type are not evaluated on entry, but assigned to on exit.\n\nAny parameters of 'inout' type are evaluated on entry, and assigned on exit.\n\n> **Note:** It is a checked compile-time error to pass non-assignable expressions to parameters which are of either 'out' or 'inout' type.\n\nThe return value of a handler is subsequently available by using **the result** expression.\n\n> **Note:** All handlers return a value, even if it is undefined. This means that calling a handler will always change **the result**.\n\n### Expressions\n\n    Expression\n      : ConstantValueExpression\n      | VariableExpression\n      | ResultExpression\n      | ListExpression\n      | CallExpression\n\nThere are a number of expressions which are built-in and allow constant values, access to call results, list construction and calls. The remaining syntax for expressions is defined in auxiliary modules.\n\n#### Constant Value Expressions\n\n      ConstantValueExpression\n        : 'undefined'\n        | 'true'\n        | 'false'\n        | INTEGER\n        | REAL\n        | STRING\n\nConstant value expressions evaluate to the specified constant value.\n\nThe **undefined** expression evaluates to the undefined value and can be assigned to any optional typed variable.\n\nThe **true** and **false** expressions evaluate to boolean values.\n\nThe INTEGER and REAL expressions evaluate to numeric values.\n\nThe STRING expression evaluates to a string value.\n\nConstant value expressions are not assignable.\n\n#### Variable Expressions\n\n    VariableExpression\n      : <Name: Identifier>\n\nVariable expressions evaluate to the value of the specified variable.\n\nVariable expressions are assignable.\n\n#### Result Expressions\n\n    ResultExpression\n      : 'the' 'result'\n\nThe result expression evaluates to the return value of the previous (executed) non-control structure statement.\n\nResult expressions are not assignable.\n\n### List Expressions\n\n    ListExpression\n      : '[' [ <Elements: ExpressionList> ] ']'\n\nA list expression evaluates all the elements in the expression list from left to right and constructs a list value with them as elements.\n\nThe elements list is optional, so the empty list can be specified as *[]*.\n\nList expressions are not assignable.\n\n#### Call Expressions\n\n    CallExpression\n      : <Handler: Identifier> '(' [ <Arguments: ExpressionList> ] ')'\n\nA call expression executes a handler.\n\nIts use is identical to a call statement, except that the return value of the handler is the value of the expression, rather than being available as **the result**.\n\n> **Note:** Handlers which return no value (i.e. have undefined as their result type) can still be used in call expressions. In this case the value of the call is **undefined**.\n"
	},	{
	"name":"lcb-style-guide",
	"display name":"lcb-style-guide",
	"data":"# LiveCode Builder Style Guide\nCopyright 2015 LiveCode Ltd.\n\n\n\n## Introduction\n\nThis document describes best practices to be followed when working with\nLiveCode Builder source code.  Please follow it *especially* when writing code\nto be included with the main LiveCode product package.\n\n## Copyright headers\n\nPlease include a license header at the top of the `.lcb` file.\n\nFor the main LiveCode repository, or for any community extensions, the license\nis the [GNU General Public License v3](http://www.gnu.org/licenses) *without*\nthe \"any later version\" clause.\n\n## Naming\n\n### Module name\n\nThe module name uses reverse DNS notation.  For example, a module created by\nthe Example Organisation would use module names beginning with `org.example`.\n\nReplace any hyphen (`-`) characters in a domain name with underscore (`_`)\ncharacters.  For example, a module derived from the `fizz-buzz.example.org`\ndomain could be `org.example.fizz_buzz`.\n\nAdditionally, add an underscore (`_`) to the start of any element in the domain\nname starting with a digit.  For example, a module derived from the\n`999.example.org` domain could be `org.example._999`.\n\nYou must only use module names corresponding to domain names that you control\nor are allowed to use.  This restriction is enforced by the the LiveCode\nextension store.\n\nIf you don't have a domain name of your own, you may use module names\nbeginning with `community.livecode.<username>`, replacing `<username>`\nwith the username you use to log into the LiveCode extension store.\nFor example, if your username is \"sophie\", then you can create a\nmodule named `community.livecode.sophie.mymodule`.\n\nFor the main LiveCode repository, please use module names beginning with\n`com.livecode`\n\nAlways write module names in lower case.\n\n### Naming variables and parameters\n\nGive variables and parameters `xCamelCaseNames` with a leading lowercase\ncharacter indicating their scope and availability.\n\nThe meanings of the leading lowercase characters are:\n\nPrefix | Context             | Meaning\n------ | ------------------- | -------\nk      | all                 | constant\ns      | module              | static variable\nm      | widget              | static variable\np      | handler definitions | `in` argument\nr      | handler definitions | `out` argument\nx      | handler definitions | `inout` argument\nt      | handler bodies      | local variable\n\nIn general, please use nouns to name your variables and parameters.  Make the\nnames descriptive; for example:\n\n    variable tOutputPath as String  -- Good\n    variable tString as String      -- Bad\n\nFor `Boolean` variables, please try to use \"yes or no\" names.  For example:\n\n    variable tIsVisible as Boolean\n    variable tHasContents as Boolean\n\n### Naming handlers\n\nGive handlers `TitleCase` names.\n\nIn general, please use verbs to name your handlers.  For example,\n\n    handler RotateShape(inout xShape, in pAngleInDegrees)\n        -- ...\n    end handler\n\n## Documenting the source code\n\nYou should add in-line documentation to `syntax` and `handler` definitions in\nLiveCode Builder source code.  It is particularly important to add in-line\ndocumentation to all syntax and to any public handlers that aren't primarily\naccessed using syntax.\n\nIn-line documentation for a handler or syntax definition is extracted from a\n`/* */` comment block immediately before the start of the definition.\n\nPlease refer to the [Extending LiveCode](Extending LiveCode.md) guide for full\ndetails of the syntax of in-line documentation comments, including examples.\n\n## Named constants\n\nOften, it is useful to use constant values in your code.  Please declare named\nconstants rather than placing the values in-line.  For example, you may\nwant to create three tabs labelled \"Things\", \"Stuff\", and \"Misc\":\n\n    constant kTabNames is [\"Things\", \"Stuff\", \"Misc\"]\n\n    handler CreateTabs()\n        variable tName\n        repeat for each element tName in kTabNames\n            -- Create the tab\n        end repeat\n    end handler\n\nIn particular, please avoid any \"magic numbers\" in your code.\n\n## Whitespace\n\n### Indentation\n\nPlease indent with tab characters.  Please use one tab character per level of\nindentation.\n\nPlease do not use a level of indentation at `module` level.\n\nComments should be indented to the same level as the code they apply to.\n\nFor example:\n\n    module org.example.indent\n\n    -- Example handler\n    handler Fizzbuzz(in pIsFizz)\n        if pIsFizz then\n            return \"Fizz\"\n        else\n            -- Maybe this should have a capital letter\n            return \"buzz\"\n        end if\n    end handler\n\n    end module\n\nIf it's necessary to mix spaces and tabs for indentation, please use 4 spaces\nper tab.\n\n### Handler declarations, definitions and calls\n\nIn handler type declarations and definitions, don't insert whitespace between\nthe handler name and the parameter list.  For example:\n\n    handler type Fizz()   -- Good\n    handler type Buzz ()  -- Bad\n\nIn handler parameter lists, please add a space between each parameter.  For\nexample:\n\n    handler FormatAsString(in pValue, out rFormat) -- Good\n    handler IsEqualTo(in pLeft,in pRight)          -- Bad\n\nPlease observe the same formatting in handler calls.  For example:\n\n    variable tFormatted\n    variable tIsEqual\n    FormatAsString(3.1415, tFormatted)             -- Good\n    IsEqualTo (tFormatted,\"3.1415\") into tIsEqual  -- Bad\n"
	},	{
	"name":"livecode_script",
	"display name":"LiveCode Script",
	"data":"# Introduction\n\nBefore getting started with LiveCode, there are a number of things you may want to know. This chapter introduces LiveCode, tells you where to begin, how to install, register and how to use the documentation.\n\n## Welcome\n\nLiveCode makes it easy to turn your concepts, ideas or designs into powerful applications. You can create desktop, Internet, database and network applications. LiveCode includes a complete graphical user interface builder, as well as the tools you need to produce faceless or background applications.\n\nLiveCode is easy to learn. If you are a complete beginner to the world of programming, you will find you can become productive quickly. If you are an experienced programmer, you will find the environment extremely powerful and one of the most productive you have used.\n\nLiveCodes programming language is object-based. This makes it easy to write modules of code that are attached directly to individual objects. Unlike other languages, LiveCode lets you both run and edit an application live. Traditionally the run, edit, compile and debug cycle in programming takes up a lot of time. In LiveCode all of these activities can take place together.\n\nIf youre coming from another language, youll appreciate that the LiveCode language is typeless, with data automatically stored in the most efficient format and converted, so you dont have to learn how to deal with different types of data. Memory management is fully automatic. LiveCode applications are not interpreted in the traditional sense, so they provide excellent performance. A LiveCode graphical application will often feel more responsive to use than a Java application, and take less time to write.\n\nA LiveCode application is completely cross-platform. That means you can run any application you create on all major modern operating systems, including Windows, Linux, Unix and Mac OS. Unlike most other cross-platform frameworks, a LiveCode application will always look and feel native on each platform that you deliver it on. You can take advantage of many platform specific features on each platform.\n\nLiveCode removes the need to learn how to access most individual programming interfaces for each operating system. This saves you the time and effort of learning thousands of platform-specific interface calls.\n\nThe goal of this manual is to provide the most accessible, comprehensive and useful guide to LiveCode possible. We aim to provide a level of depth that covers the advanced feature set, while remaining accessible to beginners. We hope you find this material useful and enjoy using LiveCode.\n\n## Where to Begin\n\nWe recommend you start by taking a look at **Developers** section online at [lessons.runrev.com](http://lessons.runrev.com). There is a wide variety of introductory material there, including step-by-step examples and guides for performing common tasks.\n\n## System Requirements\n\nMemory and disk requirements below are for the *LiveCode development environment*, not for applications created by LiveCode. Applications created with LiveCode will require sufficient free system resources to load, display, process and interact with the content of the application. Because this will vary considerably depending on the application created, it is not possible to publish a list of requirements for applications built with LiveCode. You will need to test your application to determine the minimum requirements. Many LiveCode applications will run on a moderately powerful computer and require substantially fewer resources than those listed for the development environment, others will require more.\n\n### All Operating Systems\n\nTo use LiveCode you will need:\n\n-   1024x768 or larger monitor\n\n-   True color display (16-bit or 32-bit depth)\n\n-   At least 256Mb of memory\n\n-   At least 150Mb of disk space\n\n### Requirements for Windows Systems\n\nLiveCode supports the following versions of Windows:\n\n-   Windows 2000 SP4\n\n-   Windows XP SP2 and above\n\n-   Windows Server 2003\n\n-   Windows Vista SP1 and above (both 32-bit and 64-bit)\n\n-   Windows 7 (both 32-bit and 64-bit)\n\n-   Windows Server 2008\n\nAdditionally, QuickTime 7 or later is required for most multimedia features.\n\n### Requirements for Linux Systems\n\nThe minimal requirements for LiveCode to run on Linux are:\n\n-   32-bit installation, or a 64-bit linux distribution that has a 32-bit compatibility layer\n\n-   2.4.x or later kernel\n\n<!-- -->\n\n-   glibc 2.3.2 or later X11R5 capable Xserver running locally on a 24-bit display\\*\n\n<!-- -->\n\n-   compositing window manager (optional - required for alpha-blended window shapes)\n\n-   gtk/gdk/glib (optional - required for native theme support)\n\n-   pango/xft (optional - required for pdf printing, anti-aliased text and unicode font support)\n\n-   lcms (optional - required for color profile support in JPEGs and PNGs)\n\n-   gksu (optional - required for elevate process support)\n\n-   mplayer (optional - required for video playback)\n\n<!-- -->\n\n-   esd (optional - required for audio playback)\n\nAlthough impossible to test every existing Linux distribution, we are aiming to ensure that LiveCode runs on as wide a variety of systems as possible. To achieve this, the engine has been implemented to have minimal direct dependencies on system software, and will gracefully degrade in feature set if it cannot find the libraries it needs. Generally any recent linux distribution including Gnome/GTK support will have the required libraries for full feature support  for example, Ubuntu 7 supports all these features (although alpha blended window shape support requires you to be running with 'Advance Desktop Effects' turned on).\n\n### Requirements for Mac OS X Systems\n\nLiveCode supports the following versions of Mac OS X:\n\n-   10.3.9 (Panther) on PowerPC\n\n-   10.4.11 (Tiger) on Intel and PowerPC\n\n-   10.5.8 and later (Leopard) on Intel and PowerPC\n\n-   10.6.x (Snow Leopard) on Intel\n\n## Using the Documentation\n\n### Documentation Conventions\n\nLanguage Terms\n\nThis documentation contains examples of LiveCode language syntax. The syntax for each language term is provided in **boldface typewriter text**.\n\nThe syntax description uses the standard conventions to indicate parts of the syntax:\n`[]` Square brackets enclose optional portions.\n\n`{}` Curly braces enclose sets of alternatives from which to choose.\n\n`|` Vertical bars separate different alternatives.\n\n`\\\\` Line continuation character  this line continues to the next line.\n***Italics*** indicate placeholders that you don't enter literally.\n\nCode examples are provided in `typewriter text`.\n\n**Menu Reference**\n\nWhen you are told to choose an item from a menu, the menu name is written, followed by an arrow, followed by the menu item. For example **File -\\> New** means choose \"New\" from the \"File\" menu.\n\n**Keyboard Shortcuts**\n\nMany menu items have keyboard equivalents. These items can be accessed by holding down a modifier key and pressing another key. The modifier keys used throughout this document are generally the modifier keys used on Windows, Linux and Unix. If you are using Mac OS, you may need to substitute modifier keys using the table below. For example, if you are using a Mac, where we say press **control-x** in this documentation, you may need to press **command-x**.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|------------------------------------------------|---------------------------------------------------------------|\n| **Windows, Linux and Unix keyboard shortcuts** | **Mac OS equivalent**                                         |\n| Control                                        | Command                                                       |\n| Alt                                            | Option                                                        |\n| Right-click                                    | Control-click (or right-click if you have a two button mouse) |\n\nFigure 2 Cross-platform Keyboard Shortcuts\n\nScreen Snapshots\n\nScreenshots are used extensively throughout the documentation. Please remember that LiveCode is a cross-platform application. While many of the snapshots are taken on the Windows platform, most of the feature set will work on Linux, Unix and Mac OS. Snapshots of these platforms are used from time to time and are also used to illustrate platform specific features.\n\n> **Tip:** This style of text box tells you about an alternative way to do something or describes a shortcut.\n\n> **Important:** This style of text box describes an aspect of LiveCode that may confuse you if you don't know about it and tells you how to avoid unexpected behavior.\n\n> **Note:** This style of text box provides some additional information that may be useful, or emphasizes a key point.\n\n> **Caution:** This style of text box warns you about a potential problem that might cause an error or loss of data.\n\n### Navigating the Documentation\n\nThe LiveCode documentation is spread across four components; the Start Center, the Resource Center, the Dictionary and this User's Guide.\n\nThe Start Center is aimed at introducing you to LiveCode, and should be your first port of call if you have not used LiveCode before. The Resource Center will help you build upon any experience you have and the dictionary is a reference resource which you can refer to while implementing your projects.\n\nYou can access the documentation from within LiveCode from the **Help** menu. Additional resources are available online at [www.runrev.com](http://www.runrev.com).\n\n### Start Center\n\nThe purpose of the Start Center is to introduce you to LiveCode and provide you with enough knowledge to start implementing your own projects. It can be accessed by choosing **Help -\\> Start Center**. The Center itself is split across two sections; Getting Started and User Forums.\n\n**Getting Started**\n\nThe Getting Started section contains media and written tutorials. These outline the basic functionality behind LiveCode and provide instruction on how to create a simple calendar stack. The section also contains a downloadable version of this guide and a link to the LiveCode Resource Center which is outlined in section 1.6.4.\n\n![](images/image2.png)\n\n**User Forums**\n\nLiveCode has a very active and friendly user community. We encourage all new users to sign up to our mailing list and user forums as they are a great way to get technical help, meet new people and keep up-to-date with what is going on in the world of LiveCode. The User Forums section provides a link to our forum registration page as well as a list of links to the most recent posts which have been made.\n\n![](images/image3.png)\n\n### Dictionary\n\nThe Dictionary contains the complete LiveCode syntax. This can be searched using the quick search box in the top right of the dictionary or filtered using the list of topics on the left.\n\n![](images/image4.png)\n\nWhen the selected filter is All the keyword index will contain all the entries in the dictionary. The number of entries will decrease when a different filter is chosen as only the syntax for that topic will be shown.\n\n![](images/image5.png)\n\n![](images/image6.png)\n\nThe documentation for a Dictionary entry can be viewed by clicking on the entry header in the keyword index. This will show the entry in the area underneath the data view list. To expand the entry to fill the window, double click the entry in the list. To get back to the previous view use the back button.\n\n![](images/image7.png)\n\n![](images/image8.png)\n\nThe Dictionary itself has two viewing modes; single column view and multiple column view. When in single column view, only the keyword for each dictionary entry will be shown in the keyword index. In multiple column view you can choose which items to see for each entry. The items can be chosen via the Preferences pane or by right-clicking on the column headings themselves (when in multiple column view).\n\n![](images/image9.png)\n\n![](images/image10.png)\n\nAt the bottom of each dictionary entry, there is a box titled User contributed notes. This will contain any comments made by other LiveCode users about the keyword documented above. It is worth having a quick look over these notes as they may often explain ways to do things more easily or efficiently, or show how to avoid potential problems.\n\nIf you wish to contribute notes yourself, or to give feedback on the helpfulness of existing notes, you will need a RevOnline account. Please see the section on RevOnline below, to find out more about RevOnline. If you are not logged into your RevOnline account, the dictionary will ask you to do so before adding or rating notes.\n\n![](images/image11.png)\n\nOnce you are logged in, you will be able to submit your own notes to any dictionary entry. All submissions get queued for approval by the RevOnline team. You will normally receive an email within a few days indicating whether or not the note was approved.\n\nThere are no formatting options available, so your note will appear just as it does in the entry field, with one exception. Anything enclosed in xml tags will be treated as a LiveCode code snippet, indented and colored.\n\n![](images/image12.png)\n\nIn order to achieve the best possible user experience and to maximize the chances of your submissions being approved, please try to adhere to the guidelines described in the About Notes pop-up box.\n\n### RevOnline\n\nRevOnline gives you the opportunity to upload and share your projects as well as download those created by other members of the LiveCode online community. It can be accessed via the RevOnline button located in the menu bar. The main interface can be seen below:\n\n![](images/image13.png)\n\nThe interface is designed to organise the online content into various categories to aid you in finding the kind of content you wish to download. You will find three main types of content in RevOnline, stacks (LiveCode programs), externals and code snippets. Externals are libraries that can extend the functionality of the LiveCode language using a lower level language. A code snippet is a portion of LiveCode script that you can paste into and incorporate into your own projects.\n\nThe results of searching or browsing through the RevOnline content are displayed in the *search list* area. This is an explaination of the controls you can use to adjust the parameters of your search:\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Search field**    | Enter text and press return or click Go to search. Matches will be made against the titles of uploaded content, the authors name and content descriptions.                                                                                                                                                                 |\n| **Type list**       | Highlight one of the items in this list filter search to only show results of that type. Selecting All will display content of all three types.                                                                                                                                                                             |\n| **Tag list**        | Tag your own and others peoples content with a word or phrase. All tags are listed here alphabetically. Selecting a tag will filter the search results for uploads that have been tagged accordingly. Selecting All will remove the filtering.                                                                             |\n| **Search order**    | Change the order in which the search results are displayed. There are four options. A to Z lists content alphabetically by title, Popularity by the number of times it has been downloaded, Rating by the average user rating (out of five stars) and Date by the date on which the content was uploaded to RevOnline |\n| **Order direction** | The direction (ascending/descending) of the search order can be changed by clicking on the arrow to the right of the sort control.                                                                                                                                                                                            |\n| **View mode**       | The search list area can be viewed in two modes, a vertical scrolling list or a grid. In list mode 10 results will be displayed per page, in grid mode the number of results displayed will be dependent upon the size of the RevOnline stack. Whilst in grid mode the *viewing pane* area will not be visible.         |\n| **User filter**     | If you apply user filter to a search, the users name will appear above the type and tag lists (see below), subsequently only content by that user will be returned in the search results. Clicking on the button or text of the user filter will remove it.                                                                  |\n\n![](images/image14.png)\n\nThe *search list* area displays a preview of the results your search has returned. At the top of this list you will see the *page controls* which allow you to navigate forwards and backwards through the pages of your search should it return more results than can be displayed on one page.\n\n![](images/image15.png)\n\nAn example of the search list previews can be seen below:\n\n![](images/image16.png)\n\nAt the top of the preview is the contents name. You can also see its average user rating out of five stars, the total number of times it has been downloaded, the authors name and a list of tags applied to this upload. The download button at the bottom will download and launch this particular stack, it also tells you the size of the download. The *preview image* can either be a custom screenshot as above or one of three standard images. These are black for stacks, red for code snippets and green for externals. The *type icon* in the lower left corner of the preview image also indicates the type, these are shown below for a stack, code snippet and external respectively:\n\n![](images/image17.png) ![](images/image18.png) ![](images/image19.png)\n\nClicking on the *preview image* or content title will update the right hand *viewing pane* with more detailed information about this upload. Clicking on the authors name will display the authors user profile in the *viewing pane* and introduce a *user filter* to the search results. When the *search list* is in grid mode the *viewing pane* will be hidden, doing either of the above operations will cause the *search list* to switch back to list mode and display the associated content in the *viewing pane*.\n\nThe *viewing pane* displays detailed information on users and uploads.\n\n![](images/image20.png)\n\nIf you are a viewing stack details as shown above, in addition to the information provided by the preview you will also see a headline, description and a revision number which is incremented whenever the author uploads a new version of their stack, code snippet or external. Clicking on the authors name or *user profile image* will display their profile view. Clicking on the *content type* or any of the tags in the *list of applied tags* will apply these filters to the search controls. When viewing an external your will see an additional Platform: field that indicates which platforms the external library is compatible with, make sure your operating system is supported before downloading and installing an external. If you are currently logged in to your Rev Online account you will be able to give the upload a rating by hovering over the *rating control* and clicking when the rating you wish to submit is displayed, this can only be done once per upload. You can also tag the upload by clicking on the *add tag control* which brings up following dialog:\n\n![](images/image21.png)\n\nAs you type into the text entry field, tag suggestions will appear in a drop down menu that can be selected using the arrow keys. Once you have finished typing press the ok button to submit your tag, you must be logged in to complete this operation.\n\nThe *status bar* at the bottom of the RevOnline interface displays the number of results your search has returned as well as a progress bar indicating the progression of searches and downloads. You will also see text feedback in response to the operations you perform such as Retrieving stack details ... and Content tagged etc.\n\nIn the top right corner of RevOnline you will find the *login controls* which will display your current login status as shown below:\n\n![](images/image22.png)\n\nIn order to upload, rate and tag content in RevOnline you must have an account, this account is also required for making comments in the wiki docs detailed elsewhere. To register for an account just click on the Sign Up control and enter your email in the dialog that appears. Your email address will be used as your username for logging in, a password will be emailed to you upon signing up. After receiving this email you must hit the activation link in the email before your account can be accessed. Once activated, you can login to your account using the Log In control pictured above which will bring up the following dialog:\n\n![](images/image23.png)\n\nThe Remember me check box will cause RevOnline to maintain your username in the Email : field between login attempts. The Sign in automatically check box will mean that you are automatically signed in upon opening RevOnline, however if you explicitly sign out you will have to re-enter your password regardless of this preference. If you forget your password at any time you can use the Forgot your password? link in the login dialog to have a new one emailed to you.\n\nUpon logging in and viewing your profile for the first time you will be presented with your profile view in edit mode where you have the opportunity to enter information about into the highlighted fields and change your profile picture using the *change profile picture* control as shown below:\n\n![](images/image24.png)\n\nClicking on the *change profile picture* control will bring up the following dialog:\n\n![](images/image25.png)\n\nUse the *Position Controls* to move the centre of the image up, down, left or right. You can zoom in or out using the *Zoom controls*. Pressing the *Re-centre image* button will reset the image to its original position and zoom level. Once you are happy with orientation of your picture click ok, or cancel to discard your changes. This dialog is also used to change stack preview pictures.\n\nWhen you have finished editing your profile you can hit the save changes button to submit your information, a minimum of a first and last name must be entered before you can save. You can also choose to display your email or not and change your password to one of your choosing using the Change password control. You can reach this profile at any time by clicking on the My Account control in the *login controls* which will both display your profile and display all your uploads in the *search list*. To exit this view simply remove the user filter or hit the My Account control again.\n\nTo upload content to RevOnline simply click on the upload content in the *login controls,* you will then be presented with the content browser view.\n\n![](images/image26.png)\n\nClicking on the tabs at the top of this view will change the content type. Above you can see the code snippet view, it simply requires you to paste a section of code into the *code entry field* and press ok, if you have your code snippet stored in your clipboard you can simply press the paste button. For stacks you can either select a stack from the list of recently opened stacks or browse to the files location using the browse button. For externals you need to check which platforms your external will support and then browse to the appropriate file you wish to upload (shown below). The default file types for extensions on each platform are; .dll for Windows , .bundle for Mac OS X and .so for Linux.\n\n![](images/image27.png)\n\nWhen uploading a code snippet or external RevOnline will place the code or file into an installer stack. The installer stacks give you the option to install or try an external file or copy to clipboard a code snippet. When using the try option with an external the file will be removed from your installation when you next exit LiveCode.\n\nOnce you have pressed ok you will be presented with the edit mode view for the file you are uploading. Here you can enter a name description and change the preview picture for your upload (note  you cannot edit the title of an external upload it must be the name of one of the files you have included). If you attempt to upload a file that has already been uploaded to RevOnline, you will be taken to the existing version of that file to edit, this avoids duplicate uploads.\n\nWhenever you are viewing content that you have uploaded or your own profile whilst logged in the edit controls will appear above the *viewing pane*, shown below:\n\n![](images/image28.png)\n\nBy clicking on the edit profile or edit content (for stacks etc.) button you are entering edit mode which allows you to make changes to the information shown. When editing your profile you can simply save or discard the changes you have made. When editing an upload you have the additional options of deleting and updating the uploaded file. The delete control will permanently remove your upload from RevOnline. The update control allows you to replace the stack file, code snippet or external library with a newer version. Clicking on this control will present you with the content browser view discussed earlier. After you have chosen a replacement file you need to save your changes in order for the new file to be submitted.\n\n![](images/image29.png)\n\nThe list of tags applied to your own uploads can be altered by using the Add/Delete tags control (shown above) which will bring up the following dialog:\n\n![](images/image30.png)\n\nThis works in a similar way to the previously explained tag dialog except that you can view the entire list of tags and edit which ones you wish to be displayed. When hitting return after entering the name for your tag a new *tag item* will appear in the list (also achieved by pressing the *add tag* button). Tags can be removed by clicking on the appropriate *remove tag button*. If your tag list is too large for one page you can browse through the pages of tags using the *page controls* at the bottom of the dialog. Once you have finished editing the list you can submit your changes by clicking the ok button.\n\nAdditional options for the RevOnline interface can be set in the RevOnline tab of the preferences stack. As pictured below:\n\n![](images/image31.png)\n\nHere you can set the remember password and user name preferences and change your password to one of your choosing. The search results in RevOnline are cached to speed up performance. You can tweak the size and time for which this cache remains valid using the two slider controls. A larger cache will give you faster performance but will take longer to pickup changes made to the online content made by other users. If the text only searches option is checked RevOnline will only retrieve the text data for the search list previews which can also improve performance.\n\n### User's Guide\n\nThis Users Guide is a complete reference to LiveCode. It details what the dialogs and windows within the development environment do, and explains the LiveCode language in depth.\n\n## Additional Resources\n\nIf you have a question that isn't answered in this documentation, you can find additional information to help you on our web site. You can also connect with the LiveCode developer community, which includes many experienced developers who offer their expertise for the common good to answer questions and help their fellow developers. You'll find example code, information on planned enhancements, and the latest updates. Visit:\n\nhttp://www.runrev.com\n\n### Developer Community\n\nThe forums (section 1.6.3 above), are available for getting help from other developers, for discussing feature requests and future directions, and for receiving announcements from RunRev. To join the forums, visit:\n\n<http://forums.runrev.com/>\n\nMailing lists are also available. To join the mailing lists visit:\n\n<http://support.runrev.com/lists>\n\n> **Tip:** Tip: You can use the Google search engine to search the list archives, using\n<http://www.google.com/advanced_search?q=site:lists.runrev.com>\n\n### Technical Support\n\nRunRev offers *up and running* technical support to all users to assist you in getting the development environment working on your system.\n\nMany editions include additional technical support for more *advanced* problems and questions. Where support is not included, a separate technical support contract for advanced support can be purchased. For full details of our current support policies, please see <http://support.runrev.com/>\n\nYou can contact us by email <support@runrev.com>\n\n# Getting Started\n\nCreating a simple *graphical application* in LiveCode can take just minutes. First you create a user interface, including any windows, palettes, dialogs you require. Then you populate the user interface with controls, like push buttons, check boxes, text fields or menus. Finally, you use LiveCodes English-like programming language to tell your application how to behave.\n\n### Prerequisites\n\nBefore you get started, you should be familiar with how to use your computer. You should also be familiar with common applications such as a web browser, word processor and email client. If you are using Linux or Unix, you should be familiar with basic use of the command line. If you are not familiar with using a computer, we recommend you spend some time getting acquainted before trying to learn LiveCode.\n\n### Event Driven Programming\n\nA LiveCode application is driven by user actions. LiveCode constantly watches the computer for common actions, such as clicking on a button, typing into a field, sending data across a network, or quitting an application.\n\nWhenever an event occurs, LiveCode sends a message. When writing your program, you decide what messages you want your program to respond to. LiveCode automatically sends each message to the most relevant object. For example, if a user clicks on a button, LiveCode sends a message to the button. You place code within the button that tells it how to respond to being clicked on.\n\nThere are a wide range of possible events. When a user clicks on a button, a series of events are sent to the button. For example, when the mouse first moves within the border of the button a `mouseEnter`message is sent. Then a series of mouseMove messages are sent as the mouse moves over the button. When the mouse button is depressed a `mouseDown`message is sent. When the mouse is released a `mouseUp`message is sent. You dont have to respond to all of these events. You simply place code within an object to handle the events you want your application to respond to.\n\nEvents that are not handled by individual objects can be handled in a number of ways at different levels of your application, in libraries, or they can be ignored. The rules that govern what happen to events that are not processed by an object are described in the section *The Message Hierarchy*.\n\nWell return to Event Driven Programming in more detail in the section *Coding in LiveCode*.\n\n### Object-Based Programming\n\nAny *graphical application* you build using LiveCode will be based on objects. With LiveCode you typically create the objects of your application before writing any code. You can start by drawing the buttons, text fields, and other controls that make up your application. LiveCode operates like other layout, drawing or application development environment. You can select controls by clicking them, move them by dragging them around, resize them, and change their layer to move them closer or further from the top of the interface.\n\nOnce you have the objects in place, you can proceed to attach code to each object to respond to the events you want. LiveCode includes a complete graphical development environment that makes it easy to create and edit any kind of user interface. It includes objects for all the basic operating system elements, including buttons, checkboxes, text fields, menus, graphics, and many more. In addition you can create and customize your own objects that look and behave however you want.\n\nIf you are writing a non-graphical application, you can choose to create objects to assist in organizing your code into sections and load these objects off screen, or you can simply write your code in a text file and run the text file directly. This method is commonly used to communicate with Apache and other web browsers when using LiveCode to build server-side or network applications.\n\nObject-Based programming is covered in more detail in the section *Building a User Interface*. Non-graphical applications are covered in more detail in the section *Building a Web Application*.\n\n### The Edit and Run Mode\n\n> **Important:** In order to enter **run** mode, choose the browse tool in the *top left* of the tools palette.\n\nIn order to **edit**, choose the pointer tool from the *top right* of the tools palette.\n\nUnlike most other development systems, a LiveCode application can be created, edited, debugged and run live.\n\nWhen in run mode, objects receive all the normal messages that drive a LiveCode application. For example, clicking on a button in run mode will cause a `mouseUp`message to be sent to it, causing the button's script to run if you've designed it to respond to the `mouseUp`message.\n\nWhen in edit mode, objects do not receive messages when you click on them, and you can move, resize or edit the properties for objects.\n\n> **Tip:** To temporarily stop all messages being sent to your application while editing it, choose *Suppress Messages* from the *Development* menu or *Toolbar*.\n\nThere few other differences between the two tool modes. You can view and edit properties and code in either mode. Your application does not stop running while you make changes to it. Only mouse interaction with objects is suspended in edit mode to allow you to edit them more easily.\n\nBecause LiveCode is constantly live, you can easily make simple changes and watch each change take effect as you make it. This allows you to design and experiment using an iterative process, resulting in a more productive and satisfying development experience.\n\n## Structuring your Application\n\n### Cards, Stacks & Files\n\nThe first step in creating a LiveCode application is creating a window, which in LiveCode is called a stack. Each window you see in LiveCode is a stack. Palettes, dialog boxes, and standard windows are all stacks.\n\nEach stack contains one or more sets of information called cards. Each card can have a different appearance or all the cards in a stack can look the same. By going from card to card in a stack, you change what's being displayed in that stack's window. You can think of a LiveCode stack as a stack of playing cards (hence the name), where you can flip through the cards, but only one card at a time is visible. A stack can have a single card or many cards. See Figure 3  Stack file Structure, below.\n\nAll user interface objects (controls) are created by dragging them on to a card area.\n\nYou can also group controls together if you want them to operate as a set. For example, if you have a set of navigation buttons that go from card to card in your stack, you can make them into a single group. Groups can appear on more than one card, so your navigation buttons or background image can appear on each card of your stack. For more details, see the section on *Group and Backgrounds*.\n\nA collection of stacks can be saved together in a single file. This file is known as a stack file. The first stack in the file is called the main stack and will be loaded automatically when your application is run.\n\n### The Structure of a Stack File\n\nEach LiveCode file contains one or more stacks: either a single main stack, or a main stack and one or more substacks. Since each stack is a window (including editable windows, modeless and modal dialog boxes, and palettes), a single stack file can contain multiple windows.\n\nYou can use this capability to bundle several related stacks into a single file for easy distribution, to organize your stacks into categories, or to allow several stacks to inherit properties from the same main stack.\n\n![](images/image32.png)\n\nFigure 3  Stack File Structure\n\n### Opening a Stack File\n\nWhen you open a stack file, either by using the \"Open Stack\" menu item in the File menu or by using one of the navigation commands (see **open, go**, **modal**, **modeless**, **palette**, or **topLevel** in the *LiveCode Dictionary*), the stack file's main stack opens automatically to its first card.\n\n> **Important:** A stack file is saved as a whole. If you save a stack, all the other stacks in the same stack file are saved at the same time.\n\nSubstacks in the stack file do not open automatically when the stack file opens. You must open a substack in a handler or the Message Box, or by using the Application Browser.\n\n### Main Stacks and Substacks\n\nThe first stack created in a stack file is called the *mainstack*. Any other stacks created in the same stack file are called *substacks* of the mainstack.\n\nThe mainstack is part of the object hierarchy of all other stacks in the same stack file. In other words (for the purposes of inherited properties and shared behaviors), the mainstack *contains* its substacks. Events that are not handled by a substack are passed on to the mainstack's script, color and font properties are inherited from the mainstack by its substacks. For more details on the object hierarchy and inheritance in LiveCode in general, see the section on *The Message Path*.\n\nDialog boxes and palettes are commonly stored as substacks of the main application window, which is typically a mainstack. This allows you to store code and common functions used by all the substacks in the mainstack's script. Because mainstacks are part of the object hierarchy of their substacks, the substacks can call this functionality from scripts within the substack.\n\n### Stacks, Stack Files, and Memory\n\nA stack file can be loaded into memory without actually being open. A stack whose window is closed (not just hidden) is not listed in the **openStacks** function. However, it takes up memory, and its objects are accessible to other stacks. (For example, if a closed stack loaded into memory contains a certain image, you can use the image as a button icon in another stack.)\n\nIf one stack in a stack file is loaded into memory, so are any other stacks in the same stack file. You cannot load one stack in a stack file without loading all the rest at the same time even if you open only one of the stacks.\n\nA stack can be loaded into memory without being open under the following conditions:\n\nA piece of code in another stack read or set a property within the closed stack. This automatically loads the referenced stack into memory.\n\nThe stack is in the same stack file as another stack that is open.\n\nThe stack was opened and then closed, and its **destroyStack** property is set to false. If the **destroyStack** property is false, the stack is closed but not unloaded when its window is closed.\n\n> **Tip:** To manipulate a stack window in an external, use the **windowID** property. For more information, see the *LiveCode Dictionary*.\n\n### Media & Resources\n\nWhen planning a project, it is important to consider what types of media you will need to access and how to structure access to that media.\n\nLiveCode supports a wide range of media formats. Media can be accessed using the built-in media support, through QuickTime or via an external library. The advantage of using the built-in support is that you can consistently display or play back the media on all platforms without having to check that any 3<sup>rd</sup> party component has been installed. The advantage of using QuickTime is that a wider range of media is supported. Other 3<sup>rd</sup> party libraries may allow a greater range of media access.\n\nSince each loaded stack file takes up as much memory as the size of all its stacks, it is often advisable to place large, seldom-used objects (such as color pictures, sound, and video) in external files, which can be bundled with your application and loaded into memory only when you need them.\n\nThe built-in media support allows you to embed media directly within your stack file, or to reference it externally, storing it in a data folder, online or on a CD. QuickTime media must be located externally and can either be local or streamed from a server.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|\n| **Embedding Media within your project**                                                                                   | **Referencing Media externally**                                                                    |\n| Allows distribution of a single-file application for easy, reliable distribution                                          | Requires you to distribute the media files separately                                               |\n| Requires importing media whenever it is updated                                                                           | Allows you to edit media files directly, they update automatically                                  |\n| Requires enough memory to load all the media                                                                              | Makes it easy to load and unload media if you need to reduce memory requirements                    |\n| Allows you to use the built-in editing capabilities directly                                                              | Requires you to import and export the media to use the built-in editing capabilities                |\n| Is less practical for creating large themed or localized applications where one set of media is replaced with another set | Makes it easy to create themed or localized applications by simply linking to a different directory |\n\n> **Tip:** When importing images, use the Image Library, or create a library card that contains all the originals, then reference those objects throughout your project. For more details on referencing images, see the section on the *button* object.\n\nFor details of the image formats supported natively, see the section on the *Image* object. For details of the audio formats supported natively, see the section on the *audioClip* object. For details on how to control a QuickTime movie, see the section on the *Player* object.\n\n### How to Use External Files\n\nThere are three main ways to use external files:\n\nKeep media such as images, sounds, and video in external files, in the appropriate format, and use referenced controls to display the contents of the files. When you use a referenced control, the image, sound, or video file is loaded into memory only when a card that contains the referenced control is being displayed. The memory needed for the image, sound, or video is therefore only used when actually needed. By using *relative file paths*, you can move the application and its data files to any other system. For more details on using file paths, see the section on *File Name Specifications and File Paths*.\n\n> **Note:** To create a referenced control, use the \"New Referenced Control\" submenu in the File menu, or create an empty image or player object, then set the object's **fileName** property to a file path for the file you want to reference. For more details, see the section on *Building a User Interface*.\n\nKeep portions of your application in a separate stack file, and refer to the stacks in that stack file as necessary. The **stackFiles** property simplifies referring to external stack files. When you set a stack's **stackFiles** property to include one or more file paths, the stacks at those locations become available to your stack by simply referring to the stacks by name.\n\nKeep portions of your application on a server, and download them using the built in URL commands. For more details on the URL commands, see the section on *Working with Files, URLs & Sockets*.\n\n### When to use a Database\n\nYou don't need to use an external database to store information for your application. You can store information in stacks, in text files, and in a variety of other files, read it into your application as needed, and modify it. However, as a rule of thumb, we recommend that when you have over two thousand records of information, or you want to allow multiple users to access information at the same time, you consider using a database.\n\nIn these circumstances an external database offers many advantages. A database located on your local machine will be fast and efficient at accessing and searching records. A database located on a server can be accessed by more than one user. Depending on the particular implementation, a database may be suitable for constant access by hundreds of users, each receiving and updating data continually. SQL databases have built-in record-locking capabilities, preventing one user's changes from wiping out another's a necessity for reliable multi-user databases. Other built-in features work behind the scenes to ensure the data in the database is not corrupted by interference between different users.\n\nSQL databases are also built for speed. When searching tens or hundreds of megabytes or more, the performance of an optimized database will generally be much better than that of a stack doing the same search. Moreover, stacks must be loaded into memory to be searched, and therefore the whole collection of data must fit into local memory.\n\nFinally, if you use an external database, you can put the heavy-duty processing on a server designed for the purpose, while using LiveCode's flexibility to give the user options for selecting data, then presenting it in a usable form.\n\nWith LiveCodes built in *Database Library*, your application can communicate with external SQL databases. You can get data from single-user and multi-user databases, update data in them, get information about the database structure, and display data from the database in your stack. With the Database Query Builder, you can automate the process of querying a database and populating fields with the data, with no coding required.\n\nFor more details on working with databases, see Chapter 8, *Working with Databases*.\n\n### LiveCode Memory Limits\n\nThe following table details the memory limits for different types of LiveCode components. Please note that these limits refer to the maximums that may be in use at any one time. You can store additional information on disk or in a database and load it when it is required.\n\n**A note about entries designated as \"Unlimited\":**\n\nSince each open stack file resides completely in memory, LiveCode stacks (and all structures within a stack) are effectively limited by available memory and by LiveCode's total address space of 4G (4,294,967,296 bytes) on 32-bit systems\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------------------------------------------|---------------------------------------------|\n| Total addressable space                     | 4 GB (on 32-bit systems)                    |\n| Maximum length of a line in a field         | 65,536 characters storage                   \n| |                                                                                            \n| |                                               No more than 32,786 pixels wide for display  |\n| Maximum size of an object                   | Unlimited                                   |\n| Maximum number of objects in a group        | Unlimited                                   |\n| Maximum number of objects on a card         | Unlimited                                   |\n| Maximum number of cards in a stack          | Unlimited                                   |\n| Maximum number of objects in a stack        | Unlimited                                   |\n| Maximum length of object names              | 65,536 characters                           |\n| Maximum length of custom property names     | 255 characters                              |\n| Maximum length of command or function names | 65,536 characters                           |\n| Maximum size of custom properties           | Unlimited                                   |\n| Maximum number of custom properties         | Unlimited                                   |\n| Maximum size of a script                    | Unlimited                                   |\n| Maximum size of other properties            | 64K                                         |\n|                                             |                                             |\n| Maximum nesting level in control structures | Unlimited                                   |\n| Maximum level of recursion                  | Unlimited                                   |\n\n# The Development Environment\n\nThis section details the main components within LiveCodes Integrated Development Environment (IDE). The development environment contains all the features you need to quickly create a professional application. The Application Browser allows you to find your way around your application as you develop it. The Properties Inspector allows you to set appearance and basic behaviors. The Code Editor allows you to add code to each object in your application. In addition to these standard tools, the Message Box provides a mini command-line that allows you to develop aspects of your application automatically or to test out your applications code and functionality.\n\n## The Menu Bar\n\n### The File Menu\n\nThe File menu contains commands to open, close and save files; print; and incorporate files into your stack.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|----------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **New Mainstack**                      | Creates a new \"Untitled 1\" main stack window. When you save the stack, LiveCode asks for a file name and location.                                                                                                                                        |\n| **New Substack of (main stack name)**  | Creates a new untitled stack in the same file as the active main stack. When you save the substack, it is saved in the main stacks file. This item is disabled if the active window is not a main stack.                                                 |\n| **Open Stack...**                      | Opens the main stack whose file you select. If you select a HyperCard file, it is automatically converted into a LiveCode main stack.                                                                                                                     |\n| **Open Recent Stack**                  | Opens a cascading menu containing the names of the 30 main stacks you have most recently closed. Choose a name to open the stack. You can change the number of items displayed using Preferences.                                                         |\n| **Close**                              | Closes the active window. This item is disabled if no window is open.                                                                                                                                                                                     |\n| **Close and Remove from Memory...**    | Closes the current stack and all stacks in the same stack file as the current stack, and removes all stacks in the file from memory. This item is disabled if the active window is not a user stack.                                                      |\n| **Import as Control**                  | Opens a cascading menu you can use to choose a file and place its contents in a new control of the appropriate type. This item is disabled if the active window is not a stack.                                                                           |\n| **Image File...**                      | Imports the picture file you choose as a new image on the current card. You can import GIF, JPEG, PNG, BMP, XWD, XBM, XPM, or PBM, PGM, or PBM files (and PICT files on Mac OS and OS X systems). For more details see the section on the *image* object. |\n| **Snapshot**                           | Displays a crosshairs cursor for you to select an area of the screen, and imports a screen shot of that area as a new image on the current card.                                                                                                          |\n| **Audio File...**                      | Imports the sound file you choose as a new audio clip in the current stack. You can import WAV, AIFF, or AU files. For more details, see the section on the *audioClip* object.                                                                           |\n| **Video File...**                      | Imports the video file you choose as a new video clip in the current stack. You can import QuickTime, AVI, or MPEG files. For more details, see the section on the *videoClip* object.                                                                    |\n| **Text File...**                       | Imports the text file you choose as a new field on the current card.                                                                                                                                                                                      |\n| **EPS File...**                        | Imports the Encapsulated PostScript file you choose as a new EPS object on the current card. This item is only available on Unix platforms with Display Postscript installed. For more information, see the section on the *EPS* object.                  |\n| **All Images in Folder...**            | Imports all the picture files in the folder you choose, and places them in new images on the current card. Subfolders, and other types of files, are ignored. For more details see the section on the *image* object.                                     |\n| **All Audio Files in Folder...**       | Imports all the sound files in the folder you choose, and places them in new audioClips in the current stack. Subfolders, and other types of files, are ignored. For more details, see the section on the *audioClip* object.                             |\n| **New Referenced Control**             | Opens a cascading menu you can use to select a file to reference (i.e. link) to a new control of the appropriate type. This item is disabled if the active window is not a stack.                                                                         |\n| **Image File...**                      | Creates a new image on the current card and links to the picture file you select in the new image object. For more details see the section on the *image* object.                                                                                         |\n| **Quicktime-Supported File...**        | Creates a new player on the current card and links the audio or video file you select with the new player. For more details, see the section on the *player* object.                                                                                      |\n| **All Images in Folder...**            | For each picture file in the folder you select, creates a new image on the current card and links it with one of the files. Subfolders, and other types of files, are ignored. For more details see the section on the *image* object.                    |\n| **Save**                               | Saves changes to the current stack and to any other stacks that reside in the same stack file. If the file has not yet been saved, you specify the new files name and location. This item is disabled if the active window is not a stack.               |\n| **Save As...**                         | Saves the current stack, along with any other stacks that reside in the same file, to a new file with a name and location you specify. The new file becomes the current working copy.                                                                     |\n| **Move Substack to File...**           | Saves the front most substack as a main stack in a file of its own, with a name and location you specify. The substack is removed from its previous stack file. This item is disabled if the active window is not a substack.                             |\n| **Revert to Saved...**                 | Throws away any changes to the current stack, along with any other stacks that reside in the same stack file. The entire stack file is then reloaded.                                                                                                     |\n| **Standalone Application Settings...** | Settings for packaging the current stack for distribution as a standalone application. This item is disabled if the active window is not a stack. For more details, see the section on*Deploying your Application*.                                       |\n| **Save As Standalone Application...**  | Packages the current stack into a standalone application for distribution using the settings set using the Standalone Application Settings window.                                                                                                        |\n| **Page Setup...**                      | Opens the Page Setup dialog box for the currently selected printer.                                                                                                                                                                                       |\n| **Print Card...**                      | Prints the current card.                                                                                                                                                                                                                                  |\n| **Print Field...**                     | Prints the currently selected field using the revPrintField command. For more details, see the section on *Printing*.                                                                                                                                     |\n| **Exit**                               | Closes all open stacks and quits LiveCode.                                                                                                                                                                                                                |\n\n### **The Edit Menu**\n\nThe Edit menu contains commands to select, cut, copy, and paste text and objects.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Undo**             | Reverses the most recent text change, paint action, movement or deletion of an object.                                                                                                                                                                                                |\n| **Cut, Copy, Paste** | Cuts, copies or pastes the selected text or object. Text and images can be exchanged with other programs in this manner. Objects are only available within the currently running instance of LiveCode.                                                                                |\n| **Clear**            | Deletes the selected text or objects, without placing it on the clipboard.                                                                                                                                                                                                            |\n| **Duplicate**        | Makes a copy of the selected object or objects. If the object is a card, the copy is added after the current card. If the object is a control, the copy is placed on the current card, below and to the right of the original object. This item is disabled if no object is selected. |\n| **Replicate...**     | Makes one or more copies of the selected object or objects, using the settings you select.                                                                                                                                                                                            |\n\n![](images/image33.png)\nThe Replicate dialog allows you to select how many copies of the currently selected object you would like. You can specify that each object is offset a number of pixels from the previous copy. You can also specify that each object is scaled up or down a number of pixels. If the object is an image or a graphic, each copy can be rotated by a specified number of degrees.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Select All**              | Selects all the text in the current field or all the controls on the current card.                                                                                                                                                        |\n| **Deselect All**            | Deselects any selected objects, or removes the insertion point from a field.                                                                                                                                                              |\n| **Invert Selection**        | Selects all the unselected objects and unselects all the selected ones. This item does not work on text selections.                                                                                                                       |\n| **Select Grouped Controls** | If this item is checked, clicking a control that's part of a group selects only that control. If unchecked, clicking a control that's part of a group selects the group.                                                                  |\n| **Intersected Selections**  | If this item is checked, dragging with the Pointer tool selects each object that intersects the dragged rectangle. If unchecked, dragging with the Pointer tool selects only objects that are entirely enclosed by the dragged rectangle. |\n| **Find and Replace...**     | Searches for and optionally replaces text in fields, properties, scripts, global variables, or button contents. For more details, see the section on *Find and Replace*.                                                                  |\n| **Preferences**             | Sets application-wide preferences. (Note that this item is available under the LiveCode menu when running on Mac OS X.)                                                                                                                   |\n\n### **The Tools Menu**\n\nThe Tools menu contains commands to work with LiveCode's tool palettes and to use stack development tools.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|----------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Browse Tool**            | Chooses the Browse tool for running a project. Allows you to perform user actions such as running scripts by clicking buttons, or entering text in a field.                                                                                                                                                                                                                                           |\n| **Pointer Tool**           | Chooses the Pointer tool for editing a project. Allows you to select, move, and resize objects.                                                                                                                                                                                                                                                                                                       |\n| **Tools Palette**          | Shows or hides the Tools palette for choosing tools for object creation.                                                                                                                                                                                                                                                                                                                              |\n| **Application Browser**    | Opens the Application Browser window, which lists all open stacks, the cards in each stack, and the controls on each card. For more details, see the section on the *Application Browser*.                                                                                                                                                                                                            |\n| **Menu Builder**           | Creates or changes the menu bar in the currently active stack. For more details, see the section on the *Working with Menus*.                                                                                                                                                                                                                                                                         |\n| **Database Query Builder** | Creates or edits settings for using an SQL database. Using the Database Query Builder, you can connect to a database and specify a SQL query to generate a cursor result set. Connection settings and cursor result sets can be linked to fields for display of the data, using the *Database* pane in the field's property Inspector. For more details, see the section on *Working with Databases*. |\n| **Message Box**            | Shows or hides the Message Box. The Message Box is a command line tool that allows you to run scripts or perform automated editing operations. For more details, see the section on *The Message Box*.                                                                                                                                                                                                |\n\n### **The Object Menu**\n\nThe Object menu contains commands to change the properties of the selected object or objects, to create new objects, and to work with groups.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Object Inspector**        | Opens the Inspector for the currently selected object, allowing you to view and set object properties. If more than one object is selected, changes made to the properties are applied to each of the selected objects. This item is disabled if no object is selected. For more details, see the section on *The Properties Inspector*.                                                             |\n| **Card Inspector**          | Opens the Inspector for the current card, allowing you to view and set card properties.                                                                                                                                                                                                                                                                                                              |\n| **Stack Inspector**         | Opens the Inspector for the current stack, allowing you to view and set stack properties.                                                                                                                                                                                                                                                                                                            |\n| **Object Script**           | Opens the Code Editor for the selected objects. If more than one object is selected, a script editor window opens for each one. For more details, see the section on *The Code Editor*.                                                                                                                                                                                                              |\n| **Card Script**             | Opens the Code Editor for the current card.                                                                                                                                                                                                                                                                                                                                                          |\n| **Stack Script**            | Opens the Code Editor for the current stack.                                                                                                                                                                                                                                                                                                                                                         |\n| **Group Selected**          | Makes the selected objects into a group. This item changes to \"Ungroup Selected\" if the only selected object is a group. For more details, see the section on *Groups and Backgrounds*.                                                                                                                                                                                                              |\n| **Ungroup Selected**        | Makes the selected group into individual objects. This removes the group permanently if you visit another card before grouping the objects again. This item changes to \"Group Selected\" if more than one object is selected.                                                                                                                                                                         |\n| **Edit Group**              | Enters group-editing mode to make changes to the objects in the selected group. This item changes to \"Stop Editing Group\" while in group-editing mode. This item is disabled if no object is selected, if more than one object is selected, or if the selected object is not a group.                                                                                                                |\n| **Stop Editing Group**      | Leaves group-editing mode. This item changes to \"Edit Group\" if the stack is not already in group-editing mode.                                                                                                                                                                                                                                                                                      |\n| **Remove Group**            | Removes the selected group from the current card, without deleting it from the stack.                                                                                                                                                                                                                                                                                                                |\n| **Place Group**             | Opens a cascading menu containing the names of groups that are in the stack but not on the current card. Choose a group to add it to the current card. This item is disabled if all the groups in the stack already appear on the current card, or if there are no groups. Note: Only the names of top-level groups are listed; groups that are a part of another group are not listed in this menu. |\n| **New Card**                | Creates a new card following the current card. Note: If there are any shared groups on the current card when you choose this menu item, they are automatically placed on the new card. If a group's backgroundBehavior is false, they are not placed automatically on new cards.                                                                                                                     |\n| **Delete Card**             | Deletes the current card from the front most stack.                                                                                                                                                                                                                                                                                                                                                  |\n| **New Control**             | Opens a cascading menu you can use to create a new control. For more details, see the section on *Control Types*.                                                                                                                                                                                                                                                                                    |\n| **Flip**                    | Opens a cascading menu you can use to change the orientation of the selected image or graphic. This item is disabled if any object other than an image or graphic is selected.                                                                                                                                                                                                                       |\n| **Horizontal**              | Swaps the left and right edges of the selected image or graphic, flipping it around an imaginary line drawn from top to bottom of the object.                                                                                                                                                                                                                                                        |\n| **Vertical**                | Swaps the top and bottom edges of the selected image or graphic, flipping it around an imaginary line drawn from left to right of the object.                                                                                                                                                                                                                                                        |\n| **Rotate**                  | Opens a cascading menu you can use to rotate the selected image or graphic.                                                                                                                                                                                                                                                                                                                          |\n| **By...**                   | Rotates the selected image or graphic by the number of degrees you specify.                                                                                                                                                                                                                                                                                                                          |\n| **90 Right**               | Rotates the selected image or graphic 90 degrees to the right (clockwise).                                                                                                                                                                                                                                                                                                                           |\n| **90 Left**                | Rotates the selected image or graphic 90 degrees to the left (counterclockwise).                                                                                                                                                                                                                                                                                                                     |\n| **180**                    | Rotates the selected image or graphic 180 degrees (halfway around).                                                                                                                                                                                                                                                                                                                                  |\n| **Reshape Graphic**         | Allows you to interactively reshape currently selected polygon or curve graphics.                                                                                                                                                                                                                                                                                                                    |\n| **Align Selected Controls** | Opens a cascading menu you can use to line up objects. This item is disabled if no object or only one object is selected.                                                                                                                                                                                                                                                                            |\n| **Left**                    | Moves the selected controls so their left edges are lined up with the left edge of the first control selected.                                                                                                                                                                                                                                                                                       |\n| **Right**                   | Moves the selected controls so their right edges are lined up with the right edge of the first control selected.                                                                                                                                                                                                                                                                                     |\n| **Top**                     | Moves the selected controls so their top edges are lined up with the top edge of the first control selected.                                                                                                                                                                                                                                                                                         |\n| **Bottom**                  | Moves the selected controls so their bottom edges are lined up with the bottom edge of the first control selected.                                                                                                                                                                                                                                                                                   |\n| **Make Widths Equal**       | Resizes the selected controls so that the width of each one is equal to the width of the first control selected.                                                                                                                                                                                                                                                                                     |\n| **Make Heights Equal**      | Resizes the selected controls so that the height of each one is equal to the height of the first control selected.                                                                                                                                                                                                                                                                                   |\n| **Send to Back**            | Moves the selected objects behind all other objects on the card. This item is disabled if no object is selected.                                                                                                                                                                                                                                                                                     |\n| **Move Backward**           | Moves the selected objects back one layer.                                                                                                                                                                                                                                                                                                                                                           |\n| **Move Forward**            | Moves the selected objects forward one layer.                                                                                                                                                                                                                                                                                                                                                        |\n| **Bring to Front**          | Moves the selected objects in front of all other objects on the card.                                                                                                                                                                                                                                                                                                                                |\n\n### **The Text Menu**\n\nThe Text menu contains commands to change the appearance of text.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Text Style Options** | Applies or removes the selected style from the selected text or the selected object. These items are disabled if nothing is selected.                                                                                                                                                         |\n| **Link**               | Makes the selected text, or all text in the selected object into a link. Linked text has special properties in LiveCode, for example linked text will receive a linkClicked message when clicked on. For more details, see the section on the *Field* object.                                 |\n| **Subscript**          | Moves the selected text below the baseline and makes it smaller.                                                                                                                                                                                                                              |\n| **Superscript**        | Moves the selected text above the baseline and makes it smaller.                                                                                                                                                                                                                              |\n| **Font**               | Opens a cascading menu you can use to change the font face used for the selected text or objects.                                                                                                                                                                                             |\n| **Use Owner's Font**   | Causes the font face of the object's owner (if an object is selected) or the object the text is in (if text is selected) to be used, removing any font face specific to the selected text or objects. For more information on font inheritance, see the section on the *Message Hierarchy*.   |\n| **Size**               | Opens a cascading menu you can use to change the font size used for the selected text or objects.                                                                                                                                                                                             |\n| **Use Owner's Size**   | Causes the font size of the object's owner (if an object is selected) or the object the text is in (if text is selected) to be used, removing any font size specific to the selected text or objects. For more information on font inheritance, see the section on the *Message Hierarchy*.   |\n| **Color**              | Opens a cascading menu you can use to change the font color used for the selected text or objects. (This item is disabled if nothing is selected.)                                                                                                                                            |\n| **Use Owner's Color**  | Causes the font color of the object's owner (if an object is selected) or the object the text is in (if text is selected) to be used, removing any font color specific to the selected text or objects. For more information on font inheritance, see the section on the *Message Hierarchy*. |\n| **Pen Color**          | Changes the selected text, or text used in any selected objects, to use the current pen color setting (used to draw graphics from the main tool palette).                                                                                                                                   |\n| **Align**              | Opens a cascading menu you can use to change the text alignment (justification) used for the text in the selected objects.                                                                                                                                                                    |\n\n### **The Development Menu**\n\nThe Development menu contains commands for debugging and for using custom tool stacks.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **LiveCode Online**       | Opens the LiveCode Online window, allowing you to share your stacks with the LiveCode community and download other peoples stacks.                                                                                                                                                                                                                            |\n| **Object Library**        | Displays the Object Library window, which stores pre-scripted objects you can copy into the current stack for use.                                                                                                                                                                                                                                             |\n| **Image Library**         | Displays the Image Library window, which displays images you can either reference or copy into the current stack for use. You can use the Image Library to show all the icons and cursors that come with LiveCode, all the images in the current stack, or image libraries that you create. For more details, see the section on the *Object & Image Library*. |\n| **Plugins**               | Opens a cascading menu you can use to open custom tool stacks stored in the Plugins folder.                                                                                                                                                                                                                                                                    |\n| **Plugin Settings**       | Customizes which messages are handled by the custom tool stacks stored in the Plugins folder.                                                                                                                                                                                                                                                                  |\n| **Script Debug Mode**     | If this item is checked, the debugger is enabled: the debugger window appears when a breakpoint is encountered during script execution, and you can enter the debugger when an execution error occurs. If unchecked, the debugger is disabled. For more details, see the section on *Debugging*.                                                               |\n| **Clear All Breakpoints** | Removes all breakpoints that you've used the Code Editor to mark, in all open stacks. Note: This menu item does not affect breakpoints set with the *breakpoint* command.                                                                                                                                                                                      |\n| **Message Watcher**       | Opens the Message Watcher window, used to view and track messages, function calls, getProp calls, and setProp triggers as they are sent to objects.                                                                                                                                                                                                            |\n| **Variable Watcher**      | Opens the Variable Watcher window, which you use to keep track of the value of variables during debugging. When the debugger is not open, the variable watcher shows the value of global variables.                                                                                                                                                            |\n\n> **Caution:** Warning: this feature will cause your scripts to fail silently instead of giving an error message in the event LiveCode encounters an error.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------------------|-------------------------------------------------------------------------------|\n| **Suppress Errors** | Prevents display of the error window when LiveCode encounters a script error. |\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Suppress Messages** | Prevents system messages (such as openCard and closeCard) from being sent during normal navigation. This option will also cancel any currently *pending* messages. |\n\n> **Tip:** To also suspend LiveCode libraries, hold down the Shift key while choosing this menu item.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Suspend Development Tools** | Hides LiveCode's menus, palettes, and other parts of the development environment, so that you can preview how your application will look and behave as a standalone, outside the development environment. |\n\n### **The View Menu**\n\nThe View menu contains commands to move around the current stack and to show or hide development tools.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Go First**                      | Goes to the first card in the current stack.                                                                                                                                                                                                                                                                                                                         |\n| **Go Prev**                       | Goes back to the previous card in the current stack.                                                                                                                                                                                                                                                                                                                 |\n| **Go Next**                       | Goes forward to the next card in the current stack.                                                                                                                                                                                                                                                                                                                  |\n| **Go Last**                       | Goes to the last card of the current stack.                                                                                                                                                                                                                                                                                                                          |\n| **Go Recent**                     | Goes back to the card you were on before navigating to the current card.                                                                                                                                                                                                                                                                                             |\n| **Toolbar Text**                  | Shows or hides the text labels in the Toolbar at the top of the screen. To hide the Toolbar completely, uncheck both this item and \"Toolbar Icons\".                                                                                                                                                                                                                  |\n| **Toolbar Icons**                 | Shows or hides the icons in the Toolbar at the top of the screen.                                                                                                                                                                                                                                                                                                    |\n| **Palettes**                      | Shows or hides all open LiveCode palettes.                                                                                                                                                                                                                                                                                                                           |\n| **Rulers**                        | Shows or hides a ruler at the left and bottom edges of each open stack.                                                                                                                                                                                                                                                                                              |\n| **Grid**                          | If this item is checked, dragging and resizing objects is constrained by a pixel grid. If unchecked, you can drag and resize objects to any location. You can alter the grid spacing in Preferences.                                                                                                                                                                 |\n| **Backdrop**                      | Shows or hides a solid or patterned backdrop behind LiveCode's windows.                                                                                                                                                                                                                                                                                              |\n| **LiveCode UI Elements in Lists** | If this item is checked, elements of the LiveCode development environment appear in lists: for example, development environment stacks appear in the Application Browser, and LiveCode custom properties appear in the Custom Properties pane of the property inspector. If unchecked, elements of the LiveCode development environment do not appear in such lists. |\n| **Look and Feel**                 | Opens a cascading menu you can use to change the appearance of controls in order to preview your application's appearance on other platforms.                                                                                                                                                                                                                        |\n| **Show Invisible Objects**        | If this item is checked, objects whose visible property is set to false are shown. If unchecked, objects whose visible property is set to false remain hidden.                                                                                                                                                                                                       |\n\n### **Window**\n\nThe Window menu contains the names of open stack windows.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Send Window To Back** | Shuffles the frontmost stack window to the back and brings the second window to the front. (This item is disabled if only one stack is open or the active window is not a stack.) |\n\n### **The Help Menu**\n\nThe Help menu contains commands which allow you to find out more about using LiveCode, license your copy of LiveCode, get technical support via email, and check the LiveCode site for software updates. For more information, see the section on *Using the Documentation*.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Documentation**       | Opens the main LiveCode documentation window, where you can get information about all aspects of developing in LiveCode.                                                                                                                                       |\n| **Buy a license**      | Loads the LiveCode store in your web browser.                                                                                                                                                                                                                  |\n| **Support**            | Loads the support section of the LiveCode web site in your web browser.                                                                                                                                                                                        |\n| **Check for Updates**  | Checks online to see if an update to LiveCode is available.                                                                                                                                                                                                    |\n| **Manage Versions **   | Allows you to select a different version of LiveCode to be your default version. The default version is the version linked to from the shortcut placed within the first level of your LiveCode install folder, and/or on the Desktop and/or in the Start Menu. |\n| **Re-license LiveCode** | Deletes your LiveCode licensing information and restarts LiveCode allowing you to enter a new license key.                                                                                                                                                     |\n\n## The Application Browser\n\nThe Application Browser contains a list of all open stacks, the cards in each stack, and the controls on each card. It allows you to navigate to any card, open or close a stack, select, open the property Inspector for, or edit the script of any object.\n\nYou can access the Application Browser by choosing **Tools -\\> Application Browser**.\n\n![](images/image34.png)\n\nFigure 5  Application Browser: main window\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------|-------|-------|\n| **Left header bar** | Displays the name of the stacks and their associated cards, together with the object number and the number of lines of script for that card or stack.<br><br>Clicking in this area will sort the cards by the column header clicked on.<br><br>Right-clicking allows you to customize the columns on display, optionally adding columns to display the object ID or cards marked property, or allowing you to reset the columns to default<br><br>Clicking and dragging between the column headers allows you to resize the columns.                                                                                                    |\n| **Stack components list** | Displays all the stacks (mainStacks and subStacks) within open stack files.                                                                                                                  <br><br>Click the fold out symbol to the left of the stack to view a list of cards, audioClips and videoClips associated with the stack.<br><br>Double-clicking will go to the stack or card selected, or play the audio or video clip.<br><br>Right-click to open object context sensitive menu<br><br>Alt-double-click to open the objects Inspector.<br><br>Control-double-click to edit the script.                                                                                                                                                       |\n| **Resize bar**            | Drag to alter width of the left and right sides.                                                                                                                                              |\n| **Right header bar**      | Displays the object type, visibility, selectability, layer, name, and number of lines of script.<br><br>Clicking in this area will sort the objects by the column header clicked on.<br><br>Right-clicking allows you to customize the columns on display, optionally adding columns to display the object ID, or allowing you to reset the columns to default.<br><br>Clicking and dragging between the column headers allows you to resize the columns.                                                                                                             |\n| **Card controls list**    | Displays a list of controls on the card selected on the left, or list of audio or video clips.<br><br>Click an object to select it.<br><br>Right-click to open the objects context sensitive menu. Double-click to open a controls Inspector or to play an audioClip or videoClip.<br><br>Alt-double-click to open the Inspector for an audioClip or videoClip.<br><br>Control click to select multiple objects.<br><br>Control-double-click to edit script.<br><br>To Refresh the list of controls currently displayed on the right hand column, right-click on an object then choose Refresh.                                                                    |\n\n> **Tip:** To select an object by typing its name, click in either the left hand or right hand column and then start typing.\n\n![](images/image35.png)\n\nFigure 6  Application Browser: stack context-sensitive menu\n\n**Go:** Go to this stack.\n\n**Toplevel:** Bring this stack to front in editable mode.\n\n**Property Inspector:** Open the Inspector for this stack.\n\n**Edit Script:** Edit script of this stack.\n\n**New Substack:** Create a subStack within the same file as this stack.\n\n**Delete subStack:** Delete this subStack.\n\n**Close and Remove From Memory:** Close and remove the mainStack and all subStacks in this file from memory.\n\n**Save:** Save all stacks in this stack file.\n\n**Standalone Application Settings:** Open the Standalone Settings options.\n\n**Save as Standalone Application:** Save this stack file as a standalone application.\n\n![](images/image36.png)\n\nFigure 7 Application Browser: card context-sensitive menu\n\n**Go:** Navigate to this card\n\n**Toplevel:** Bring stack to front in editable mode, then navigate to this card\n\n**Select:** Select this card\n\n**Property Inspector:** Open the Inspector window for this card\n\n**Edit script:** Edit script of this card\n\n**New Card:** Create a new card\n\n**Delete Card:** Delete this card\n\n![](images/image37.png)\n\nFigure 8  Application Browser: control context-sensitive menu\n\n**Property Inspector:** Open the Inspector window for this control\n\n**Edit script:** Edit script of this card\n\n**Refresh:** Update the list of controls\n\n## \n## The Properties Inspector\n\nThe Properties Inspector allows you to view and edit the properties for any selected object. Properties control how an object looks and some aspects of an objects behavior. The Inspector can be accessed by double clicking on a selected object, from the toolbar, from the *Object* menu and from context sensitive menus.\n\n![](images/image38.png)\n\nFigure 9 - Properties Inspector\n\n| &nbsp;| &nbsp;|\n|-------|-------|\n| **Lock icon** | The Lock icon locks the Inspector to the object currently being inspected. Once locked, the Inspector will not update when you change selection or switch to *Run* mode by choosing the *Browse tool*. This allows you to used a locked Inspector to change an objects properties while interacting with your project. Selecting another object and choosing Inspect will create another Inspector to inspect the new object. You can use this facility to compare the properties of two objects. |\n| **Pane Selector** | This menu allows you to access each of the different panes within the inspector for a given object.                                                                                                                                                                                                                                                                                                                                                                                                |\n| **Action menu** | Use the Action menu to Select another Object, Change the Profile, Edit the Script or Send a Message to the object currently being inspected, or to Lock the Inspector.                                                                                                                                                                                                                                                                                                                             |\n| **Property text** | Edit the contents of a property by typing into the text area within the Inspector. Press return to set the property and leave the current option selected. Press tab to set the property and move on to the next editable text property.                                                                                                                                                                                                                                                           |\n| **Property description** | This text describes the object property. By default this text is an English-like description of the property. However you can change this to contain the Name of the LiveCode Property in the Preferences. You may prefer to view the LiveCode Property names if you are writing scripts that set object properties.                                                                                                                                                                               |\n\n> **Important:** For documentation on what each individual object property does, hover the mouse over the object until you see the script property equivalent. Then look that term up in the LiveCode Dictionary.\n\n## The Code Editor\n\nThe Code Editor within LiveCode has been designed specifically for LiveCode coding. It includes features to help make code more understandable. These include code indentation and color coded syntax highlighting, as well as other integrated tools such as a Debugger and syntax Dictionary. You can access the Code Editor for an object by selecting the object then choosing Script from the Tool bar. The Code Editor is also available from the Object menu, and from a number of other context sensitive menus detailed elsewhere in this guide. Each of the Code Editor's components are outlined below.\n\n![](images/image39.png)\n\n**Main Script Area**\n\nDisplay and edit scripts in this area. For more details on how to write a script, see the section on Coding in LiveCode. The Code Editor will colorize and format scripts automatically. When typing press tab to manually format the script. Press Enter (on the numeric keypad) to compile the script. Press Enter again to close the Code Editor.\n\n> **Note:** It is not necessary to close the Code Editor to run a script, all that is required is that the script is applied using the Compile button.\n\n**Breakpoints Area**\n\nClick next to a line of script to set or remove a breakpoint. A breakpoint specifies a point at which script execution should pause and the debugger be loaded. For more details, see the section on Debugging.\n\n**Compile Button**\n\nCompiles the script instantly. Any syntax errors will appear in the Error Display and the script will not compile. A compiled script is not saved until the stack that contains it is saved.\n\nPress *Enter* (on the numeric keypad) to activate the Compile button. Press *Enter* again to close the Code Editor.\n\nNote that *none* of the message handlers within the script will be available if there is a Script Error during compilation, as none of the script will have compiled.\n\n**The Error Watcher**\n\nCompile and execution errors will appear here. Double click the icon next to the error details to highlight the line the error occurred on in the script (if applicable).\n\n![](images/image40.png)\n\n**Handler List**\n\nThe handler list displays all the functions, commands and handlers which are part of the current script. When a handler name is clicked, the script will jump to that handler.\n\n**Documentation**\n\nThe Code Editor also has a built-in syntax dictionary. When this tab is active a summary of the dictionary entry for the keyword which you are currently typing will be displayed. The full dictionary entry can be viewed by clicking Launch Documentation. Alternatively you can choose to view the entire entry in place by toggling the Full Document check box at the bottom of the documentation pane.\n\n![](images/image41.png)\n\n**Search Results**\n\nWhen you perform a 'find all' operation the results will be displayed under this tab.\n\n![](images/image42.png)\n\n**Script Tabs**\n\nWhen multiple scripts are open they will appear as tabs in the Code Editor. Right clicking on the tabs brings up a menu which allows a tab to be moved to a new window, closed, or kept while closing all other tabs. Clicking a tab will bring up the script it represents.\n\n## The Debugger\n\nThe Debugger helps you track bugs and understand code, by allowing you to pause the execution of your programs or step through them line by line. You cause execution to pause by setting breakpoints. When you run your script, execution will pause at a breakpoint and you will be able to observe or edit variable values, continue execution or set another breakpoint later in the code. Each debugger feature is outlined below:\n\n![](images/image43.png)\n\n**Continue**\n\nWhen in debug mode, the Continue button will start running the code from the current position. The program will run until the end is reached or another breakpoint is found.\n\nWhen you are not in debug mode, the continue button can be used to execute a handler. When you press it, a dialog will appear asking which handler you would like to call and, if applicable, which parameters you'd like to pass. On clicking OK the Code Editor will call the handler you specified. It will also remember the handler for next time. To change the handler called later, choose Entry Point from the Debug menu.\n\n**Stop Debugging**\n\nWill halt execution at the current point and stop debugging. You will then be able to edit the script.\n\n**Show Next Statement**\n\nThe Show Next statement option will return the debugger to the currently executing statement. This is useful if you have switched tabs or scrolled during debugging.\n\n**Step Into Next Statement**\n\nUse Step Into to execute the next statement. If the next statement is a command or function Step Into will jump to that function or command allowing you to execute it line by line.\n\n![](images/image44.png)\n\n**Step Over Next Statement**\n\nUse Step Over to execute a command or function call without stepping through it line by line. The code within the handler will run at full speed and execution will pause on the line after the handler call.\n\n![](images/image45.png)\n\n**Step Out**\n\nThe Step Out function allows you to exit a command or function that you have previously stepped into. When selected, the rest of the current handler will run and execution will pause on the line after the handler call. This is useful to avoid stepping through a long command or function line by line when you have identified that the error you are looking for is not within that command or function.\n\n![](images/image46.png)\n\n**Debug Context**\n\nThe Debug Context shows you the path of execution up to the current statement you are paused on in the debugger. This allows you to identify where you are in your program and which handlers called the current handler you are in. Changing the debug context allows you to view variables from different parts of the program. Use this feature to find an erroneous command call or a call where wrong parameters were used.\n\n**Variable Watcher**\n\nThe Variable Watcher tab allows you to examine the value of variables within your program while it is executing. As you step through your code these values will be updated. The variable name is shown in the left column and its value adjacent on the right. If a variable's value is too large to be displayed in the pane it will have a magnifying glass next to it. Clicking this will bring up a watch window which allows the variable's value to be changed. Variables can also be edited by double clicking on their value in the variable watcher.\n\n> **Tip:** You can see the value of a variable by moving the mouse over the variables name in the script field while debugging.\n\n**Breakpoint Management**\n\nUse breakpoints to specify where to pause execution in the debugger. You set breakpoints by clicking in the gutter, or by right clicking in the Breakpoint Manager at the bottom of the Code Editor and selecting New Breakpoint. Each breakpoint is associated with a line of code and execution is paused when that line is reached. Alternatively, a condition can be assigned to the breakpoint. In this case, execution will only pause if the condition is true when the line is reached.\n\n![](images/image47.png)\n\n> **Tip:** To see a list of all the breakpoints within a stack, including the script they are in, which line they are on, and whether there is a condition attached, click the Breakpoints Manager at the bottom of the Code Editor. The check box to the left of each breakpoint can be used to enable or disable the breakpoint. Double click a breakpoint to go to that line in the associated object's script. To edit a breakpoint, including adding a condition or changing the line number, click the pencil icon.This can also be done by right-clicking on the breakpoint, either in the Breakpoints Manager, or the Code Editor's gutter.\n\n![](images/image48.png)![](images/image49.png)\n\nThe Breakpoint Manager also allows you to set watches. These are associated with variables rather than lines of code and will pause execution when the value of the variable you are watching changes. Alternatively, if the watch has a condition attached, execution will only pause if, when the variable's value is changed, the condition is true. To add a watch, right click in the Breakpoint Manager and choose New Breakpoint.\n\n![](images/image50.png)\n\n## The Code Editor Menubar\n\nThe Code Editor menubar contains commands to help you edit scripts.\n\n### The File Menu\n\nThe File menu contains commands to print a script or close the Code Editor, with or without saving changes to the script.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------|------------------------------------------------------------------|\n| **Compile** | Compiles the current script.                                     |\n| **Save**    | Saves the current stack.                                         |\n| **Close**   | Closes the current script.                                       |\n| **Print**   | Prints the current script.                                       |\n| **Quit**    | Exits LiveCode. Will prompt you to save your work if applicable. |\n\n### The Edit Menu\n\nIn addition to the standard commands to select, cut, copy and paste text, the Edit menu contains the following, script-specific commands:\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Revert**            | Takes any changes which haven't been compiled, and removes them from the current script.                                                                                                                                                                                                                                 |\n| **Comment**           | Places a comment character at the beginning of the selected text. If more than one line is selected a comment character is placed at the beginning of each line.                                                                                                                                                         |\n| **Uncomment**         | Removes comment characters from the selected text.                                                                                                                                                                                                                                                                       |\n| **Quick Find**        | Opens the find field within the Code Editor.                                                                                                                                                                                                                                                                           |\n| **Find and Replace** | Brings up the Code Editor's find and replace dialog.                                                                                                                                                                                                                                                                     |\n| **Go**                | Brings up a dialog box which lets you enter a line number to jump to in the script.                                                                                                                                                                                                                                      |\n| **Variable Checking** | Variable checking causes LiveCode to perform a stricter check of your scripts. Using any variable without declaring it first, or using a literal string without encloning it in quotes causes a compile error. This behavior can be useful in tracking down certain subtle problems such as misspelling a variable name. |\n\n### The Debug Menu\n\nThe Debug menu contains commands to aid in debugging scripts:\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------------|-----------------------------------------------------------------------------------------------------------------------------------|\n| **Show Next** | Highlights the next line of code to be executed. This is useful if you have changed tab or scrolled your script during debbuging. |\n\n| &nbsp;| &nbsp;|\n|---------------|--|\n| **Step Into** | Executes the next line of the handler being debugged. If the next line is a call to another handler, this command steps into that handler. This menu item is disabled if the debugger is not running. |\n\n> **Tip:** Press F11 to step into the next line.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Step Over** | Executes the next line of the handler being debugged. If the next line is a call to another handler, this command steps over that call, skipping it and staying within the current handler. |\n\n> **Tip:** Press F10 to step over the next line.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------|----------------------------------------------------------------------------------------|\n| **Run** | Resumes normally executing the handler being debugged, starting from the current line. |\n\n> **Tip:** Press F5 to activate the Run button.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------|-------|\n| **Abort** | Stops running the handler being debugged. |\n\n> **Tip:** Press control-period (or command-period) to activate the Abort button.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Toggle Breakpoint** | Adds/removes a breakpoint from/to the currently selected line.                                                                                                                                                                                                                                            |\n| **Variables**         | Changes the tab view at the bottom of the Code Editor to the Variable Watcher tab.                                                                                                                                                                                                                        |\n| **Breakpoints**       | Changes the tab view at the bottom of the Code Editor to the Breakpoint Manager.                                                                                                                                                                                                                          |\n| **Entry Point**       | Lets you define which handler execution should begin at when debugging a script.                                                                                                                                                                                                                          |\n| **Script Debug Mode** | If this item is checked, the debugger is enabled: the execution of the program will pause when a breakpoint is encountered during script execution, and you can enter the debugger when an execution error occurs. If unchecked the debugger is disabled. For more details, see the section on Debugging. |\n\n### The Handler Menu\n\nThe Handler menu contains a list of all handlers in the current script. Choose a handler to go to that handler in the script.\n\n### The Window Menu\n\nThe Window menu contains the names of open script editor windows.\n\n## The Message Box\n\nThe Message Box is a command line tool that allows you to run scripts or perform automated editing operations. It allows you to try out short scripts, test parts of your program, provides a convenient output window for debugging and can be used for editing and setting properties.\n\n> **Tip:** The Message Box is one of the more useful components in LiveCode when you are starting out and wanting to try out simple scripts. You will find you can try out many of the script examples in this User's Guide or in the getting started materials on our website simply by copy-pasting them into the Message Box.\n\nThe message box has the following modes:\n\n**Single Line**  execute single line and short scripts\n\n**Multiple Lines**  execute multiple line scripts\n\n**Global Properties**  view and edit global properties\n\n**Global Variables**  view and edit global variables\n\n**Pending Messages**  view, cancel and edit pending messages\n\n**Front Scripts**  view and edit frontScripts\n\n**Back Scripts**  view and edit backScripts\n\n### Single and Multiple Line Modes\n\nUse the Single and Multi-Line modes to execute short scripts.\n\n![](images/image51.png)\n\nFigure 10  The Message Box in Single Line Mode\n\n| &nbsp;| &nbsp;| &nbsp;|\n|--------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Command area**   | Type valid LiveCode code into this area. In *Single Line* mode, separate multiple lines with **;** (semi-colon) and press *Return* to execute. In *Multiple Line* mode, press return to separate lines, and press *Enter* to execute.<br><br>For example, in Single Line mode, to move all controls on the current card 10 pixels to the left you would run:                                                                                                                                                                                                                                                                                                                                        `repeat with i = 1 to the number of controls`;` move control i relative 10,0`;`end repeat`<br><br>In Multiple Line Mode:`repeat with i = 1 to the number of controls`<br><br>`move control i relative 10,0`                                                                                                                                                                                                                                                                                                                                                                                                                        <br><br>`end repeat`<br><br>Type **control-m** to focus the command area and start typing, whenever the Message Box does not have the focus. Press **control-u** when typing to clear the command area.<br><br>In *Single Line* mode press the **Up Arrow** key to cycle backwards through the history of previously entered and executed scripts. Press the **Down Arrow** key to cycle forwards. In *Multiple Line* mode, press **alt-up arrow** or **alt-down arrow** to cycle forwards or backwards, respectively. Press **control-u** to clear the current command area.<br><br>Typing the name of a global variable or property on its own will result in the line being auto-completed to include **put** in front of the global variable or property, thus the contents of that global will be placed into the results area. For example typing:<br><br>`time`<br><br>Will be auto completed to:                                                                                                                                                                                                                                                                                                                                                                                                                             <br><br>`put the time`<br><br>The current time will be placed in the results area.                                                                                                                                                                                                                                                                                                                                                                                                   |\n| **Results area**   | Displays:<br><br>The *result* function after running code in the *command area*.                                                                                                                                                                                                                                                                                                                                                                                        <br><br>Any script that uses the **put** command without a destination container.<br><br>Any script compile error created as a result of attempting to run code placed in the command area.<br><br>Any execution error created as a result of attempting to run code placed in the command area.<br><br>The **msg** special global will be updated whenever anything is placed in the results area, either by script or by directly editing the content of the results area. You can set or retrieve the content of this variable in any script. For example, try running the following in the command area:<br><br>`put the clipBoardData; replace return with return & return in msg`<br><br>The result placed into the results area will contain the current contents of the clipboard, with every return character replaced with a second return character.                                                                                                                                                                                                                                                                                       |\n| **Stack selector** | Select a stack to work on. Prior to executing any script the *defaultStack* will be set to the stack displayed in this menu. By default the Message Box will choose the front most editable stack. The menu is updated whenever you change the front most stack or click on the Message Box. You can use this menu to choose an alternative open stack. For example, running the following script in the command area of the single line message box:<br><br>`put the number of controls`<br><br>Would place the number of controls in the current card of the *stack displayed in the menu*, into the results area.                                                                                                                                                                                                                                                                                                                                    |\n| **Intelligence**   | The Message Box will attempt to auto complete the typing of a name of an object property, resulting in putting the contents of that property into the results area. You can choose whether the auto-complete should attempt to use the currently selected object, or the object directly underneath the mouse. For example, with an object selected, entering:<br><br>`width`<br><br>Will result in:<br><br>`put the width of the selObj`<br><br>The width of the currently selected object will be placed in the results area. The `selObj`will be substituted with the `mouseControl`if you choose this option. In the example above, that would result in the width of the object underneath the mouse being placed in the results area instead. For more details on the `selObj`function or the `mouseControl`functions, see the LiveCode Dictionary.                                                   |\n| **Lock icon**      | This option prevents the Stack selector from updating automatically when you change stacks. Use this option if you want to run a number of commands on a specific stack regardless of which stack is currently in front.                                                                                                                                                                                                                              |\n\n### Global Properties\n\nThe Global Properties mode allows you to view and edit all global properties. Scroll to select a property from the list on the left and select it to view or edit it. Typing a portion of the property name into the Filter field at the top will filter the list of properties. Changes to global properties take effect immediately. If a property is read only this will be indicated when you select it and editing it will have no effect. For more details on Global Properties, see the section on *Global Properties.*\n\n### Global Variables\n\nThe Global Variables mode allows you to view and edit all global variables. Environment variables are shown first, followed by other variables. Scroll to find a variable from the list on the left and select it to view or edit it. Typing a portion of the variable name into the Filter field at the top will filter the list of variables. Changes to global properties take effect immediately. The Show LiveCode UI Variables is an advanced option, discussed in the section on Editing the LiveCode User Interface. For more details on Global Variables, see the section on *Global Variables*.\n\n### Pending Messages\n\nThe Pending Messages mode allows you to view all the current timer based messages that are pending. This is the same as the global property the pendingMessages*.* You can select a pending message to edit its script or cancel it.\n\n> **Tip:** You can cancel all current pending messages using the **Suppress Messages** button on the toolbar.\n\nPressing update refreshes the list with the current list of pending messages. The Auto Update mode refreshes the list continuously. Note that the Auto Update takes place every 200 milliseconds. If your messages fire more quickly they may not be displayed. For more details on Pending Messages, see the section on *Timer Based Messaging*. The Show LiveCode UI Messages is an advanced option, discussed in the section on *Editing the LiveCode User Interface*.\n\n### Front Scripts & Back Scripts\n\nThese modes list all the scripts currently available as libraries at the front or back of the message path. This is the same as the global properties `the frontScripts`and the `backScripts`. Select a front or back script to remove it or edit its script. For more details on library scripts, see the section on *Extending the Message Path*. The Show LiveCode UI Scripts is an advanced option that displays all of the libraries used by the LiveCode IDE. This is discussed in the section on *Editing the LiveCode User Interface*.\n\n### Stacks In Use\n\nThis mode is the same as the Front and Back scripts mode, except that it displays the `stacksInUse`global property. You can also add a stack directly using the Add button.\n\n## The Toolbar\n\nThe main toolbar provides easy access to commonly used functions.\n\n![](images/image52.png)\n\nFigure 11  The Main Toolbar\n\nFor details on what each toolbar icon does, see the section on the Menu Bar (above).\n\nTo hide and show the text or icons on the tool bar, use **View -\\> Toolbar Text** and **View -\\> Toolbar Icons**. To hide the Toolbar completely, uncheck both options.\n\n## Find and Replace\n\nThe Find and Replace dialog allows you to search your entire application, a portion of the application, multiple files in a directory, or stacks specified in your applications **stackFiles** property. You can search for object names, scripts, field & button text, custom properties, and other properties. After performing a search you can replace the search term with a replacement term, either in all of the results or on a selection of the results.\n\n![](images/image53.png)\n\nFigure 12  Find and Replace\n\n| &nbsp;| &nbsp;| &nbsp;|\n|--------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Find field**     | Enter a search term.                                                                                                                                                                                         |\n| **Search In menu** | A menu with the following options:<br><br>**The current selection**  Searches the currently selected objects<br><br>**This card**  Searches the current card of the front most editable stack<br><br>**This stack**  Searches the front-most editable stack<br><br>**This stack File**  Searches the mainStack and all of the subStacks within the stack file associated with the current front most editable stack<br><br>**This stack file and its stack files**  Includes the stacks referenced in this stacks stackFiles property. For more details on the stackFiles property, see the section on *Structuring Your Application*.<br><br> > **Important:** StackFiles are normally set on the mainStack of your application. Ensure that you bring the mainStack to the front before searching its stackFiles. If you search using this option when a subStack is in front, your search will not include any stackFiles.<br><br>**All open stacks**  Searches all open stack files that are currently on screen<br><br>**All open stack files**  Searches all open stacks, including all mainStacks and subStacks in each file<br><br>**Specific open stack file**  Allows you to select a specific open stack file to search<br><br>**All stack files in a folder**  Searches all the stacks in a folder you specify<br><br>**Global variable contents**  Searches the contents of currently declared global variables |\n| **Find button**    | Performs the search |\n| **Case Sensitive** | Specifies that the search should be case sensitive (e.g. \"a\" and \"A\" are treated as different characters) |\n| **Regular Expression**                   | Specifies that the Find Field contains a regular expression instead of plain text. A regular expression allows you to describe a pattern of text to match. For more details on using regular expressions, see the section on *Using Regular Expressions* below. |\n| **Obey dontSearch properties**           | Specifies that fields, cards or groups with their dontSearch property set to true should be excluded from the search. For more details on the *dontSearch* property, see the LiveCode Dictionary.                                                               |\n| **Search marked or unmarked cards only** | Specified that the search should be restricted to either marked or unmarked cards. For more details on marked and unmarked cards, see *mark* in the LiveCode Dictionary.                                                                                        |\n| **Search in**                           | Allows you to specific which object properties to search:                                                                                                                                                                                                       |\n| **Name**                                 | Searches an objects *short name* property.                                                                                                                                                                                                                     |\n| **Script**                               | Searches an objects *script* property.                                                                                                                                                                                                                         |\n| **Custom**                               | Searches and objects custom properties and custom property sets. For more details on Custom properties, see the section on *Custom Properties*.                                                                                                                 |\n| **Field Text**                           | Searches within field text.                                                                                                                                                                                                                                     |\n| **Button Text**                          | Searches button text. This includes text in menus. For more information on buttons and menus, see the section on *Control Types*.                                                                                                                               |\n| **All Other**                            | Searches all other commonly used object properties. For more details on exactly what is included, see the *properties* entry in the LiveCode Dictionary.                                                                                                        |\n| **Results column header**                | Allows you to sort search results by clicking. Drag between the column headers to change column widths.                                                                                                                                                         |\n| **Search Results Area**                  | Displays a list of objects that match the search parameters.                                                                                                                                                                                                    |\n| **Remove from List**                     | Removes the currently selected search result in the Search Results area from the list. Once removed, the object will no longer be included in any replace operation.                                                                                            |\n| **Replace With**                         | Specifies a term to use to replace the search term with.                                                                                                                                                                                                        |\n| **Replace in All**                       | Replaces the Find Field with the Replace With field in all objects currently listed in the Search Results Area.                                                                                                                                                 |\n\n# Building a User Interface\n\nThe user interface for your application is often one of its most important features. Building a clear, logical and aesthetically pleasing user interface will make all the difference to the success of your application. This chapter discusses how to build a user interface using LiveCode. It tells you how to create and lay out controls, which objects to use and even how to build your own custom objects. We then touch briefly on some tips for good user interface design.\n\n## Creating and Organizing Objects\n\n### Creating Controls with the Tools Palette\n\nThe main tools palette allows you to change between Edit and Run mode, create objects, and edit bitmap images with the paint tools.\n\n![](images/image54.png)\n\nFigure 13 - The Main Tools Palette\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Run mode**          | Click to enter run mode. When in run mode, objects receive all the normal messages that drive a LiveCode application. For example, clicking on a button in run mode will cause a **mouseUp** message to be sent to it and the script will run.                                                                                                                                                                                                                             |\n| **Edit mode**         | Click to enter edit mode. When in edit mode, objects do not receive messages when you click on them, and you can move, resize or edit the properties for objects.                                                                                                                                                                                                                                                                                                          \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n| |                         For more details about the run and Edit mode, see the section *The Edit and Run Mode*.                                                                                                                                                                                                                                                                                                                                                                                  |\n| **Button objects**    | Drag any object within these areas onto an editable stack to create a new object. Double-click an object to create a object of that type in the center of the front most editable stack.     \n| |                        \n| |                          *For more details on all of these objects, see the section about each object type later in this chapter.* | \n|  **Field objects**    | |                            \n|  **Menu objects**     | |                           \n|  **Scrollbar objects**  | |                        \n|  **Image & Player**   | |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| **Vector Graphics**   | Press the grey triangle at the bottom right of the Image & Player area to hide and show this section. Click to choose the type of new graphic you want to create. Use the fill bucket to choose the fill color, the fill pencil to choose the line color, the line thickness menu to choose the line thickness, and the optional shape menu to choose preferences specific to the type of graphic selected. Click and drag in an editable stack to create the new graphic. |\n| **Bitmap graphics** | The paint tools allow you to edit bitmap graphics that have been imported into LiveCode or create your own. To use them, create an image object and paint within that area, or modify an existing image. You cannot use the paint tools to edit an image that has its filename property set, as that image data is stored outside LiveCode. For more details on working with images, see the section on *Images* later in this chapter and the chapter on *Working with Media*. |\n\n> **Tip:** You can also create objects using the **New Control** sub-menu in the Object menu, or by typing **create [object type]** in the Message box. For more information on creating objects using the Message Box, see the section on *Building Interfaces Using Scripts*, later in this chapter.\n\nTo open a system-standard color chooser, double-click on color chooser popup menus at the bottom of the Vector Graphics or Bitmap Graphics sections of the tools palette.\n\n### Alignment & Layering\n\n![](images/image55.png)\n\nFigure 14  Size & Position Inspector\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Lock size and position**    | Locks the object so that its size and position cannot be adjusted interactively with the mouse when in edit mode. This also prevents images, groups and players from automatically resizing to display their entire content whenever the card that they are on is reopened. For more details see the entry for *lockLocation* in the LiveCode Dictionary.                                                                                                                                                                                                                                                                |\n| **Width & Height**            | Allows you to set the width and height of the object(s) currently being operated on by the Property Inspector. Objects are resized from their center. For more details, see the *width* and *height* properties in the LiveCode Dictionary.                                                                                                                                                                                                                                                                                                                                                                              |\n| **Fit Content**               | Automatically sizes the object large enough to display its content. In the case of buttons, the content is the text and any icon. For images, this is the native width and height of the original image before any scaling. For more details, see the entry for *formattedWidth* and *formattedHeight* in the LiveCode Dictionary.                                                                                                                                                                                                                                                                                       |\n| **Location**                  | Sets the objects position (the center of the object) relative to the top left of the card.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| **Left, Top, Right & Bottom** | Sets the position of one of the objects edges.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| **Layer**                     | Sets the layer of the object. The buttons with arrows allow you to send an object to the back, move an object back one layer, bring an object forward one layer and bring an object to the front. Layer determines which objects are displayed in front or behind others, as well as the objects number and tabbing order. Note that you cannot relayer objects that are grouped unless you are in edit background mode, or have the *relayerGroupedControls* set to true. For more details, see the section on *Group & Backgrounds*. For more details on tabbing order see the section on *The Keyboard Focus* below. |\n\nUse the Align Objects Inspector to resize objects relative to other objects, to reposition objects and/or to relayer objects.\n\n![](images/image56.png)\n\nFigure 15  Align Objects Inspector\n\nTo open the Align Objects Inspector, select multiple objects, then open the Inspector and choose Align Objects from the menu at the top of the Inspector. The Align Objects pane will automatically be displayed if you select multiple objects of different types.\n\n> **Important:** The Align Objects Inspector resizes objects relative to each other. Always select the object you want to use as a reference first, then select other objects that you want to make the same as that object next. If you want to distribute objects, select them in the order that you would like them to be distributed.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Equalize**   | Make objects the same width, height, or have exactly the same rectangle.                                                                                                                                                                                                                                                                                                                  |\n| **Align**      | Aligns the objects by their left, right, top or bottom edges, or by their horizontal center or vertical center, using the first object selected as a reference.                                                                                                                                                                                                                           |\n| **Distribute** | Distributes the objects with an equal difference between them, using the order they were selected. First to last selected will distribute objects evenly between the edges of the first and last objects selected. Edge to edge will distribute the objects so that their edges touch each other exactly. Across card will distribute the objects evenly over the entire card area. |\n| **Nudge**      | Nudge the selected object the number of pixels specified in the center of the arrows. To change the number of pixels, click on the number.                                                                                                                                                                                                                                                |\n| **Relayer**    | First to last selected will relayer the objects in the selection in the order they were selected. 'Last to first\" will relayer the objects in reverse order. Use these buttons to set the tab order of a set of objects. For more information on the tabbing order, see the section on *The Keyboard Focus* below.                                                                      |\n\n### The Keyboard Focus\n\nThe focus is an indication to the user of which control will receive a keystroke. Exactly which objects are capable of receiving the keyboard focus depend on the current operating system, and the properties applied to the control. Edit fields can receive the focus, as can all other objects on Windows and Linux, and many objects on Mac OS.\n\nThe order in which the user moves through controls that can receive the keyboard focus is determined by the objects layer. When a card is opened, LiveCode automatically focuses the first object on the card that is capable of receiving the keyboard focus.\n\nYou can turn on the ability of an object to get the keyboard focus by checking the *Focus with Keyboard* option in the objects Inspector, or by setting its *traversalOn* property by script.\n\nOn some platforms objects give an indication that they have the focus by displaying a border. You can specify whether a border should be displayed by setting an objects Show Focus Border option in the Inspector, or setting its *showFocusBorder* property by script.\n\n## Object & Control Types\n\n### Stacks  for displaying windows, palettes and dialog boxes\n\nIn LiveCode, each window is a stack. This includes editable windows, modeless and modal dialog boxes, and palettes, as well as sub-windows available on some operating systems, such as sheets and drawers.\n\n> **Tip:** If you want to make controls within a stack scale and position automatically when you resize the stack, see the section on the *Geometry Manager*.\n\nThis topic discusses the way windows are implemented in LiveCode applications; how to change window appearance; and how to control the behavior of the various window types. This topic does not cover the organization of stacks within a stack file, which is covered in detail in the section *Structuring Your Application*.\n\n> **Caution:** Do not start your stack name with \"rev\". Stacks with names starting with \"rev\" are reserved by the LiveCode development environment.\n\nYou create a new stack  which can then be displayed in any number of modes (as described below)  by choosing **File -\\> New Mainstack**. You can edit stack properties by choosing **Object -\\> Stack Inspector**.\n\n### Window Types and the Mode of a Stack\n\nThe nature of a stack's window depends on the stack's **style** property and on what command was used to open the stack. You can either specify the window type when opening the stack, or allow the stack's **style** property to determine the type of window it is displayed in.\n\n> **Note:** We recommend you specify the mode you want a stack to be opened in as part of the command you use to open the stack, rather than using the style property. This makes it easy to switch a stack between editable mode in the development environment, and for example, a dialog in the runtime environment.\n\n### The Standard Window Types\n\nLiveCode windows are usually one of four types: editable or **topLevel** windows, **modal** or **modeless** dialog boxes, or **palette** windows.\n\n> **Important:** You will normally create a new stack and edit it while it is in editable mode. If you want to create a dialog, create the stack like any other stack. Then when opening it, specify in the script that it should be displayed as a dialog, or a palette, etc. The appropriate commands for doing this are detailed with each type of window below.\n\nYou can test out these commands as you work on your window layout and scripts, using the *Message Box* (see section of the same name), or using the *window context menu* (see *Modal Dialog Boxes*, below). For more details on wr`it`ing scripts in general, see the section on *Coding in LiveCode*.\n\nMost windows are editable or **topLevel** windows, and this is the default mode for LiveCode stacks. If you open a stack using the **go** command (without specifying a mode), or using the Open Stack menu item, then the stack is displayed as an editable window unless its **style** property specifies another window type.\n\n### Editable Windows  for documents\n\nAn editable window has the appearance and behavior of a standard document window. It can be interleaved with other windows, and you can use any of LiveCode's tools to create, select, move, or delete objects in the stack.\n\n![](images/image57.png)\n\nFigure 16  Editable Document Windows on Multiple Platforms\n\nTo display a stack in an editable window, you use the **topLevel** or **go** commands:\n\n```\ntopLevel stack \"My Stack\"\ngo stack \"My Stack\"  \"topLevel\" is the default mode\ngo stack \"My Stack\" as topLevel\n```\n\nStacks whose **style** property is set to \"topLevel\" always open as editable windows, regardless of what command you use to open them.\n\n> **Note:** If the stack's **cantModify** property is set to true, the window retains its standard appearance, but tools other than the Browse tool can no longer be used in it. In other words, every tool behaves like the Browse tool when clicking in an unmodifiable stack's window.\n\n### Modeless Dialog Boxes  for alerts and settings\n\nModeless dialog boxes are similar to editable windows. Like editable windows, they can be interleaved with other windows in the application. Their appearance may differ slightly from the appearance of editable windows, depending on the platform.\n\n![](images/image58.png)\n\nFigure 17  Modeless Dialog Boxes on Multiple Platforms\n\nLike unmodifiable stacks, modeless dialog boxes do not allow use of tools other than the Browse tool. Use modeless dialog boxes in your application for windows such as a Preferences or Find dialog box, that do not require the user to dismiss them before doing another task.\n\nTo display a stack in a modeless dialog box, you use the **modeless** or **go** commands:\n\n```\nmodeless stack \"My Stack\"\ngo stack \"My Stack\" as modeless\n```\n\nStacks whose **style** property is set to \"modeless\" always open as modeless dialog boxes, regardless of what command you use to open them.\n\n### Modal Dialog Boxes  for alerts and settings\n\nA modal dialog box is a window that blocks other actions while the window is displayed. You cannot bring another window in the application to the front until the dialog box is closed, nor can you edit the stack using the tools in the Tools palette. While a modal dialog box is being displayed, the handler that displayed it pauses until the dialog box is closed.\n\n![](images/image59.png)\n\nFigure 18  Modal Dialog Boxes on Multiple Platforms\n\nModal dialog boxes do not have a close box. Usually, they contain one or more buttons that close the window when clicked.\n\n> **Important:** If you mistakenly open a modal dialog box without having included a button to close the window, use the contextual-menu shortcut (Control-Shift-Right-click for Unix or Windows, Command-Control-Shift-click for Mac OS) to display a context menu. Choose *toplevel* to make the stack editable.\n\nTo display a stack in a modal dialog box, you use the **modal** command or **go** commands:\n\n```\nmodal stack \"My Stack\"\ngo stack \"My Stack\" as modal\n```\n\nStacks whose **style** property is set to \"modal\" always open as modal dialog boxes, regardless of what command you use to open them.\n\n### Palettes  for accessory and tool windows\n\nA palette has a slightly different appearance, with a narrower title bar than an editable window. Like dialog box windows, a palette does not allow use of tools other than the Browse tool.\n\n![](images/image60.png)\n\nFigure 19  Palette Windows on Multiple Platforms\n\nA palette floats in front of any editable windows or modeless dialog boxes that are in the same application. Even when you bring another window to the front, it does not cover any palettes.\n\n> **Note:** On some Unix systems, palettes have the same appearance and behavior as ordinary windows and do not float. On Mac OS systems, palette windows disappear when their application is in the background and another application is in front.\n\nTo display a stack in a palette, you use the **palette** command or **go** commands:\n\n```\npalette stack \"My Stack\"\ngo stack \"My Stack\" as palette\n```\n\nStacks whose **style** property is set to \"palette\" always open as palettes, regardless of what command you use to open them.\n\n### **Ask Question Dialog  for asking a question**\n\nThe ask question dialog is a special type of window that is designed to make it easy to ask the user a question. It includes special syntax for opening the dialog with question text and returning any answer to the script that called it. You can also specify the window title, as well as an icon to be displayed in the window. The font, object positions, button order and icon will *automatically change* to reflect the operating system. However, if you do require more flexibility than is provided in this dialog, you should create your own modal dialog box instead (see above).\n\n![](images/image61.png)\n\nFigure 20  Ask Question Dialog Boxes on Multiple Platforms\n\nTo display the ask dialog, use the following commands:\n\n```\nask \"What is your name?\"\nask question \"What is the answer?\" titled \"Question\"\n```\n\n> **Tip:** You can try this example out right now by coping and pasting it into **Tools -\\> Message Box**, then pressing return.\n\nThe word question specifies the icon, and may be any of question | information | error warning.\n\nTo change the miniature application icon shown in the Mac OS X platform picture above, see the entry for gREVAppIcon in the *LiveCode Dictionary*.\n\nThe result is returned in the *special variable* it.\n\n```\nif it is \"Joe\" then doSomeThing\n```\n\nFor complete details on the syntax, see the ask command in the *LiveCode Dictionary*.\n\n![](images/image62.png)\n\nFigure 21  Icons for Ask and Answer Dialogs on Multiple Platforms\n\n### **Answer Alert Dialog  for displaying a dialog**\n\n<span id=\"OLE_LINK3\" class=\"anchor\"><span id=\"OLE_LINK4\" class=\"anchor\"></span></span>Like the ask dialog box above, the answer dialog is a special dialog that has been designed to make it easy to display information in a dialog on screen and optionally allow the user to make a choice from a list of up to seven choices. The answer command opens the dialog, lets you specify the text and the button choices, and returns the button click to the script that called it. You can also specify the window title, as well as an icon to be displayed in the window. As with the ask dialog, the font, object positions, button order and icon will *automatically change* to reflect the operating system. However, if you do require more flexibility than is provided in this dialog, you should create your own modal dialog box instead (see above).\n\n![](images/image63.png)\n\nFigure 22  Answer Dialogs on Multiple Platforms\n\n```\nanswer \"Hello World!\"\n```\n\n\n```\nanswer question \"What city is the capital of Italy?\" with \"Paris\" or \"London\" or \"Rome\" titled \"Multiple Choice\"\n```\n\nThe result is returned in the *special variable* it.\n\n```\nif it is \"Rome\" then answer information \"That was the correct answer.\"\n```\n\nFor complete details on the syntax, see the answer command in the *LiveCode Dictionary.*\n\nThe answer dialog is implemented internally as a stack attached to the LiveCode IDE. For details on customizing the IDE, see the section on *Editing the LiveCode User Interface*.\n\n> **Tip:** If you're not sure what a stack's name is, you can use the **mouseStack** function to find out. Enter the following in the Message Box (Tools -\\> Message Box), then move the mouse pointer over the stack window and press Return: `put the mouseStack`\n\n### **File Selector Dialogs**\n\nThe file selector dialogs allow you to display the system standard dialogs. These dialogs allow the user to select a file or a set of files, select a directory, or specify a name and location to save a file.\n\nThe syntax for bringing up the file selector dialogs mirrors the syntax for the alert and question dialogs detailed above. However, unlike these dialogs, the file selector dialogs are displayed using the system standard dialogs where available. The notable exception at the time of this writing is Linux platform, where a built-in dialog is used instead due to more limited OS support. (You can force the other platforms to use this built-in stack based file selector by setting the *systemFileSelector* global property.)\n\n![](images/image64.png)\n\nFigure 23  Answer File dialog for selecting a file\n\n```\nanswer file \"Select a file:\"\n```\n\n```\nanswer file \"Select an image file:\"`with type \"QuickTime Movies|mov\" or type \"All Files|\"\n```\n\nThe file path to the file selected by the user is returned in the *special variable* it. If the user cancelled the dialog, the special variable `it`will be empty and \"cancel\" will be returned by *the result* function.\n\nFor complete details on the syntax, see the `answer file with type`in the *LiveCode Dictionary.*\n\n![](images/image65.png)\n\nFigure 24  Ask File dialog for saving a file\n\n```\nask file \"Save this document as:\" with \"Untitled.txt\" answer file \"Select an image file:\" with type \"Text Files|txt\" ortype \"All Files|\"\n```\nThe file path to the file to be saved is returned in the *special variable* it. If the user cancelled the dialog, the it variable will be empty and cancel will be returned by *the result* function.\n\nFor complete details on the syntax, see the ask file with type in the *LiveCode Dictionary.*\n\n![](images/image66.png)\n\nFigure 25  Answer folder dialog for choosing a directory\n\n```\nanswer folder \"Please choose a folder:\"\n```\n```\nanswer folder \"Please choose a folder:\" with`\"/root/default folder\"\n```\n\nThe file path to the folder selected by the user is returned in the *special variable* it. If the user cancelled the dialog, the `it` variable will be empty and \"cancel\" information will be returned by *the result* function.\n\nFor complete details on the syntax, see answer folder in the *LiveCode Dictionary.*\n\n### **Color Chooser Dialog**\n\nThe `answer color` dialog allows you to display the operating systems standard color picker dialog.\n\n![](images/image67.png)\n\nFigure 26  Answer color dialog for choosing a color\n```\nanswer color\n```\nThe color chosen is returned in the *special variable* it. If the user cancelled the dialog, it will be empty and \"cancel\" will be returned by *the result* function.\n\nFor complete details on the syntax, see answer color in the *LiveCode Dictionary.*\n\n### **Printer Dialogs**\n\nThe printer dialogs allow you to display the standard printer and page setup dialogs.\n\n![](images/image68.png)\n\nFigure 27  Answer printer for standard printer dialog\n\nUse the `answer printer` command to display a standard printer dialog prior to printing. If the user cancels the dialog, \"cancel\" will be returned by *the result* function.\n\n### **Visual Effect Dialog**\n\nAnswer effect allows you to display the QuickTime special effects dialog box.\n\n![](images/image69.png)\n\nFigure 28  Answer effect dialog for choosing a QuickTime effect\n\nUse the `answer effect` command to display a standard QuickTime effect dialog. The effect will be returned as binary data in the special variable `it`. You can use this variable with the visual effect command to create a visual effect *transition*. If the user cancels the dialog, `it` will be empty and \"cancel\" will be returned by *the result* function.\n\n### Alpha Blend Windows  for Enhanced Tooltips and Multimedia\n\nUse the *Shape* option in the *Stack Inspector* to set a stacks **windowShape** property to the transparent, or *alpha channel* of an image that has been imported together with its alpha channel (i.e. in either PNG or GIF format). This allows you to create a window with \"holes\" or a window with variable translucency. You can apply a shape to any type of stack, regardless of the mode it is opened, allowing such a window to block as a dialog, float as a palette, etc.\n\n> **Important:** The border and title bar of a stack are not shown if the stack's `windowShape`is set. This means you will need to provide methods of dragging and closing the window if you want the user to be able to do these tasks.\n\n![](images/image70.png)\n\nFigure 29  Window with alpha mask applied\n\nYou can change the **windowShape** property dynamically by script to a series of images to create an animated translucent window.\n\n### System Palettes  for utilities floating above applications\n\nA system palette is like a palette, except that it floats in front of all windows on the screen, not just the windows in its application. Use system palettes for utilities that you want the user to be able to see and access in every application.\n\n![](images/image71.png)\n\nFigure 30  System Window floating above other applications\n\nTo display a stack in a system palette, you turn on the check box in the Stack Inspector \"Float Above Everything\". For more details on this feature, see the entry for systemWindow in the *LiveCode Dictionary*.\n\nUsing this feature overrides the stack's **style** or **mode**.\n\nThe system palette style is currently not supported on Linux & Unix.\n\n### Sheet dialog boxes  Mac OS X only\n\nA sheet is like a modal dialog box, except that it is associated with a single window, rather than the entire application. A sheet appears within its parent window, sliding from underneath the title bar. While the sheet is displayed, it blocks other actions in its parent window, but not in other windows in the application.\n\nTo display a stack in a sheet dialog box, you use the **sheet** command:\n\n```\nsheet \"My Stack\" -- appears in defaultStack\nsheet \"My Stack\" in stack \"My Document\"\n```\n\n> **Note:** Note the **answer**, **answer file**, **answer folder**, **ask**, **ask file**, and **answer folder** commands (see above) all include an ...as sheet form, so you can display these dialog boxes as sheets on Mac OS X. You can safely use the as sheet form on cross-platform application as on systems other than OS X, the **sheet** command displays the stack as an ordinary modal dialog box.\n\n### Drawers  Mac OS X only\n\nA drawer is a subwindow that slides out from underneath one edge of a window, and slides back in when you close it. You usually use a button in the main window to open and close a drawer.\n\nTo display a stack as a drawer, you use the **drawer** command:\n\n```\ndrawer \"My Stack\" at left *-- of defaultStack*\ndrawer \"My Stack\" at bottom of stack \"My Document\"\n```\n\nOn systems other than OS X, the **drawer** command displays the stack as an editable window. Because this does not map well to other platforms, we recommend you only use drawers for applications that are only being developed for Mac OS X.\n\nUse drawers to hold settings, lists of favorites, and similar controls that are accessed frequently but that don't need to be constantly visible.\n\n### Stack menus  for displaying non-standard menus\n\n> **Note:** Usually a menu in a LiveCode application is implemented as a button. We recommend that menus are implemented using buttons, as these will automatically be drawn with the native theme on each platform. For more details, see the section on Menus below\n\nIt is also possible to display a stack as a `pulldown`, popup, or option menu. Stack menus are used when a menu needs to contain something other than just text. For example, a popup menu containing a slider, or an option menu consisting of icons instead of text, can be implemented as a stack menu.\n\nTo display the stack menu, you create a button and set its **menuName** property to the stack's name. When the user clicks the button, the stack is displayed with the behavior of a menu. Internally, the menu is implemented as a window, and you can use the **popup**, **pulldown**, or **option** command to display any stack as one of these menu types.\n\n### Stack Decorations  for Window Appearance\n\nStack decorations allow you to specify how the title bar and border of a window will be drawn. You can access the stack decorations options in **Object -\\> Stack Inspector**.\n\nApart from the differences in appearance between different window modes, the appearance and functionality of a window can vary depending on the stack's properties and the platform it is being displayed on.A window's title bar displays the window's title, as well as a close box, minimize box or collapse box, and maximize box or zoom box.\n\n![](images/image72.png)\n\nFigure 31  Window Decorations on Windows and Mac OS X\n\n> **Note:** On Mac OS X, a stack's **shadow** property controls whether the stack window has a drop shadow. On OS X systems, you can set this property to false to create a window with no shadow.\n\nThe properties above can also be set by script, for more details see the **decorations** property in the *LiveCode Dictionary*.\n\nWhile the stack's mode is separate from its **decorations**, the mode may affect whether these properties have an effect. If the **decorations** property is set to \"default\", it displays the appropriate decorations *for the current window type* on the current platform.\n\n### Button Controls  for performing actions\n\nA button is a clickable object that is typically for allowing a user to perform an action by clicking.\n\n![](images/image73.png)\n\nFigure 32  Button Objects on Multiple Platforms\n\nCheck boxes and radio buttons are used to allow the user to make choices. Radio buttons are used when only one option for a set of options may be selected at any time. Check boxes are used where some options may be turned on and others may be off.\n\n> **Note:** LiveCode will automatically enforce the rule of highlighting one radio button at a time if you place the radio buttons together in a group. For more details on groups, see the section on *Groups and Backgrounds*.\n\n![](images/image74.png)\n\nFigure 33  Check Boxes and Radio Buttons on Multiple Platforms\n\nAll button objects in LiveCode are highly flexible and customizable. Common settings include the ability to show and hide the border or fill, and to display an icon.\n\nIcons allow you to provide a wide range of functionality. For example you can create a roll over effect by setting a hover icon. Or you can create a custom check box by setting an icon and a highlight icon  doing so will replace the system standard check box and display your icon in each state depending on whether the button has been pressed or depressed.\n\n![](images/image75.png)\n\nFigure 34  Custom Buttons for Multimedia\n\n> **Important:** Button icons are not limited in width or height. They can be animated by using an animated GIF. In fact, an icon can reference **any** image contained within your LiveCode stack file. Referencing an image in this way saves disk space and allows you to update all icons in your stack by updating a single image. See the chapter *Working with Media* for more information.\n\n### Text Field Controls  for displaying or entering text\n\nFields allow you to display text. Fields can optionally allow the user to edit the text. Fields support multiple fonts, styles and colors, images and a subset of basic HTML tags. Fields can be linked to a database using the Database Query Builder or by directly accessing a database with the database library. They can display and render XML using the XML library. List fields allow the user to select one or a set of choices. Table fields allow display of data similar to a spreadsheet. Other types of field can easily be created, including tree views, or any hybrid between these types, with a little scripting. At the time of this writing there is also a 3<sup>rd</sup> party library available that allows you to host a web browser within an object and control it by script.\n\n![](images/image76.png)\n\nFigure 35  Field Controls\n\n### List and Table Field Controls\n\nList fields allow you to display a set of choices. Users cannot edit list fields. You can specify whether the user is allowed to make a single selection or multiple selections.\n\n![](images/image77.png)\n\nFigure 36  List Fields\n\n### Table Field Control  for displaying a table\n\nTable fields allow you to display data in cells, and optionally allow the user to edit the cells. Table fields are ideal for displaying basic tabular data. For more complex data display requirements we recommend you use the Data Grid control.\n\n![](images/image78.png)\n\nFigure 37  Table Field\n\n### Data Grid Control  for presenting data\n\nData Grids allow you to display data in both grid and form modes. You can customize a data grid to include custom layouts that include any other LiveCode object. Data grids can provide a view into a data source, allowing you to display large data sets. For full documentation on using data grids, see the online documentation at:\n\n<http://lessons.runrev.com/spaces/lessons/manuals/datagrid>\n\n![](images/image79.png)\n\nFigure 38  Data Grid\n\n### Cards\n\nEach stack contains one or more separate screens of controls. Each screen is known as a card. Each card can have an entirely different appearance, or all the cards in a stack can share some or all elements, by using *shared groups*, known as *backgrounds* (see below).\n\nChoosing **Object -\\> New Card** will create a new card within the current stack. The new card will either be completely blank, or will contain any shared groups from the previous card.\n\n### Groups & Backgrounds  for organizing, and sharing controls\n\nGroups, LiveCode's most versatile object type, are used for several purposes: radio button clusters; menu bars; for creating scrollable object areas within cards; and as backgrounds for displaying sets of objects that are shared between cards. Groups can also be used for creating a simple card and stack database, by holding fields that contain a different record on each card.\n\n**What Is a Group?**\n\nA group is a single object that holds a set of objects. Objects are grouped by selecting the controls you want to include in the group, then using the **group** command or choosing **Object \\> Group Selected**.\n\nOnce you've created the group, it becomes an object in its own right. You can select, copy, move, and resize the group, and all the objects in the group come with it. The objects in the group maintain their own identities, and you can add objects to the group or delete them, but the objects are owned by the group instead of the card.\n\nA group has its own properties and its own script. Groups can be any size, can be shown or hidden, and can be moved to any location in the stack window, just like any other control. Like other controls, groups can be layered in any order with the other controls on the card. Groups can also display a border around a set of objects.\n\n![](images/image80.png)\n\nFigure 39  Group of radio buttons with group title and border\n\nUnlike other controls, however, groups can appear on more than one card. You place a group on a card using the **place** command or the **Place Group** submenu in the **Object menu**.\n\n> **Important:** A group that is shared between cards appears at the same location on each card. A change made to the position of a shared group on one card is reflected on all the other cards that share the group.\n\n**Groups and Backgrounds**\n\nBoth the term **group** and the term **background** can be used to refer to groups. The terms are interchangeable in some circumstances and mean different things in others. The differences are explained in more detail below.\n\nIn general, the term **group** refers to groups that are placed on a card, while the term **background** refers to all the groups in a stack that are available for use as *backgrounds* (see below). The expression `the number of groups`evaluates to `the number of groups`on the current card. The expression the number of backgrounds evaluates to the number of background groups in the current stack, including groups that are not placed on the current card.\n\n> **Tip:** When you refer to a group by number, if you use the word **group**, the number is interpreted as referring to the groups on the referenced card, in order by layer. If you use the word **background**, the number is interpreted as referring to the groups in the stack, in the order of their creation.\n\nFor example, the expression the name of group 1 evaluates to the **name** of the lowest-layered group on the current card, while the expression the name of background 1 evaluates to the **name** of the first group that was created in the stack--whether or not that particular group is placed on the current card, or appears on any card at all.\n\nThe term **background** can be also used to refer to the set of cards that share a particular group. The following statement goes to the third card on which the group named \"Navigation\" is placed:\n\n```\ngo card 3 of background \"Navigation\"\n```\n\n**Nested Groups**\n\nLiveCode supports nested groups (one group containing another). Since a group is itself a control, it can be contained in another group.\n\nCreating a nested group is just like creating a group: select the controls you want to group (including the existing group), then choose **Object -\\> Group Selected**. The existing group is now a member of the new group.\n\n**Selecting and Editing Groups**\n\nTo select a group, simply click on one of the objects that is contained within it. This will select the group.\n\nIf you want to select an object within the group, instead of the group itself, there are two ways to do so. You can turn on the **Select Grouped** option on the toolbar or in **Edit -\\> Select Grouped Controls**. This causes groups to be ignored when selecting objects, allowing you to select objects inside a group as if the group didnt exist. You can enter this mode by script by toggling the **selectGroupedControls** global property.\n\nAlternatively you can go into edit group mode, a special mode that only displays the objects within that group. Select the group, then press **Edit Group** on the toolbar or choose **Object -\\> Edit Group**. When you have finished, choose **Object -\\> Stop Editing Group**. You can toggle this mode programmatically by using the commands **start editing** and **stop editing**.\n\n> **Tip:** If a group's border has been set, an outline appears at the group's edges. However, clicking within or on the border does not select the group. To select the group, you must click one of its controls.\n\n**Placing and Removing Backgrounds**\n\nOnce you create a group, you can display it on any or all cards in the stack. First, ensure that the groups Behave as Background option has been set in the Inspector. Then navigate to the card you want to place the group on and choose **Object -\\> Place Group** to place an instance of a particular group on the current card. You can control these features from script by using the **backgroundBehavior** property and **place** command.\n\n> **Note:** When you create a new card, if there are any groups on the current card whose Behave as Background has been set, they are automatically placed on the new card. To make it easy for all `the`cards in a stack to share a single group, create the group on the first card and set this property to true, before you create any other cards.\n\nTo remove a group from the current card without deleting it from the stack select the group and choose **Object -\\> Remove Group**. The group disappears from the current card, but it's still placed on any other cards that share the group. You can remove a group by script using the **remove** command.\n\n> **Tip:** You can use the **start editing** command from the Message Box to edit a group that has not been placed on any card. Since the group is not on any card, you must refer to it using the term \"background\" instead of the term \"group\".\n\nYou can completely delete a group in the same way as you delete any other object, by selecting the group and choose **Edit -\\> Clear** or pressing backspace.\n\n> **Important:** Deleting a background group removes it from all the cards it appears on, and from the stack itself.\n\nTo dissolve a group back into its component controls, select the group and choose **Object -\\> Ungroup**. You can ungroup a group by script using the **ungroup** command. Ungrouping deletes the group object and its properties (including its script) from the stack, but does not delete the controls in it. Instead, they become card controls of the current card. The controls disappear from all other cards the group is on.\n\n> **Note:** If you ungroup a group, then select the controls and regroup them before leaving the current card, the group is restored as it was. However, leaving the current card makes the ungrouping permanent and deletes the group from all other cards it was on.\n\n**Groups and the Message Path**\n\nFor details on how groups and backgrounds fit into the Message Path, see the section on *Groups, Backgrounds & The Message Path*, below.\n\n### Graphics, Images, Players, Audio & Video Clip Objects  for multimedia\n\nLiveCode supports a wide range of media formats, allowing you to produce rich media applications. The image object allows you to import or reference images, manipulate images by script or interactively with the paint tools, and save them out in different formats with variable compression options. Support extends to alpha channeled PNG images and animated GIF images. Images can be imported and reused within a stack to create custom or interactive interface elements. To learn how to work with these objects in a script, see the section on *Working with Media*.\n\nImage formats supported include GIF, JPEG, PNG, BMP, XWD, XBM, XPM, or PBM, PGM, or PPM files. On Mac OS systems, PICT files can also be imported (but they cannot be displayed on Unix or Windows systems). For full details on each of these formats, see the section on *Working with Media*.\n\nYou can import images using **File -\\> Import as Control -\\> Image File**. You can reference an image using **File -\\> New Referenced Control -\\> Image file**.\n\nPaint tools can only be used on images that have been imported as a control. See the section on *Using the Paint Tools* for details on how to use the paint tools.\n\n![](images/image81.png)\n\nFigure 40  Image, Graphic and Player objects\n\nVector graphics can also be created and manipulated with the graphic tools and by script. LiveCode supports paths with variable fills, gradients, blended and antialiased graphics. At time of this writing there is also a 3<sup>rd</sup> party library that allows the import and export of SVG format graphics. Use graphic objects to create interactive interfaces, graphs, charts or games.\n\nUse the player object to display and interact with any media formats supported by QuickTime. LiveCode allows you to turn on and off tracks within a movie, pan, zoom or change location within a QTVR movie, set callback messages that trigger scripts at specific points in the movie, and stream movies from a server. At time of this writing there is also a 3<sup>rd</sup> party library that allows you to edit and save movies by script.\n\nThe Audio Clip & Video Clip objects allow you to embed audio or video clip data within a stack. Some audio clip formats can be played back directly without QuickTime installed. They do not have any visual representation and can be accessed by script or in the Application Browser. Players, Audio & Video clips are covered in their respective sections within the chapter on *Working with Media*.\n\n### Menu Controls  for displaying choices\n\nMenus are used to display a list of choices. The `pulldown`menu displays a standard `pulldown`menu, and can be automatically inserted into the main menu bar on Mac OS systems. The `option`menu allows a choice from a list. The combobox allows the user to type an `option`or choose from a list. Popup menus can be displayed underneath the cursor and used to provide context sensitive options anywhere in your application. For more information on working with `pulldown`menus within the main menu bar, see the section on the *Menu Builder* below.\n\nMenu contents can be defined using a list of item names and special characters to indicate where shortcuts and checkmarks should be placed. This is the most common type of menu and is known as a *contents menu*. LiveCode will automatically draw menus defined as *contents* menus using the native system look on each platform. When you choose an item from a contents menu, LiveCode will send a `menuPick`message along with the name of the item chosen.\n\nAlternatively, menus may be constructed from a *stack panel*, giving you complete control over the menu contents and allowing the display of any object type of functionality. When you choose an item from a *stack panel* menu, the individual object within the menu will receive a `mouseUp`message. Note that panel menus cannot be displayed within the main menu bar on Mac OS systems.\n\nFor more details on working with and scripting menus in general, see the section *Working with Menus* in the chapter *Programming a User Interface*.\n\n![](images/image82.png)\n\nFigure 41  Menu Controls\n\nThe cascade menu is a special type of control that is only used when building a stack panel menu. Sub-menu items can be created in list-based content menus without using this object.\n\n![](images/image83.png)\n\nFigure 42  Tab Menu on Windows\n\nThe tabbed panel is a type of menu in LiveCode. You can specify a list of tabs to be displayed and receive a `menuPick`message when the user clicks on a tab in the same way as other menus. There are two common techniques for implementing a tabbed interface: group the objects for each tab together and show or hide the appropriate group when you change tab; or place the tab object into a group which is then placed as a background on multiple cards.\n\n### Other Controls\n\nScroll bars can be used as a *progress* bar to display a value, a *slider* to allow the user to choose a value, or to scroll objects. (Note that you dont need to use a scrollbar object with fields or groups as these can display a built-in scroll bar.) Sliders and scrollbars can be displayed both horizontally and vertically  to display vertically, resize so that the height is greater than the width.\n\n![](images/image84.png)\n\nFigure 43  Scrollbars\n\n## Using the Menu Builder\n\nThe menu builder allows you to create and edit a standard menu bar that will work correctly regardless of the platform you intend to deploy on. On Windows and Unix, menus built with the Menu Builder will appear in the top of the window. On Mac OS they will be displayed in the main menu bar. It is also possible to generate a menu bar by script. For more details, see the section on *Programming a User Interface*.\n\nChoose **Tools -\\> Menu Builder** to open the Menu Builder.\n\n![](images/image85.png)\n\nFigure 44  Menu Builder\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Preview** | This option allows you to preview your menu bar in the main menu bar. It only applies on Mac OS systems where the option Set as Menu Bar on Mac OS has been turned on.<br><br> > **Important:** To bring back the LiveCode development menu bar when working with a stack that has this option turned on, click on a LiveCode IDE window such as the Tool bar. |\n| **Menu bar settings** | This area specifies the main settings for your menu bar. Use the *New* button to create a new menu bar in the current top most editable stack. Enter the name for your menu bar in the text area. *Delete* will permanently delete your menu bar. Use the *Edit* button to load an existing menu bar from the top most editable stack to edit in the area below.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| **Menu edit area**    | Select a menu to work on from the scrolling list. At a minimum your application should have a File, Edit and Help menu. These menus are created for you automatically when you create a new menu bar. To create a new menu, move the orange *divider bar* to the position in the menu bar you want to create the new menu, and press *New Menu*. Disable the currently selected menu by checking *Disabled*. Choose the keyboard shortcut (the portion of the name that is underlined), using the *Mnemonic* popup menu (Windows, Linux & Unix only). To move a menu in the list, select it then press the *up or down arrows* (to the right of the name area).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| **Menu content area** | Select a menu item to work on from the scrolling list. To create a new menu item, move the orange *divider bar* to the position in the menu bar you want to create the new menu, and press *New Item*. Disable the currently selected item checking *Disabled*. Choose the keyboard shortcut (the portion of the name that is underlined, for use when the menu is open), using the *Mnemonic* popup menu (Windows, Linux & Unix only). To move a menu item up or down the list, select it then click the *up or down arrows* (to the right of the name area). To move items into a *submenu*, click the *Right* arrow, or click the *Left* arrow to move a submenu item back into the main menu bar. To insert a *divider*, position the orange divider bar where you want the divider, the click the blue divider button (top right). To make the menu item a *Checkbox* or *Diamond* option, choose the appropriate option from the *Mark* popup menu. To create a control key *shortcut* for the item, click the Shortcut check box and enter the letter you want to use for the shortcut. To understand the *symbols* that are created next to the menu items, see the section on *Menu Bars* within the chapter on *Programming a User Interface*. |\n| **Scripting**         | *Edit Script* opens the Code Editor for the currently selected menu. *Auto Script* places a blank script within the currently selected button with spaces to insert actions for each of the menu items within that item. We recommend you press Auto Script before pressing Edit Script when you create a menu.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n\n## Using the Geometry Manager\n\nUse the Geometry Manager to specify how objects should be scaled and positioned when the user resizes the window.\n\n![](images/image86.png)\n\nFigure 45  The Geometry Manager\n\n| &nbsp;| &nbsp;|\n|--------------------------------|----------|\n| **Scale or Position Selector** | Choose whether you want the control to be *scaled* or *positioned* when the stack is resized. Scaling will change the dimensions of the control as the stack resizes. Positioning will move the control, it does not change its dimensions. Note that it is possible to scale an object in the horizontal plane and have it position in the vertical. Select Scale then set the options for one axis in the Linking area. Then select Position and set the options for the other axis. If you set options in both the Scale and Position modes for both axis, the Scaling options will be ignored.                                                                                                                                                                                                                                                                                                                                                                                          |\n| **Linking area**               | Use the linking area to specify the *relationship* between the control and the window, or other controls as the stack is resized. In Scaling mode you can link each edge of the object to the window or another object. In positioning mode, you can only link the X and Y axis of an object. Click the gray bars to create a link. A single click results in an absolute link, a second click will create a relative link. An absolute link will keep the object the current number of pixels away from what it is being linked to. For example, if you link the right edge to the edge of the window and the edge is currently 10 pixels away from the edge of the window, whenever the stack is resized the edge will remain exactly 10 pixels away. However if you use a relative link the distance will be calculated as a percentage of the total width of the card. The object will remain the same percentage away from the edge of the card, the exact number of pixels will vary.<br><br>When linking to another control, be sure to link to a control that is moved relative to the window, or by a script (e.g. in a `resizeStack`handler).<br><br>When using the Geometry Manager with an existing `resizeStack`handler, be sure to pass the `resizeStack`message, otherwise the Geometry Manager will not be able to take effect.<br><br>To force the Geometry to manually update, call **revUpdateGeometry**.<br><br> > **Tip:** You can use the Geometry Manager to scale objects with a \"divider\" bar. Create and script the bar to move, then link the edges of the controls to it, then call revUpdateGeometry each time it moves to have the objects scale automatically.|\n| **Clipping settings** | Turn on Prevent Object Clipping Text to prevent the control getting too small to display its label when the window is resized. If the control is a field, you can also turn on the option to display scroll bars if the text within the field does not fit. |\n| **Limit settings**    | Allows you to set the minimum and maximum possible widths and heights for the object.                                                                                                                                                                       |\n| **Remove All**        | Removes all Geometry settings from the control. Use this option if the settings you have applied do not give the desired effect and you want to start over.                                                                                                 |\n\nThe Geometry Card Settings options can be accessed from within the Card Property Inspector. Use these options to determine how Geometry is applied to the controls within the current card.\n\n![](images/image87.png)\n\nFigure 46  Geometry Card Settings\n\n| &nbsp;| &nbsp;|\n|------------------------------------------|-----------|\n| **Add to cards virtual width or height** | Use this option to implement a layout that allows a section of optional controls to be folded out. The Geometry manager will ignore the extra height or width pixels specified in this area, resizing objects as if that area of the card has not been \"expanded\". Normally these values are set by script as the window is resized to fold out additional controls. To set these properties by script, set the **cREVGeneral[\"virtualWidth\"]** or **cREVGeneral[\"virtualHeight\"]** card properties. |\n| **Update before opening card**           | Causes the objects to be resized when navigating to the card if the window has been resized while on another card. This option is not needed if the controls are contained within a background that has already been correctly resized to the current window dimensions.                                                                                                                                                                                                                             |\n\n## Using Property Profiles\n\nUse Property Profiles to store different sets of properties in a single object. Property Profiles can be used to provide *localized* versions of your application, or different *themes* or skins.\n\n![](images/image88.png)\n\nFigure 47  Property Profiles\n\n| &nbsp;| &nbsp;|\n|------------------------------------|-----------------|\n| **Create, delete or set Profiles** | The icons from left to right allow you to *duplicate*, *delete* or*create* a new profile for the currently selected object. The *Set all* button allows you to set all the objects on the current card or stack to the profile currently selected in Profile selector area.<br><br>When creating a new profile, ensure you choose a name that is *valid as a variable* and not a reserved LiveCode word. Use consistent names to allow you to create a theme or language and set all the objects in your card or stack to the same profile.<br><br>When you create a new profile, LiveCode automatically switches the object to use that profile. There are two ways to include new property settings in a profile: by using the property inspector to specify the properties you want to include, and by changing the properties directly while the profile is active.<br><br>If you make changes to the properties of the object, the profile editor will track the changes and save those into the current Profile. Any properties that have not been set for the current profile will be *inherited* from the Master profile. The profiles system supports all common object properties including styled text and Geometry information. However it does not store properties that duplicate each other (e.g. only the `rect`value will be stored, not the objects left, right or other location properties). Scripts and custom properties are also not stored by the profile editor. You can however write scripts that first check what profile is in use on the object before taking an action by checking the `revProfile` property of the object.<br><br>You can set profiles by script by setting the `revProfile` property. To set the entire card, stack or stack file, use `revSetcardProfile`, revSetStackProfile or `revSetStackFileProfile`commands respectively. To turn on the storage of new properties in the current profile and thus change profiles more rapidly, toggle the g`revProfile`ReadOnly global.                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| **Profile selector**               | Select a profile to change all the objects properties to the values contained in that profile. Click the currently selected profile to update the list of properties stored for it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| **Profiles properties**            | Displays a list of all properties that have been changed in the currently selected profile, and thus have a value unique to this profile. Select a property to see its contents. Press the *plus* icon to manually *add* a new property to the current profile. Delete the property from the current profile using the *delete* icon.                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| **Property contents**              | View and edit the contents of the currently selected property associated with the currently selected profile.<br><br>The Add Property dialog box lists all applicable properties, but the Property Profiles pane automatically eliminates redundant properties and property synonyms. For example, if you add the `backgroundColor`and foregroundColor properties, the Property Profiles pane displays the `colors`property instead the next time you re-open the property inspector. This is because the `colors`property contains all eight color settings of an object, so it's not necessary to store the individual color properties once they've been set.<br><br>To easily copy a property value from another profile, click the \"Copy\" button in the bottom section and choose the profile you want to copy from.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n\nFor more details on working with *Property Profiles*, see the section on *Property Profiles* in the chapter *Programming a User Interface*.\n\n## 10 Tips for Good User Interface Design\n\nIf you are creating a simple utility for yourself, a handful of other people, or as a research project, the design of the interface is less important. However, if you are creating software for a wide group of end users, you should take time to carefully design the user interface. As computer software has become more mature over the past couple of decades, user expectations of what their software experience should be have increased. Increasingly, users expect clear, uncluttered interfaces which are visually appealing. Getting this right is part art and part science. It is beyond the scope of this manual to give detailed instruction on this topic. There are many good books and resources devoted to this evolving area. However we thought it would be useful to give you our top 10 tips for good user interface design.\n\n**Less is more**\n\nDon't use three buttons where one would do. The fewer choices a user has to make the easier your software will be to learn.\n\n**Design to communicate**\n\nGood design supports whatever you are trying to communicate.\n\n**Get the defaults right**\n\nProviding preferences is great for power users. Just remember that the majority of your users will never adjust the defaults. So focus on getting the default behaviors right before you start to add preferences.\n\n**Layout**\n\nA clean consistent layout helps to convey a feeling of professionalism and make your software useable. If you have used a button that is 20 pixels wide in one part of your interface then use the same size of button elsewhere. Line your objects up carefully.\n\n**Screen resolution**\n\nConsider what screen resolution you are designing for and whether or not you want your interface to be resizable early on. This decision will have a big impact on your design.\n\n**Consider the program flow**\n\nIf you program performs a complex task with many options, consider creating a wizard style interface which guides the user step by step through the task. That way they are never faced with a screen covered with dozens of options and no idea what to do next.\n\n**Test it on real users**\n\nBring in a group of people and watch them use the program. Don't interfere or help them out, just get them going and take notes. If you don't have a budget for expensive user testing labs, this process can be as simple as gathering a group of students and offering them free pizza. You'll get a ton of useful feedback that will really help make your program easy to use.\n\n**Don't use square wheels**\n\nThe various types of widget and control type available have built up a meaning for users over years of use. Don't use something that has a well understood function to perform a different sort of task. If you need a widget that does something new, build something new.\n\n**Skinning**\n\nIf you're producing a custom skin for your application, a good rule of thumb is either make it entirely custom or use standard OS widgets. An OS native button can look very out of place in the middle of a carefully designed custom skin.\n\n**HCI guidelines for the three main platforms **\n\nEach of the platforms that LiveCode supports has its own set of User Interface Guidelines. We recommend you take time to familiarize yourself with them.\n\nApple Human Interface Guidelines:\n\n<http://developer.apple.com/documentation/UserExperience/Conceptual/OSXHIGuidelines/XHIGIntro/chapter_1_section_1.html>\n\nWindows Vista User Experience Guidelines:\n\n<http://msdn2.microsoft.com/en-us/library/aa511258.aspx>\n\nGNOME Human Interface Guidelines 2.0:\n\n<http://library.gnome.org/devel/hig-book/stable/>\n\nKDE Human Interface Guidelines:\n\n<http://wiki.openusability.org/guidelines/index.php/Main_Page>\n\n# Coding in LiveCode\n\nWriting code is how you give your application functionality. Writing the right code means your application will do what you want it to do. Fortunately, LiveCodes built in high level language, makes this task easy. The English-like syntax is easy to read and write. This chapter walks you through writing LiveCode.\n\n## The Structure of a Script\n\n### What is a Script\n\nEvery object in LiveCode can contain a script, which tells it what to do. You edit the script of an object using the Code Editor (see *The Code Editor*). A script is organized into a set of individual *message handlers*, each one of which can respond to a different event (see *Messages*) or contain a specific piece of functionality. Scripts can send messages to each other. In a well organized application, a script will regularly pass data between different types of message handlers which have been grouped and organized to deliver functionality, with a minimum amount of duplication. A script can contain sections of code that is commented  remarks that are intended for a human to read and are not executed. Technically a script is simply another object property, so one script can set another  within certain limits.\n\n### The Types of Handler\n\nA *handler* is a complete section of code. Each handler can be executed independently. There are four types of handler: commands (message handlers), functions, getProp handlers and setProp handlers.\n\n### Message Handlers\n\nEach *message* handler begins with the **on** control structure followed by the name of the message that this handler responds to. The handler ends with the **end** control structure and the name of the message. Message handlers look like this:\n\n```\non mouseUp\n\tbeep\nend mouseUp\n```\n\nA message handler is executed when the object whose script contains the handler receives the message. This example handler responds to the **mouseUp** message (see *Messages*).\n\n### Function Handlers\n\nEach function handler begins with the **function** control structure followed by the name of the function that this handler computes. The handler ends with the **end** control structure and the name of the function. Function handlers are typically called by another handler and return a value using the **return** control structure. Function handlers look like this:\n\n```\nfunction currentDay\n\treturn item 1 of the long date\nend currentDay\n```\n\nA function handler is executed when a handler in the same script (or one in an object lower in the *message hierarchy*) calls the function. This example handler returns today's name.\n\n### GetProp Handlers\n\nEach `getProp`handler begins with the **getProp** control structure followed by the name of the custom property that this handler corresponds to. The handler ends with the **end** control structure and the name of the property. `getProp`handlers look like this:\n\n```\ngetProp myCustomProperty\n\treturn the scroll of me + 20\nend myCustomProperty\n```\n\nA `getProp`handler is executed whenever the value of the corresponding custom property is requested by a LiveCode statement. You can write a `getProp`handler for any custom property of the object or another object lower in the message hierarchy. For more information, see the section on *Custom Properties*.\n\n### SetProp Handlers\n\nEach setProp handler begins with the **setProp** control structure followed by the name of the custom property that this handler corresponds to. The handler ends with the **end** control structure and the name of the property. setProp handlers look like this:\n\n```\nsetProp myCustomProperty newSetting\n\tset the hilite of me to true\n\tpass myCustomProperty\nend myCustomProperty\n```\n\nA setProp handler is executed whenever the value of the corresponding custom property is changed by the **set** command. You can write a setProp handler for any custom property of the object or another object lower in the object hierarchy. For more information, see the section on *Custom Properties*.\n\n### Comments\n\nComments are remarks that are intended for a human to read and are not executed. For some recommendations on what sort of comments to include and when, see the section on *Good Design Recommendations*.Comments can be placed either in a handler, or outside any handler.\n\nAny line (or portion of a line) that starts with two dashes (**--**) or a hash mark (**\\#**) is a comment. Placing these characters at the beginning of a line is called \"commenting out\" the line.\n\n```\non mouseUp -- this part is a comment\n\tbeep\n\t-- and this is a comment too\nend mouseUp\n```\n\nYou can temporarily remove a statement, or even an entire handler, by commenting it out. To comment out several lines at once, select them and choose **Script -\\> Comment**.\n\nSince comments are not executed, you can place them anywhere in a script--inside a handler or outside all handlers.\n\nComments that start with **--** or \\# only extend to the end of the line. To create a multiple-line comment, or *block comment*, surround it with **/\\*** and **\\*/** instead:\n\n```\non openCard\n\t/* This is a multiple-line comment that might\n\tcontain extensive information about this handler,\n\tsuch as the author's name, a description, or the\n\tdate the handler was last changed. */\n\tshow image \"My Image\"\n\tpass openCard /* You can also make one-line comments */\nend openCard\n```\n\nBlock comments are handy when you want to temporarily remove a section of code while debugging a handler. You can place the characters \"/\\*\" at the start of the section, and \"\\*/\" at the end, to prevent the section from being executed.\n\n### Compiling a Script\n\nA script is compiled when you change the script either by clicking Apply in the Code Editor (or, if altering a script from another script, using the **set** command). During compilation, the entire script is analyzed.\n\nIf a compile error is found when a script is being compiled, the entire script is unavailable for execution until the error is corrected and the script is re-compiled. This applies only to compile errors. If an execution error occurs during the execution of a handler, it does not affect the ability to use other handlers in the same script. For more information on dealing with errors, see the section on *Debugging*.\n\nYou cannot change a script while a handler in it is executing, because what is executed is the compiled version, not the text in the **script** property.\n\n### Summary\n\nEach object has a script, which can be empty or can contain one or more LiveCode handlers. You change a script using the Code Editor, or by setting the object's **script** property.\n\nA script can contain four kinds of handlers: commands, function handlers, setProp handlers, and getProp handlers.\n\nA comment is a part of the script that is not executed. Comments start with **--** or **\\#**.\n\nIf a script contains a compile error, none of its handlers can be used until the error is fixed.\n\n## Events\n\nLiveCode is based upon events. Every action a script takes is triggered by an event, which is sent in the form of a message.\n\n### What Causes Messages to be Sent\n\nMessages are sent by *events*. Events include user actions (such as typing a key or clicking the mouse button) and program actions (such as completing a file download or quitting the application). LiveCode watches for events and sends a message to the appropriate object when an event occurs.\n\n> **Note:** When a tool other than the Browse tool is active, the development environment traps the built-in messages that are normally sent when clicking (such as **mouseDown** and **mouseUp**). This is so that, for example, you can use the Pointer tool to select and move a button without triggering its **mouseUp** handler.\n\nThese messages are referred to as built-in messages, and include **mouseDown**, **mouseUp**, **keyDown**, **openCard**, and all the other messages described in the LiveCode Dictionary.\n\nLiveCode also sends a message whenever a handler executes a *custom* command (see *Sending Messages*). However, *built-in* commands are executed directly by the engine and don't result in sending a message. Similarly, LiveCode sends a function call whenever a handler calls a *custom* function, a **setProp** trigger whenever a handler sets a *custom* property, and a **getProp** call whenever a handler gets the value of a custom property.\n\n### Responding to Events\n\nTo respond to a message, you write a message handler with the same name as the message. For example, to respond to a **keyDown** message sent to a field (which is sent when the user presses a key while the insertion point is in the field), place a **keyDown** handler in the field's script:\n\n```\non keyDown theKey -- responds to keyDown message\n\tif theKey is a number then beep\nend keyDown\n```\n\n## The Message Path\n\nThe *message path* is the set of rules that determine which objects, in which order, have the opportunity to respond to a message. The message path is based on the *object hierarchy*.\n\n### The Object Hierarchy\n\nEach LiveCode object is part of another object, of a different object type. For example, each card is part of a stack, each grouped control is part of a group, and so on. This *object hierarchy* defines the ownership and inheritance relationship between objects.\n\nFont, color and pattern properties are *inherited* from the objects owner if they are not set. This means that if you set the **textFont** of a stack, all the objects within that stack that do not have their **textFont** property set will use that text font.\n\n### The Message Path\n\nWhen a message is sent to an object, it is often handled directly by a message handler in that object. However if no handler is present, the message will continue along a path until it finds a message handler that can respond to it. This makes it possible to group similar functionality together at different levels within your application. This behavior applies both to event messages sent as a result of a user action, and custom messages sent by script. It is therefore possible to write libraries of common functions.\n\nThe object hierarchy is closely related to the *path* that a message travels on. In most cases, when an object passes a message on, the message goes to the object's owner in the object hierarchy.\n\nThe Message Path is detailed in the figure below.\n\n![](images/image89.png)\n\nFigure 48  The Message Path\n\nFor example, suppose the user clicks a button in a main stack, causing LiveCode to send a **mouseUp** message to the button. If the button's script does not contain a handler for the **mouseUp** message, the message is passed along to the card the button is on. If the card's script contains a **mouseUp** handler, the handler is executed. But if the card does not handle the **mouseUp** message, it is passed on to the card's stack. If the stack script contains a **mouseUp** handler, the handler is executed. But if the stack does not handle the **mouseUp** message, it is passed on to the engine.\n\nThe engine is the end of the message path, and if a message reaches it, the engine takes any default action (e.g. inserting a character into a field or highlighting a button), then throws the message away.\n\nIf a message corresponding to a *custom* command or a *custom* function call reaches the end of the message path without finding a handler, instead of being thrown away, it causes an execution error.\n\n> **Note:** In order to be considered a background (as per the Message Path diagram above), a group must have its **backgroundBehavior** property is set to true.\n\nIf a stack's **dynamicPaths** property is set to true, message handlers in that stack use HyperCard's dynamic path behavior: if a handler uses the **go** or **find** command to go to a card other than the original card, that destination card's message path is inserted into the message path as long as the handler is on that card. The **dynamicPaths** property is provided for compatibility with imported HyperCard stacks, and is normally set to false, but you may encounter this behavior when working with a stack that was originally created in HyperCard.\n\n### The Message Target\n\nThe object that a message *was originally sent* to is called the message's target. You can get the target from within any handler in the message path by using the **target** function.\n\n> **Tip:** To get the name of the object whose script is currently executing, use the **me** keyword.\n\nFor example, if you click a button (causing a **mouseUp** message to be sent), and the button's script contains a **mouseUp** handler, then the **target** function returns the button's name. However, if the button doesn't handle the **mouseUp** message, it's passed to the card, and if the card has a **mouseUp** handler, it is executed in response to the message. In this case, the card's script is executing, but the **target** is not the card--it's the button that was originally clicked, because LiveCode sent the **mouseUp**message to the button.\n\n### Handlers with the Same Name\n\nIf two different objects in the message path each have a handler with the same name, the message is handled by the first object that receives it and has a handler for it.\n\nFor example, suppose that a button's script includes a **mouseUp** handler, and so does the stack script. If you click the button, a **mouseUp** message is sent to the button. Because the button's script has a **mouseUp** handler, the button handles the message, and it isn't passed any further. The message is never sent to the stack script, so for this click event, the stack script's **mouseUp** handler is not executed.\n\n> **Note:** If an object's script has more than one handler with the same name, the first one is executed when the object receives the corresponding message. Other handlers in the same object's script with the same name are never executed.\n\n### Trapping Messages\n\nWhen an object receives a message and a handler for that message is found, the handler is executed. Normally, a message that's been handled does not go any further along the message path. Its purpose having been served, it disappears. Such a message is said to have been *trapped* by the handler.\n\nIf you want to prevent a message from being passed further along the message path, but don't want to do anything with it, an empty handler for the message will block it from being passed on. This example prevents the **mouseDown** message from being acted on by the object the empty handler is in, as well as any objects below it in the object hierarchy:\n\n```\non mouseDown\nend mouseDown\n```\n\nYou can use the same technique to block custom function calls, **setProp** triggers, and **getProp** calls.\n\n### Blocking System Messages\n\nYou can block system messages  for example those sent when you navigate to another card  from being sent while a handler is executing by setting the **lockMessages** property to true.\n\nFor example, if the handler opens another stack, LiveCode normally sends **openCard** and **openStack** messages to the stack. If the stack contains handlers for these messages that would cause unwanted behavior during this operation, you can use the **lockmessages** command before going to the stack in order to temporarily block these messages. When the handler finishes executing, the **lockMessages** property is automatically reset to its default value of false, and normal sending of messages resumes.\n\n> **Tip:** To block navigation messages while testing or debugging a stack, press Suppress Messages on the toolbar or choose **Development -\\> Suppress Messages**.\n\n### Passing a Message to the Next Object\n\nTo let a message pass further along the message path, use the **pass** control structure. The **pass** control structure stops the current handler and sends the message on to the next object in the message path, just as though the object hadn't contained a handler for the message:\n\n```\non openCard\n\tdoSpecialSetupForThisCard\n\tpass openCard -- let stack get the message too\nend openCard\n```\n\n### Selectively Trapping or Passing Messages\n\nSome built-in messages, such as **keyDown**, trigger an action, so trapping the message prevents the action from being performed at all. The following example passes the **keyDown** message only if the character typed is a number:\n\n```\non keyDown theKey\n\tif theKey is a number then pass keyDown\nend keyDown\n```\n\nIf you place this handler in a field's script, it allows the user to enter numbers, but any other keystrokes are trapped by the **keyDown** handler and not allowed to pass.\n\nA similar principle applies to **setProp** triggers. If a **setProp** handler does not pass the **setProp** trigger, the custom property is not set.\n\n### Groups, Backgrounds & The Message Path\n\nAs you can see from the diagram above a group's position in the message path depends on whether the \"Behave as Background\" check box has been set (by script or using the **backgroundBehavior** property).\n\nIf background behavior is false, the group is in the message path for all controls it owns, but is not in the message path of any other object.\n\nIf the background behavior is true, the group is *also* in the message path for any cards it is placed on. If you send a message to a card control, the message passes through the control, then the card, then any background groups on the card in order of **number**, then the stack.\n\nSince a group owns any controls that are part of the group, if you send a message to a control within a group, the group is in the message path for its own controls, regardless of whether its background behavior is true or false. If a group has already received a message because it was originally sent to one of the controls in the group, the message is not sent through the group again after the card has handled it.\n\n> **Tip:** If you want a handler in a group's script to affect only the objects in the group, place the following statement at the beginning of the handler:\n\nif the owner of the target is not me then pass *message*.\n\nThis filters out any objects that are not part of the group.\n\n## Commands and Functions\n\nYou use commands and functions to perform the actions of your application. Commands instruct the application to do something  such as play a movie, display a window, or change a property. Functions compute a value  different functions might add a column of numbers, or get the fifteenth line of a certain file, or find out whether a key is being pressed.\n\n### Using Built-in Commands and functions\n\nLiveCode has over one hundred and fifty built-in commands, and over two hundred built-in functions, all of which are documented in the LiveCode Dictionary.\n\n**Commands**\n\nA command is an instruction to LiveCode to do something. A command is placed at the start of a statement (either the start of a line or after a control structure such as \"then\"). The command is followed by any parameters that specify the details of what the command is to do.\n\nHere are some examples of how built-in commands are used in statements:\n\n```\ngo next card -- go command\nbeep --beep command\nset the hilite of me to true-- set command\n```\n**Functions**\n\nA function call is a request to LiveCode for information. A function is stated using the name of the function, followed by opening and closing brackets that may contain any parameters that specify the details of what the function is to act on.\n\nWhen you use a function in a statement, LiveCode calls the function to compute the specified information, then substitutes that information in the script as if the script had originally written that information in place of the function call. The information returned can therefore be *put* into a *variable* or other *container* by using the put command in front of a function.\n\nHere's an example of how a function is used:\n\n```\nput round(22.3) into field \"Number\"\n```\n\nWhen this statement is executed, LiveCode calls the **round** function. When you round off 22.3, the resulting number is 22, so the statement puts the number 22 into the field.\n\nThe number you're rounding off is placed in parentheses after the **round** function's name. This number is called the function's parameter. A function can have one parameter, or none, or several. The parameters are enclosed in parentheses and, if there's more than one, they're separated with commas. Here are some examples:\n```\nput date() into myVariable -- date function, no parameters\nput length(\"hello\") into me -- length function, 1 parameter\nget average(10,2,4) -- average function, 3 parameters\n```\n> **Important:** A function call, by itself, is not a complete statement. You need to use a function call in conjunction with a command or control structure. (In the first example above, the **round** function is used with the **put** command.)\n\n**Writing function calls with the \"the\" form**\n\nIf a built-in function has no parameters or one parameter, it can be written in a different form, with no parentheses:\n```\nput the date into myVariable -- date function\nput the length of \"hello\" into me -- length function\n```\nIf the function has no parameters, this form is written as the *functionName*. If it has one parameter, this form is written as the *functionName* of parameter.\n\nThe \"the\" form works the same way as the \"()\" form shown above, and you can use the two forms interchangeably for *built-in functions* with fewer than two parameters. The LiveCode Dictionary entry for each built-in function shows how to write both forms.\n\nYou can use the \"the\" form for built-in functions, but not for custom functions that you write. Writing custom functions is discussed later.\n\n### Custom Commands and Functions\n\nYou use custom commands and custom functions the same way as any other command or function.\n\n**Using custom commands**\n\nYou can execute a custom command simply by typing the name of the command you want to send.\n\n```\nmyCommand\n```\n\nYou respond to a custom command's message in the same way, by writing a message handler with the name of the command:\n\n```\non myCommand -- a custom command\n\tbeep 3\n\tgo next card\n\tadd 1 to field \"Card Number\"\nend myCommand\n```\n\nIf you don't specify an object, the message is sent to the object whose script is being executed, and then passes up the message hierarchy as normal.\n\nLike a built-in command, a custom command is an instruction to LiveCode to do something. You can include parameters with a custom command by passing them after the name:\n\n```\ncheckForConnection \"ftp://ftp.example.org\"\nmakePrefsFile fileLoc,field \"Preferences\"\n```\n\nBuilt-in commands can have very flexible syntax:\n\n```\ngo to card 3 of stack \"Dialogs\" as modal\n\tgroup image \"Help Icon\" and field \"Help Text\"\nhide button ID 22 with visual effect dissolve very fast\n```\n\nHowever, the syntax of custom commands is more limited. A custom command can have several parameters, and if there is more than one, they are separated by commas:\n\n```\nlibURLDownloadToFile myFile,newPath,\"downloadComplete\"\n```\n\nrevExecuteSQL myDatabaseID,field \"Query\",\"\\*b\" & \"myvar\"\n\nBut custom commands cannot use words like \"and\" and \"to\" to join parts of the command together, the way built-in commands can. Because of this, custom commands cannot be as English-like as built-in commands can be.\n\n**Using custom functions**\n\nWhen you use the custom function \"fileHeader\" in a statement, the function handler is executed, and the function call is replaced by the value in the **return** statement. This example shows how the function can be used:\n\n```\nput fileHeader(it) into myFileHeaderVar\n```\n\nAnd the corresponding custom function:\n\n```\nfunction fileHeader theFile\n\tput char 1 to 8 of URL (\"file:\" & theFile) into tempVar\n\tput binaryDecode(\"h\\*\",tempVar) into tempVar\n\treturn tempVar\nend fileHeader\n```\n\nLike a built-in function or library function, a custom function call is a request for information. Here are a few examples showing the use of made-up custom functions:\n\n```\nget formattedPath(\"/Disk/Folder/File.txt\")\nput summaryText(field \"Input\") into field \"Summary\"\nif handlerNames(myScript, \"getProp\") is empty then beep\n```\n\nCustom functions don't have a \"the\" form, and are always written with parentheses following the function name. If the function has parameters, they are placed inside the parentheses, separated by commas. If the function doesn't have parameters, the parentheses are empty.\n\n### Passing Parameters\n\nA value that you pass from one handler to another is called a parameter.\n\nIn the example below, the following statement sends the \"alertUser\" message with a parameter:\n\n```\nalertUser \"You clicked a button!\"\n```\n\nThe parameter \"You clicked a button!\" is passed to the \"alertUser\" handler, which accepts the parameter and places it in a parameter variable called \"theMessage\". The \"alertUser\" handler can then use the parameter in its statements:\n\n```\non alertUser theMessage\n\tbeep\n\tanswer theMessage -- uses the parameter \"theMessage\"\nend alertUser\n```\n\n### Passing Multiple Parameters\n\nIf a statement passes more than one parameter, the parameters are separated by commas. The following example has two parameters, \"theMessage\" and \"numberOfBeeps\":\n\n```\non seriouslyBugUser theMessage,numberOfBeeps\n\tbeep numberOfBeeps\n\tanswer theMessage\nend seriouslyBugUser\n```\n\nTo use this custom command, you call it like this:\n\n```\nseriouslyBugUser \"Hello\",5\n```\n\nWhen the \"seriouslyBugUser\" handler is executed with the statement above, the *theMessage* parameter is \"Hello\", and the *numberOfBeeps* parameter is 5.\n\n### Parameter Variables\n\nIn the example above, \"theMessage\" and \"numberOfBeeps\" are the parameter variables. You declare parameter variables in the first line of a handler. When the handler begins executing, the values you passed are placed in the parameter variables. You can use parameter variables the same way as ordinary variables: you can put data into them, use them in expressions, and so on.\n\nParameter variables are local variables, so they go out of existence as soon as the handler stops executing.\n\n**Parameter variable names**\n\nYou can give a parameter any name that's a legal variable name. The names of variables must consist of a single word and may contain any combination of letters, digits, and underscores (\\_). The first character must be either a letter or an underscore.\n\nIt is not the name, but the order of parameters that is significant.\n\n**Empty parameters**\n\nA handler can have any number of parameter variables regardless of the number of parameters passed to it. If there are more parameter variables than there are values to put in them, the remaining parameter variables are left empty. Consider the following handler, which has three parameter variables:\n\n```\non processOrder itemName,itemSize,numberOfItems\n\tput itemName into field \"Name\"\n\tput itemSize into field \"Size\"\n\tif numberOfItems is empty then put 1 into field \"Number\"\n\telse put numberOfItems into field \"Number\"\nend processOrder\n```\n\nThe following statement places an order for one sweater:\n\n```\nprocessOrder \"sweater\",\"large\"\n```\n\nThe statement only passes two parameters, while the \"processOrder\" handler has three parameter variables, so the third parameter variable, \"numberOfItems\", is empty. Because the handler provides for the possibility that \"numberOfItems\" is empty, you can pass either two or three parameters to this handler.\n\n**Setting a default value for a parameter**\n\nTo use a default value for a parameter, you check whether the parameter is empty. If it is, then no value has been passed, and you can simply put the desired default into the parameter, as in the following example:\n\n```\nlogData theData,theFilePath\n\tif theFilePath is empty then\n\t\tput \"logfile\" into theFilePath\n\tend if\n\tput theData into URL (\"file:\" & theFilePath)\nend logData\n```\n\nThe \"logData\" handler puts data into a file, whose name and location you specify in the second parameter. If you only provide one parameter, the handler uses the filename \"logfile\" as the default value, and logs the data to that file:\n\n```\nlogData field 1,\"/Disk/Folder/data.txt\" *-- specifies a file*\nlogData myVariable-- doesn't specify a file, uses \"logfile\"\n```\n\nThe first statement above specifies the second parameter, so it doesn't use the default value. The second statement only specifies one parameter, so the data will be placed in \"logfile\" by default.\n\n### Implicit Parameters\n\nIf a statement passes more parameters than the receiving handler has parameter variables to hold them, the receiving handler can access the extra parameters with the **param** function:\n\n```\nfunction product firstFactor,secondFactor\n\tput firstFactor \\* secondFactor into theProduct\n\n\tif the paramCount \\> 2 then\n\n\trepeat with x = 3 to the paramCount\n\t\tmultiply theProduct by param(x)\n\tend repeat\n\tend if\n\treturn theProduct\nend product\n```\n\nThe function above assumes that two parameters will be passed to be multiplied, but can multiply more numbers by using the **param** function to access parameters beyond the first two. The following statement uses the \"product\" custom function above to multiply four numbers together:\n\n```\nanswer product(22,10,3,7)\n```\n\nWhen the \"product\" handler executes, the first two parameters  22 and 10  are placed in the parameter variables \"firstFactor\" and \"secondFactor\". The third parameter, 3, is accessed with the expression `param(3)`, and the fourth parameter, 7, is accessed with the expression `param(4)`.\n\n### Passing Parameters by Reference\n\nNormally, if you pass a variable name as a parameter, that variable is not changed by anything the called handler does. This is because the variable itself is not passed, only its contents. Passing parameters in this way is called \"passing by value\" because the variable's value--not the variable itself--is what is passed.\n\nIf the name of a parameter variable is preceded with the **@** character, that parameter's value is a variable name, rather than the value in the variable. Changing the parameter variable in the called handler changes the value of the variable in the calling handler. This way of passing parameters is called \"passing by reference\", because you pass a reference to the variable itself instead of just its value.\n\nFor example, the following handler takes a parameter and adds 1 to it:\n\n```\non setVariable @incomingVar\nadd 1 to incomingVar\nend setVariable\n```\n\nThe following handler calls the \"setVariable\" handler above:\n\n```\non mouseUp\n\tput 8 into someVariable\n\tsetVariable someVariable*-- call by reference*\n\tanswer \"someVariable is now:\" && someVariable\nend mouseUp\n```\n\nExecuting this **mouseUp** handler displays a dialog box that says \"someVariable is now: 9\". This is because, since \"someVariable\" was passed by reference to the \"setVariable\" handler, its value was changed when \"setVariable\" added 1 to the corresponding parameter variable.\n\nYou can pass parameters by reference to any custom function or custom command, simply by preceding the parameter name with the **@** character in the first line of the handler, as in the \"setVariable\" example handler above. Do not use the **@** character when referring to the parameter elsewhere in the handler.\n\n> **Note:** If a parameter is passed by reference, you can pass only variable names for that parameter. You cannot pass string literals or expressions using other containers such as fields. Trying to use the \"setVariable\" command described above using the following parameters will cause an execution error:\n\n**Empty parameters**\n\nIf a handler defines a parameter as being passed by reference, you must include that parameter when calling the handler. Omitting it will cause an execution error.\n\n### Returning Values\n\nOnce a function handler has calculated a value, it needs a way to send the result back to the handler that called the function. And if an error occurs during a message handler, it needs a way to send an error message back to the calling handler.\n\nThe **return** control structure is used within a function handler to pass the resulting value back to the calling handler. The returned value is substituted for the function call in the calling statement, just like the value of a built-in function. Take another look at the example from above:\n\n```\nfunction expanded theString\n\trepeat for each character nextChar in theString\n\t\tput nextChar & space after expandedString\n\tend repeat\n\treturn char 1 to -2 of expandedString\nend expanded\n```\n\nIn the custom function example above, the**return** control structure sends the spaced-out string back to the **mouseUp** handler that called the \"expanded\" function.\n\n> **Note:** The **return** control structure stops the handler, so it's usually the last line in the handler.\n\n### Returning an Error from a Message Handler\n\nWhen used in a message handler, the **return** control structure serves a slightly different purpose: it returns an error message to the calling handler.\n\nWhen used in a message handler, the **return** control structure sets the **result** function for the calling handler. If you want to return an error message to the calling handler, use the **return** control structure within the message handler.\n\nHere's an example of a message handler that displays a dialog box:\n\n```\non echoAMessage\n\task \"What do you want to show?\"\n\tif it is empty then return \"No message!\"\t\n\telse answer it\nend echoAMessage\n```\n\nThis handler asks the user to enter a message, then displays that message in a dialog box. If the user doesn't enter anything (or clicks Cancel), the handler sends an error message back to the calling handler. A handler that uses the \"echoAMessage\" custom command can check the **result** function to see whether the command successfully displayed a message:\n\n```\non mouseUp\n\techoAMessage\n\tif the result is empty then beep\nend mouseUp\n```\n\nThe **result** function is also set by many built-in commands in case of an error. If you check the **result** in a handler, the value belongs to whatever command  built-in or custom  that set it last, so if you're going to check the **result**, be sure to do so right after the command whose success you want to check.\n\n### Summary\n\nIn this topic, you have learned that:\n\nA command instructs the application to do something, while a function requests the application to compute a value.\n\nYou create a custom command or custom function by writing a handler for it.\n\nValues that you pass to a handler are called parameters.\n\nTo pass a parameter by reference, you precede its name with an **@** sign in the first line of the handler.\n\nWhen used in a function handler, the **return** control structure returns a value.\n\nWhen used in a message handler, the **return** control structure returns an error message that can be accessed with the **result** function.\n\n## Variables\n\nA variable is a place to store data that you create, which has no on-screen representation. Variables can hold any data you want to put into them. One way to think of a variable is as a box with a name on it. You can put anything you want into the box, and take it out later, by simply providing the variable's name:\n\n```\nput 1 into thisThing -- a variable named \"thisThing\"\nput thisThing into field ID 234\nput \"Hello Again!\" into line 2 of thisThing\n```\n\nBut unlike some other types of *containers*, variables are non-permanent and aren't saved with the stack. Instead, variables are automatically deleted either when their handler is finished running or when you quit the application (depending on the variable's *scope*). You can also use the **delete variable** command to delete a variable. When a variable is deleted, not only the content of the variable disappears, but also the variable itself--the \"box\".\n\n> **Tip:** To save a variable's value, set a custom property of the stack to the value of the variable in your applications **closeStackRequest** or **shutDown** handler. To restore the variable, put the custom property into a variable in the application's **startUp** or **openStack** handler.\n\n### Variable Scope\n\nThe *scope* of a variable is the part of the application where the variable can be used. If you refer to a variable in a handler that's outside the variable's scope, you'll get either an execution error or an unexpected result.\n\nThere are three levels of variable scope: **local**, **scriptlocal**, and **global**. Every variable is one of these three types. The difference between these scopes is in where they can be used and how long their value lasts.\n\n### Local Variables\n\nA local variable can be used only in the handler that creates it. Once the handler finishes executing, the variable is deleted. The next time you execute the handler, the variable starts from scratch: it does not retain what you put into it the last time the handler was executed.\n\nTo create a local variable, you simply put something into it. If you use the **put** command with a variable name that does not yet exist, the variable is automatically created as a local variable:\n\n```\nput true into myNewVar -- creates variable named \"myNewVar\"\n```\n\n> **Tip:** While you can use almost any word that isnt a LiveCode language word  also known as a *reserved word*  for a variable name, it will help you greatly if you get into the habit of naming variables logically and consistently. For details of what names are allowed for variables, see the section on *Variable Names* below. For some recommendations on naming variables, see the section on *Tips for Writing Good Code*, below.\n\nAlternatively, you can create a local variable explicitly by declaring it using the **local** command inside a handler:\n\n> **Important:** If you use a local variable in one handler, and that handler calls another handler, you can't use the local variable in the second handler. If you use a variable with the same name, LiveCode creates a second variable that is local to the second handler. But the two local variables don't affect each other, because they're in different handlers.\n\n```\nlocal myNewVar -- creates variable named \"myNewVar\"\nput true into myNewVar -- puts a value into \"myNewVar\".\n```\n\nOne common source of bugs involves misspelling a local variable name. Normally, doing so doesn't produce an execution error, because if you use a variable that doesn't exist, LiveCode creates it automatically. This means that if you misspell a variable name, LiveCode creates a new variable with the mispelled name. Such a bug may be difficult to track down because it can result in a variable having the wrong value without causing an error message.\n\nTo prevent this problem, you can require all local variables to be declared with the **local** command. You do this by turning on **Script -\\> Variable Checking** in the Code Editor menu bar. If this option is on, trying to use a local variable that doesn't exist will cause an execution error, instead of automatically creating it. Any misspelled variable names will therefore cause an obvious execution error when their handler is executed, making them easy to find.\n\nLocal variables are deleted when the handler that they're used in finishes executing. You can also use the **delete variable** command to delete a local variable.\n\n### Script Local Variables\n\nA script local variable can be used in *any handler* in an object's script. You cannot use a script local variable in handlers in other objects' scripts. Unlike a local variable, a script local variable retains its value even after a handler finishes executing.\n\nTo create a script local variable, you must use the **local** command in the script, but outside any handler. We recommend you always declare script local variables at the top of a script so they in one place and easy to find:\n\n```\nlocal mySharedVariable\non mouseDown\n\tput 2 into mySharedVariable\nend mouseDown\n\non mouseUp\n\tanswer mySharedVariable *-- displays \"2\"*\nend mouseUp\n```\n\n> **Note:** If you put the **local** command in a handler, instead of outside any handler, it creates a local variable instead. The command creates a script local variable only if you put it in the script but not within a handler.\n\nYou can also use the **delete variable** command to delete a script local variable.\n\n### Global Variables\n\nA global variable can be used in any handler, *anywhere* in the application. Unlike a *local* variable, a global variable retains its value even after the handler that created it finishes executing. Unlike a *script local* variable, a global variable can be used by any handler in any object's script.\n\nThe same global variable can be used by any stack during a session. You can declare a global variable in one stack, and use it in others.\n\nTo create a global variable, you must declare it using the **global** command:\n\n```\nglobal someGlobalSetting\n```\n\nYou must also use the **global** command at the start of a handler to make an existing global variable *available* to a handler. While a global variable can be used by any handler, you must do this in any handler you are going to use it in. If you don't declare a global variable before using it, the handler will not take the global variable's existence into account, and will simply create a local variable with the same name.\n\nYou can use the **global** command either inside a handler, or outside any handler at the top of a script (like a script local). If you use the command in a handler, the global variable can be used by any statement in that handler. If you use the command in a script but outside any handler, the global variable is available to every handler in that script.\n\nThe following example shows the use of a global variable in a button script. In this example, the variable is declared outside any handler, so the individual handlers don't need to declare it again:\n\n```\nglobal myGlobal -- declares global for the whole script\non mouseDown -- can use \"myGlobal\"\n\tput 1 into myGlobal\nend mouseDown\n\non mouseUp -- can use \"myGlobal\"\n\tadd 2 to myGlobal\n\tanswer myGlobal-- displays \"3\"\nend mouseUp\n```\n\nTo use the same global variable in a handler where the variable isn't declared in the script, you must place the **global** declaration in the handler:\n\n```\non mouseUp -- in another button's script\n\tglobal myGlobal\n\tadd 5 to myGlobal\n\tanswer myGlobal\nend mouseUp\n```\n\nIf you click the first button, then the secoond, the second button displays the number 8.\n\nAs with script local variables, we recommend you place all **global** declarations in scripts at the top of the script, making the declarations easy for you to find later.\n\n> **Tip:** You can get a list of existing global variables with the **globalNames** function. You can also choose **Development \\> Variable Watcher** to see a list of global variables and change their values. Or you can get the value using the Message Box.\n\nGlobal variables are automatically deleted when you quit the application. You can also use the **delete variable** command to delete a global variable.\n\n### Variable Names\n\nThe names of variables must consist of a single word and may contain any combination of letters, digits, and underscores (\\_). The first character must be either a letter or an underscore. You cannot use any LiveCode language word as a name of a variable.\n\nHere are some examples of **legal** variable names:\n\nsomeVariable\npicture3\nmy\\_new\\_file\n_output\n\nHere are some names that **cannot** be used as variable names:\n\n3rdRock *--* illegal as starts with a digit\nthis&That *--* illegal as \"&\" cannot be used\nMy Variable *-* illegal as it is more than one word\n\nAvoid giving a variable the same name as a custom property. If you refer to a custom property, and there is a variable by the same name, LiveCode uses the contents of the variable as the name of the custom property. Generally this will produce unexpected results.\n\nGlobal variables whose names begin with \"gRev\" are reserved by the LiveCode development environment.\n\nSee the section on *Tips for Writing Good Code* below for advice on choosing variable names.\n\n### Special Variable Types\n\nMost of the time, you use variables that you create yourself, using the **local** or **global** commands, or simply by putting a value into a new variable in order to create it.\n\nLiveCode also creates certain types of variables automatically: *parameter* variables, *command-line* variables, *environment* variables, and the special variable **it**.\n\n**Parameter variables**\n\nIn a handler for a custom command or custom function, you can define parameters on the first line of the handler. For example, the following handler defines two parameters named \"thisThing\" and \"thatThing\":\n\n```\non myHandler thisThing,thatThing\n\tadd thisThing to thatThing\n\tsubtract thatThing from field 2\nend myHandler\n```\n\nWhen you use the custom command or custom function, you can pass values to it using the parameters:\n\n```\nmyHandler 15,4+1\n-- puts \"15\" into the parameter \"thisThing\",\n-- and puts \"5\" into the parameter \"thatThing\"\n```\n\nWhen named parameters are used in a handler, they are called parameter variables. Within the handler, the parameters can be used in the same way as local variables: you can get their value, use them in expressions, and put data into them.\n\nLike local variables, parameter variables persist only as long as the handler is executing.\n\n**Environment variables**\n\nMost operating systems that LiveCode supports provide information about the operating environment in *environment* variables.\n\nYou can access environment variables by prepending the **$** character to the variable's name. For example, the following statement gets the contents of the LOGNAME environment variable, which holds the current user's login name:\n\n```\nget $LOGNAME\n```\n\nSee your operating system's technical documentation to find out what environment variables are available.\n\nYou can also create your own environment variables by prepending the **$** character to the new environment variable's name:\n\n```\nput field 3 into $MYENVVAR\n```\n\n> **Note:** Environment variables behave like global variables and can be used in any handler. However, you do not need to use the **global** command to declare them before using them.\n\nThe environment variables that you create this way are available to the application, and are also exported to processes started up by the **shell** function or the **open process** command.\n\n**Command-line argument variables**\n\nIf you start up the application from a command line, the command name is stored in the variable `$0`and any arguments passed on the command line are stored in numbered variables starting with the **$** character.\n\nFor example, if you start the application by typing the following shell command:\n\n```\nmyrevapp -h name\n```\n\nthen the variable `$0`contains \"myrevapp\" (the name of the application), $1 contains \"-h\", and `$2`contains \"name\".\n\n> **Note:** Command-line argument variables behave like global variables and can be used in any handler. However, you do not need to use the **global** command to declare them before using them.\n\n**The special variable \"it\"**\n\nThe **it** variable is a special local variable used by LiveCode to store certain results.\n\nCertain commands--such as **get**, **convert**, **read from file**, **ask**, and **answer**--put their results in this special variable. For a complete list of commands that use the **it** variable, see the entry for **it** in the LiveCode Dictionary. The following example shows how the **answer** command uses the **it** variable:\n\n```\non mouseUp\n\tanswer \"Go where?\" with \"Backward\" or \"Forward\"\n\t-- the answer command puts the button the user clicked\n\t-- into the it variable:\n\tif it is \"Backward\" then go back\n\telse go next\nend mouseUp\n```\n\nYou can use the **it** variable in the same way as any other local variable, using the **put** command to put things into it and using the variable in expressions to work with the contents.\n\n### Array Variables\n\nA variable can hold more than a single value. A variable that holds more than one value is called an array, and each of the values it holds is called an element. Each element has its own name (called the element's key).\n\nIf you think of a variable as a box with a name, you can think of an array as a box with compartments inside it. Each compartment is an *element*, and each compartment has a name, or *key*, of its own.\n\nYou specify an element of an array variable by using the variable name along with the element's key. You enclose the key in square brackets. The key may be a name, number or variable. Here's an example that shows how to put data into one element of an array:\n\n```\nput \"ABC\" into myVariable[\"myKeyName\"]\n```\n\n> **Note:** If you use a key that's not a number or variable, you should enclose the key's name in double quotes whenever you refer to it. This prevents problems in case there is a variable or reserved word with the same name.\n\nYou can use any element of an array variable in the same way you use the whole variable: put data into the element (or before or after it) and find out what data it contains. In this way, any element of a variable is like a variable in and of itself.\n\nArray elements may contain nested or sub-elements, making them multi-dimensional. This type of array is ideal for processing hierarchical data structures such as trees or XML. To access a sub-element, simply declare it using an additional set of square brackets.\n\n```\nput \"ABC\" into myVariable[\"myKeyName\"][aChildElement]\n```\n\nYou may nest elements within themselves to any number of levels.\n\n**Deleting Elements of an Array**\n\nYou use the **delete variable** command to remove one element from an array variable, in the same way you delete a variable. To delete an element, you specify both the variable and the element's key:\n\n```\ndelete variable myVar[\"myElement\"]\ndelete variable myVar[myElement][child1]\n```\n\nThis statement removes the element named \"myElement\" from the variable \"myVar\", but does not delete the other elements in the array.\n\n**Listing the Elements in an Array**\n\n> **Tip:** To delete the contents of an element without deleting the element itself, put **empty** into the element:\n\nput empty into myVar[\"myElement\"]\n\nYou use the **keys** function to list the elements in an array variable. The **keys** function returns a list of elements, one per line:\n\n```\nput the keys of myArray into listOfElements\n```\n\n**Listing Nested Elements within an Element**\n\nYou use the **keys** function to list the child elements of an element withn an array variable. The **keys** function returns a list of elements, one per line:\n\n```\nput the keys of myArray[node25] into listOfElements\n```\n\n**Transforming a List of Data into an Array**\n\nThe **split** command separates the parts of a variable into elements of an array. You can specify what character in the list you want the data to be split by. The data will be converted into a set of elements named according to where it is split. For example:\n\n```\nput \"A apple,B bottle,C cradle\" into myVariable\nsplit myVariable by comma and space\n```\n\nWill result in the following:\n\n**KEY VALUE**\n\nA apple\n\nB bottle\n\nC cradle\n\nFor more details, see the **split** command in the LiveCode Dictionary.\n\n**Combining the Elements of an Array into a List**\n\nThe **combine** command combines the elements of the *array* into a single variable. After the command is finished executing, the variable specified by *array* is no longer an array.\n\nFor example:\n\n```\ncombine myArray using return\n```\n\nWill combine the contents of the each element of the original *array* so that they appear on a separate line.\n\nFor more information, see the **combine** command in the LiveCode Dictionary.\n\n**Nesting an Array**\n\nYou may place an entire array as a child of an element by putting an array variable into an element of another array. For example:\n\n```\nput tMyArray into tBigArray[node50]\n```\n\nWill result in the entire array being placed as a child of `node50`within tBigArray.\n\n**More Information**\n\nFor more information about using array variables, see the section on *Processing Text and Data*.\n\n### Constants\n\nA constant is a value that has a name. Like a variable, a constant is set in your script. Unlike variables, constants cannot be changed.\n\nWhen you use a constant, LiveCode substitutes the value of the constant for its name. The following example uses a constant named \"slash\":\n\n```\nput slash after field \"Expressions\" *-- displays \"/\"*\n```\n\nYou create a new constant using the **constant** command.\n\nYou cannot put anything into a constant once it's been created.\n\n**Built-in constants**\n\nThe LiveCode language defines several constants, such as **return**, **space**, and **comma**, for characters that have special meaning in scripts and therefore can't be entered literally into an expression.\n\n> **Tip:** To see a list of all built-in constants, open the Documentation window, click LiveCode Dictionary, and choose \"Constants\" from the menu at the top of the window.\n\n**User-defined constants**\n\nYou can also define your own constants using the **constant** command:\n\n```\nconstant myName=\"Joe Smith\"\n```\n\nLike variables, constants can have different scope depending on how they are created. A constant can be defined as either a local constant or a script local constant:\n\nIf you place the **constant** command in a handler, the constant can be used only in that handler.\n\nIf you place the **constant** command in a script, but outside any handler, the constant can be used in any handler in the script.\n\n## Containers, Operators & Sources of Value\n\n### What is a Container?\n\nContainers are sources of information that can be edited using chunk expressions. In addition to variables, LiveCode has six other container types: fields, buttons, images, URLs, the selection, and the message box.\n\nFields, buttons, and imported images are all LiveCode objects. All display their content on the screen, in different ways, and the contents of all three are saved when you save the stack they are in. URLs refer to external resources (either files on the system, or items on an Internet server). The Message Box is a special container that's part of the development environment. All of these containers are covered in more detail in their respective sections.\n\n### Setting and Retrieving Data from Containers\n\nYou use the **put** command to place data into a container, or to place data from a container into another container or variable. Containers support the use of chunk expressions, the ability to specify a portion of a container by referring to it in English. For more details, see the section on *Chunk Expressions*.\n\n### What are Sources of Value?\n\nSources of value are like containers. They can be retrieved using the **get** command. However unlike containers, they cannot be set using the **put** command. Sources of value include properties, function calls, literal strings, and constants.\n\n### Getting and Setting Properties\n\nYou can use the **get** command to retrieve data from properties. Properties may be set using the **set** command. When retrieving data you may use chunk expressions. However you must set a property in its entirety, using the set command. Properties are covered in more detail in the section on *Properties*. Examples of retrieving and setting properties are to be found throughout this *Users Guide*.\n\n### What are Literal Strings?\n\nA literal string is a string of characters whose value is itself. If the string is a number, the value is that number.\n\n### Using Literal Strings\n\nWhen you use a literal string in an expression, LiveCode simply substitutes the string for itself:\n\n```\nput \"Hello World!\" into field 1\nget 1 + 2 + it\nput 1 - 4.234 into field \"Result\"\n```\n\n**Quoting strings**\n\nLiteral strings that consist of more than one word or are reserved words in the LiveCode language must be enclosed in double quotes:\n\n```\nput \"This is a test\" into myVar *-- works*\nput This is a test into myVar *--* **DOESN'T WORK - not quoted**\nput That into myVar *-- works*\nput This into myVar -- DOESN'T WORK - reserved word\n```\n\nIn some contexts, you can use an unquoted one-word literal string without causing a script error. However, you should make a practice of always quoting literal strings (other than numbers), because it ensures that the statement will continue to work properly even if the string becomes a reserved LiveCode word in the future.\n\nIf the **Script -\\> Variable Checking** option is set to true, compiling a script that contains an unquoted literal string causes a script error.\n\n### What are Operators?\n\nUse operators to put together, compare or perform an operation on data. Use a *String Operator* to combine data. Use a *Numeric Operator* to perform a calculation. Finally, use a *Logical Operator* to return true or false.\n\n### Numeric Operators\n\nNumeric operators produce a number as their result. Numeric operators include the arithmetic operators (**+**, **-**, **\\***, **/**, **mod**, **div**, and **^**) and the bitwise operators (**bitAnd**, **bitOr**, **bitXOr**, and **bitNot**). For individual usage instructions, look up the operator you wish to use in the LiveCode Dictionary.\n\nFor example:\n\n```\nput \"1+2 =\" && 1+2 into field \"Eq\" *-- displays \"1+2 = 3\"*\n```\n\n**String operators**\n\nString operators produce a string of characters as their result. String operators are the concatenation operators (**&**, **&&**, and **,**).\n\n```\nput \"1+2 =\" && 1+2 into field \"Eq\" *-- displays \"1+2 = 3\"*\n```\n\n### Logical Operators\n\nLogical operators produce either \"true\" or \"false\" as their result.\n\nLogical operators include the comparison operators (**=**, **\\<\\>**, **\\<**, **\\>**, **\\<=**, **\\>=**), existence operators (**there is a**, **there is no**, **is in**, **is not in**, **is among**, **is not among**, **contains**), data type operators (**is a**, **is not a**), geometry operators (**is within**, **is not within**), and basic logical operators (**and**, **or**, **not**).\n\n```\nif the platform is \"MacOS\" and field \"Time\" \\< zero then*...*\n```\n\n### Binary versus Unary Operators\n\nOperators can use either one argument (a unary operator) or two arguments (a binary operator):\n\n```\n\"a\" & \"b\" -- & is binary\nthere is a field \"c\" -- **there is a** is unary\n```\n\nThe **bitNot**, **there is a**, **there is no**, **is a**, **is not a**, and **not** operators are unary operators. All other operators are binary operators.\n\n### Conversion of Values\n\nLiveCode converts values in expressions to whatever type of data is needed for the operation. This conversion happens automatically, so you don't need to know what type of data you are dealing with in advance (something that in other languages is called \"type casting\").\n\nFor example, suppose you have the following statement:\n\n```\nput char 2 of \"123\" + char 3 of \"456\" into field 3\n```\n\nCharacter 2 of the literal string \"123\" is the single-character string \"2\", and character 3 of the literal string \"456\" is the single-character string \"6\". When LiveCode uses the **+** operator, it automatically converts these strings to numbers so that they can be added together. Then it converts the resulting number back to a string so that it can be placed in a field as text.\n\n### Operator Precedence\n\nWhen you combine sources of value using operators, LiveCode evaluates each source of value in the expression. Next, it applies any operators to arrive at a final value for the expression. LiveCode does not necessarily apply all the operators in right-to-left order.\n\nInstead, it uses the operator precedence order to determine how to compute expressions that include more than one operator. Precedence determines the order in which LiveCode carries out calculations in expressions. If an expression contains more than one operator, the operators with higher precedence are calculated before operators with lower precedence.\n\nFigure 49  Operator Precedence\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|----------------|--------------------------|------------------------------------------------------------------------------------------------------------------------------------|\n| Grouping       | **() **                  | Any part of the expression in parentheses is evaluated first. If parentheses are nested, the innermost values are evaluated first. |\n| Unary          | **-**                    \n| |                                            \n| |                  **not**                   \n| |                                            \n| |                  **bitNot**                \n| |                                            \n| |                  **there is a**            \n| |                                            \n| |                  **there is no**           | Next, unary operations (that act on only one operand) are done. This includes unary minus (which makes a number negative).         |\n| Exponentiation | **^**                    | Next, exponentiation operations are done.                                                                                          |\n| Multiplication | **\\***                   \n| |                                            \n| |                  **/**                     \n| |                                            \n| |                  **div**                   \n| |                                            \n| |                  **mod**                   | Multiplication and division are done next. These are numeric operators and result in a number.                                     |\n| Addition       | **+**                    \n| |                                            \n| |                  **-**                     | Addition and subtraction are done next. These are numeric operators and result in a number.                                        |\n| Concatenation  | **&**                    \n| |                                            \n| |                  **&&**                    \n| |                                            \n| |                  **, **                    | Operations that join two strings are done next. These are string operators and result in a string.                                 |\n| Comparison     | **\\<**                   \n| |                                            \n| |                  **\\<=, ?**                \n| |                                            \n| |                  **\\>**                    \n| |                                            \n| |                  **\\>=, ?**                \n| |                                            \n| |                  **contains**              \n| |                                            \n| |                  **is among**              \n| |                                            \n| |                  **is not among**          \n| |                                            \n| |                  **is in**                 \n| |                                            \n| |                  **is not in**             \n| |                                            \n| |                  **is within**             \n| |                                            \n| |                  **is not within**         \n| |                                            \n| |                  **is a**                  \n| |                                            \n| |                  **is not a **             | Operations that compare two values are done next. These are logical operators and result in either true or false.                  |\n| Equality       | **=, is**                \n| |                                            \n| |                  **\\<\\>, !=, ?, is not **  | Operations that compare two values for equality are done next. These are logical operators and result in either true or false.     |\n| bitAnd         | **bitAnd**               | bitAnd operations are done next.                                                                                                   |\n| bitXOr         | **bitXOr**               | bitXOr operations are done next.                                                                                                   |\n| bitOr          | **bitOr**                | bitOr operations are done next.                                                                                                    |\n| and            | **and**                  | and operations are done next.                                                                                                      |\n| or             | **or**                   | or operations are done last.                                                                                                       |\n| function calls |                          | Functions are evaluated after all possible operators in the functions parameters are evaluated.                                   |\n\n### Using the Grouping Operator *()*\n\nSuppose you want to change the precedence used in an expression. The grouping operator () has higher precedence than all other operators, so you can use it to change the order in which operators are evaluated. In other words, if you enclose part of an expression in parentheses, any operations inside the parentheses are evaluated before anything else happens.\n\nFor example, function calls have higher precedence than division, so the expression the sin of 1/4 means \"get the sine of 1, then divide it by 4\":\n\n```\nget the sin of 1/4 -- does the sin function first\n```\n\nIf you want the sine of 1/4, you need to change the order of evaluation so that the division is done first. You do this by surrounding the part you want evaluated first with parentheses:\n\n```\nget the sin of (1/4) -- does the division first\n```\n\nIf parentheses are nested, the expression within the innermost set of parentheses is evaluated first.\n\n### Factors and Expressions\n\nAn expression is any source of value, or combination of sources of value. Any of the sources of value discussed above  containers, properties, function calls, literal strings, and constants  are simple expressions. You use operators to combine sources of value to produce more complex expressions.\n\n### Defining Factors\n\nA factor is the first fully resolvable portion of an expression. (All factors are expressions, but not all expressions are factors.) A factor can be either a source of value, or an expression that combines sources of value but doesn't include any binary operators outside parentheses. Enclosing an expression in parentheses turns it into a factor.\n\nThese examples show some expressions, along with the first factor in each expression, to help you see the distinction:\n\n**Expression: Its first factor:**\n\n```\n3 + 4 3\n(3 + 4) (3 + 4)\n(3 + 4)/field 4 (3 + 4)\nfield 6 \\* pi field 6\nsin of pi/4 sin of pi\nsin(pi/4) sin(pi/4)\nsin(pi/4) \\* exp2(12) sin(pi/4)\nwhole world whole\n\"whole world\" \"whole world\"\n```\n\n**When it matters**\n\nThe distinction between factors and expressions matters when you're using the **the** form of built-in functions, when you use **URL**, and when you refer to objects.\n\nIf you use the **the** form of a built-in function that has a parameter, the parameter must be a factor, not an expression:\n\n```\nget the sqrt of 4 + 5 *-- yields 7*\nget sqrt(4+5) *-- yields 3*\nget the sqrt of (4 + 5) *-- yields 3*\n```\n\nIn the first example above, although we intended to get the square root of 9, we actually ended up with the square root of 4. This is because the expression `4 + 5`is not a factor (because it contains a binary operator that's not inside parentheses). The first factor in the expression `4 + 5`is 4, so the first example gets the square root of 4 (which is 2), then adds 5 to that result.\n\nThe second example avoids this problem because it doesn't use the \"the\" form of the function. Since the parameter is enclosed in parentheses, you can use either a factor or an expression, and obtain the intended result, the square root of 9.\n\nIn the third example, we turn the expression `4 + 5`into a factor by surrounding it with parentheses. Since the parameter is now a factor, we can get the correct result, even using the **the** form of the function.\n\nWhen referring to URLs, the URL is a factor:\n\n```\nget URL \"file:myfile.txt\" *-- works*\nget URL \"file:\" & \"myfile.txt\" *--* **DOESN'T WORK**\nget URL (\"file:\" & \"myfile.txt\") *-- works*\n```\n\nIn the first example, the URL specified is a factor because it is a simple string with no operators.\n\nThe **URL** in the second example is not a factor, because it includes the binary operator **&**, so the **get** command tries to get the URL \"file:\"  which is nonexistent--and concatenate the content of that **URL** with the string \"myfile.txt\".\n\nIn the third example, we turn the **URL** into a factor by surrounding it with parentheses, providing the expected result.\n\nWhen referring to **cards** or **backgrounds**, the **name**, **number** or **ID** of the object is an expression:\n\n```\ngo card 1 + 1 -- goes to card 2\ngo card 3 of background \"Data\" && \"Cards\"\n-- goes to first card with the group \"Data Cards\"\n```\n\nHowever, when referring to controls (including groups) or stacks, the **name**, **number**, or **ID** of the object is a factor:\n\n```\nanswer field 1 + 10 -- displays field 1 content + 10\nanswer field (1 + 10) -- displays field 11 content\nselect button \"My\" && \"Button\" -- **DOESN'T WORK**\nselect button (\"My\" && \"Button\")  works\n```\n\n## Making Decisions\n\nYou make decisions using the `ifthenelse c`ontrol structure or, if you want to choose from a list of options, use the `switch`control structure.\n\n### Ifthenelse\n\nUse the **if** control structure to execute a statement or list of statements under certain circumstances. For example, you may want your application to respond differently depending on a user action.\n\nThe `if` control structure always begins with the word `if`. There are four forms of the `if` control structure:\n\n```\nif condition then statement [else elseStatement]\n```\n\nThis form may have a line break before the words `then`or else or both.\n\n\n```\nif condition then\n\tstatementList\n[else \n\telseStatementList]\nend if\n\nif condition\nthen statement\n[else\n\telseStatementList\nend if]\n\nif condition then\n\tstatementList\nelse elseStatement\n```\n\nThe *condition* is any expression that evaluates to true or false. The *statementList* or *elseStatementList* consists of one or more LiveCode statements, and can also include if, switch, try, or repeat control structures. The *statement* or *elseStatement* consists of a single LiveCode statement.\n\nIf the *condition* evaluates to true, the *statement* or *statementList* is executed; if the *condition* evaluates to false, the *statement* or *statementList* is skipped. If the if control structure contains an else clause, the *elseStatement* or *elseStatementList* is executed if the *condition* is false.\n\nIf one if control structure is nested inside another, use of the second form described above is recommended, since the other forms may cause ambiguities in interpreting which else clause belongs with which if statement.\n\nThe if control structure is most suitable when you want to check a single *condition*. If you need to check for multiple possibilities, doing something different for each one, use a switch control structure instead.\n\n### Switch\n\nUse the `switch`control structure when you want to choose among several possible values for an expression and then execute a set of statements that depends on the value.\n\n```\nswitch [switchExpression]\n\tcase {caseValue | caseCondition}\n\t\t[statementList]\n\t[default\n\tdefaultStatementList]\nend switch\n```\n\nThe **switch** control structure begins with the word switch on a single line, with an optional *switchExpression*. The **switch** line is followed by one or more case sections. Each case section begins with the case keyword, followed by either a *caseValue* (if a *switchExpression* was included on the **switch** line) or a *caseCondition* (if no *switchExpression* was included). If the *caseValue* is equal to the *switchExpression*, or the *caseCondition* evaluates to true, LiveCode begins executing the following statements.\n\nThe **case** sections may be followed by an optional default section. If no **break** statement has been encountered yet in the switch control structure, the statements in the default section are executed. The **switch** structure ends with an end switch statement.\n\nThe *switchExpression* is any expression. The *caseValue* is any expression. If the *caseValue* evaluates to the same value as the *switchExpression*, the condition is matched for that case section. The *caseCondition* is any expression that evaluates to true or false. (If the *caseCondition* evaluates to true, the condition is matched for that case section. Each *statementList* consists of one or more LiveCode statements, and can also include if, switch, try, or repeat control structures. The *defaultStatementList* consists of one or more LiveCode statements.\n\nFlow of control in a **switch** structure is less complicated than it looks. In general, when LiveCode enters a **switch** control structure, it looks for the first case section whose *caseValue* is equal to the *switchExpression*, or whose *caseCondition* is true. When a matching condition is found, all statements following it are executed--even statements in another case section--until either a break statement is encountered or the **switch** control structure ends.\n\nThis means that if you do not end a **case** section's *statementList* with a break statement, the statements in all the following case sections (and the default section) are executed even if those case sections don't have a matching *caseValue* or a true *caseCondition*. Occasionally, this behavior is useful. However, in most cases, you should place a break statement at the end of each *statementList*. This ensures that only one *statementList* is executed, and the rest are skipped.\n\nThis also means that you can attach more than one *caseValue* or *caseCondition* to the same *statementList*, simply by placing one case line above the next. The following example beeps if the current card is either the last or first card, and goes to the next card otherwise:\n\n```\nswitch (the number of this card)\n\tcase 1\n\tcase (the number of cards)\n\t\t-- either of the above conditions execute the following\n\t\t-- statement:\n\t\tbeep\n\tbreak\n\tdefault\n\t\tgo next card\nend switch\n```\n\nThere is no limit to the number of **case** sections you can include in a **switch** control structure, although the more case sections there are, the more expressions LiveCode must evaluate and the more slowly the **switch** structure executes.\n\n## Extending the Message Path\n\nThis section deals with how to extend the message path, either by adding code libraries to the message path, or by sending messages directly to objects that are not currently in the message path.\n\n### Creating a Code Library\n\nA library is a set of custom commands and custom functions for a specific application or a specific area of functionality. You can create a library for any purpose you want, and put any custom commands and functions into it that you need. Libraries are typically used to store routines that are common across your application. You can also exchange useful libraries with other developers.\n\nTo create a code library, place the handlers you want to use in any object that's available in your stack. This object is now a code library. Then use the **insert script** command to add that object to the message path. To insert the script of a stack into the message path, use the **start using** command. Typically you would run one of these commands as your application is starting up, so that all the scripts can access the libraries you require. Libraries do not need to be in the same stack or even stack file, you can load any stack on disk and then load the libraries within it to make them available to all running stacks. This makes it easy to design your application in modules, share code with other developers or update your application libraries without modifying your application. You can design your standalone application to work in the same way, making it easy to update it using a small patch utility, i.e. without having to reinstall the entire application.\n\n### Using backScripts\n\nTo make the script of an object available to any other handler in LiveCode:\n\n```\ninsert script of card \"Library\" into back\n```\n\nThe script of an object that's been inserted into the back, as in the above example, is called a `backScript`. Such an object is placed last in the message path of all objects. It receives messages after any other object, and just before the engine receives the message. The `backScript` object remains in the message path until the end of the session (or until you remove it with the **remove script** command.)\n\nBecause a backScriptreceives messages after all other objects in the message path, if you place a handler in the `backScript`, it eventually gets all the corresponding messages, no matter what object sent them, unless another object handles them first.\n\n### Using frontScripts\n\nYou can also extend the message path by placing objects into the front of the message path, before any other object. The script of such an object is called a frontscript, and you use the **insert script** command to place the object in the front:\n\n```\ninsert script of button \"Interceptor\" into front\n```\n\nBecause the object is in the front of the message path, it receives messages even before the target of the message. For example, if you click a button, any objects in the front of the message path receive the **mouseUp** message first, before the button. If you place a handler in a frontscript, it receives all the corresponding messages before any other object can handle them.\n\nUse a frontscript when you want to be able to handle a message even if the target object has a handler for it. For example, the LiveCode development environment displays a contextual menu when you **Control-Shift-right-click** an object. It does this with a **mouseDown** handler in a frontscript. Whenever you click an object, the frontscript receives the **mouseDown** message first, and checks whether the needed keys are being pressed. If they are, the handler displays the contextual menu; the **mouseDown** message is trapped and goes no further. Otherwise, the handler passes the message to the next object in the message path, which is the object you clicked.\n\n### Using a Stack's Script with *start using*\n\nThe **start using** command is similar to the **insert script** command, but can be used only to place stacks, not other object types, in the message path.\n\nThe **start using** command inserts the stack at the end of the message path, *after* the object's stack and main stack, but *before* objects that have been inserted into the back with **insert script**.\n\n### Sending Messages Directly to Objects\n\nIf the handler you want to use is not in the message path, instead of inserting it into the path to make it a code library, you can use the **`send`** command to directly `send` a message to the object whose script contains the handler.\n\n> **Tip:** You can use this technique to skip a portion of the message path, by sending the message directly to an object further up the hierarchy.\n\n```\non mouseUp -- in button script\n\tsend \"mouseUp\" to this stack\nend mouseUp\n```\n\nFor example, suppose you have a handler for a custom command called \"`myCommand`\" in the script of a button, and you want to execute that handler from a card script. Since the button is not in the card's message path, you can't simply use the command in the script, because if the \"`myCommand`\" message goes through the card's message path, it won't find the handler. The following statement sends the message directly to the button whose script includes the handler:\n\n```\nsend \"myCommand\" to button \"Stuff\" of card \"Stuff Card\"\n```\n\n> **Important:** When you send a message to an object, the message path for that message starts with the target object. For example, if a stack script contains a **send** command that sends a message to a button, the message moves through the button's message path, not the stack's.\n\nIf you want to use a custom function whose function handler is not in the message path, you can use the **value** function to specify the object. The **value** function can be thought of as an equivalent of the **send** command for function calls.\n\nFor example, if card 1 of a stack contains a function handler called \"myFunction\" you can use the function from within the script of card 3 with the following statement:\n\n```\nget value(\"myFunction(1,2,3)\",card 1)\n```\n\n### The *send* Command versus the *call* Command\n\nThe **call** command is similar to the **send** command. Like the **send** command, the **call** command sends a message to the specified object, allowing you to use handlers that aren't in the message path.\n\nThe difference between **send** and **call** is how they handle object references in the handler that is triggered by the sent message. If the message is sent by the **send** command, object references in the handler are treated relative to the object you sent the message to.\n\nFor example, suppose card 1 of a stack contains the following handler:\n\n```\non showCard\n\tanswer the number of this card\nend showCard\n```\n\nIf a handler in the script of card 3 uses the **send** command to send a \"showCard\" message to card 1, the dialog box displays \"1\", the number of the card the handler is on. However, if the same handler uses the **call** command instead, the dialog box displays \"3\", the number of the card that used the **call** command. In other words, handlers that are triggered by the **send** command use the context of the object the handler is in, while handlers that are triggered by the **call** command use the context of the object that triggered the handler.\n\n### Writing reusable code using behaviors\n\nBehaviors are a method to create common functionality between objects without duplicating the scripts.\n\nAn object with a **behavior** set will act as though its script was set to the script of the **behavior** button. If multiple objects share the same behavior, each will have its own set of script local variables. Any references to **me**, the **owner of me**, etc will resolve to the child object currently executing.\n\nBehavior scripts must be stored in button objects. To set an objects behavior, refer to the long id of the button containing the behavior script.\n\n## Timer Based Messaging\n\nTimers allow you to schedule events to happen in the future. Use timers for updating the display at regular intervals, processing data in chunks, playing animations, displaying status bars, or anywhere where you need to schedule events. Messages can be scheduled with millisecond precision and fire many times a second to create an animation, or can be scheduled to arrive hours later. When you schedule an event to be delivered in the future, LiveCode continues to respond to user events as normal. This makes timer based messaging ideal where you want your user interface to remain responsive while doing data processing or updating the display.\n\n### Delivering a Message in the Future\n\nTo deliver a message after a specified time period, use the `in time`form of the send command.\n\n```\nsend \"updateStatus\" to me in 20 seconds\nsend \"updateAnimation\" to me in 33 milliseconds\n```\n\n### Repeating a Timer Message\n\nIf you want to send a message repeatedly, for example to continuously draw frames in an animation, simply send the same message again at the end of the message handler. The following example starts an animation when the button is clicked on, then updates the frame at 30 frames per second (every 33 milliseconds).\n\n```\non mouseUp\n\tupdateAnimation\nend mouseUp\n\non updateAnimation\n\t-- insert code to update animation here\n\tsend updateAnimation to me in 33 milliseconds\nend updateAnimation\n```\n\nThe result will be that the `updateAnimation`message is sent, it will update the screen then send itself to itself in a 33 milliseconds. The message will continue to be delivered indefinitely. Therefore it is important that you ensure there is an condition in the message handler that will exit when the task is done, without sending the message again. Alternatively you can directly cancel any message to stop the loop (see the section *Canceling a Timer Message* below for more details).\n\nTo create a *smooth script driven animation*, you should allow for the time it takes to redraw the display and for any interruptions (e.g. another intensive process causing your message to be delivered late). Thus it is best to send the message a little more frequently than you need to redraw the screen, and to check each time the message is activated what frame you should currently be on.\n\n```\nlocal lTotalFrames, lStart variables will be available to all script handlers\n\non mouseUp\n\t-- store the current start time\n\tput the milliseconds into lStart\n\t- put the number of frames in your animation here\n\tput 100 into lTotalFrames updateAnimation\nend mouseUp\n```\n\non updateAnimation\n\t-- calculate milliseconds since start\n\tput the milliseconds  lStart into tElapsedTime\n\tput round(tElapsedTime / 33) into tFrameNumber\n\t-- calculate current frame number\n\tif tFrameNumber \\> lTotalFrames then\n \t\t-- if we have reached the end\n \t\tset the currentFrame of image 1 to lTotalFrames\n \t\t- draw the last frame\n \t\texit updateAnimation\n\t\t -- exit without sending updateAnimation again\n \tend if\n\t\n \t-- insert code for drawing the screen here\n \t-- in this example we assume the animation is a simple\n \t-- animated GIF\n \t-- but you could have any type of operation here, e.g.\n \t-- setting the transform of a vector\n \tset the currentFrame of image 1 to tFrameNumber\n \t-- send another updateAnimation message\n\t send updateAnimation to me in 22 milliseconds\nend updateAnimation\n\nFor more example scripts involving timers and animation, see the *Sample Scripts* section of the online documentation.\n\n### Canceling a Timer Message\n\nWhen a timer message is sent, **the result** function contains the ID of the message generated. Use the **cancel** command to cancel that message, preventing it from being delivered. In the following example, a dialog will be displayed 20 seconds after the user moves the mouse over a button. If the mouse moves out of the button before the 20 seconds has elapsed, the dialog will not be displayed.\n\n```\nlocal LTimerID\non mouseEnter\n\tsend \"displayDialog\" to me in 20 seconds\n\tput the result into lTimerID\nend mouseEnter\n\non mouseLeave\n\tcancel lTimerID\n\tend mouseLeave\n\non displayDialog\n\tanswer \"The mouse was over this button for 20 seconds.\"\nend displayDialog\n```\n\n> **Important:** Ensure you have a way to cancel any pending timer messages. Typically you may want to ensure that a timer is cancelled when the card is closed. For example a timer message that draws an animation on the current card will generate a script error if the card is changed and the message is still sent, as the script will no longer be able to find the objects.\n\n### Displaying a List of Pending Timer Messages\n\nYou can get a list of all the currently pending timer based messages using the `pendingMessages`function.\n\n```\nput the pendingMessages into tMessagesList\n```\n\n*tMessagesList* will now contain a list of messages, one per line. Each line consists of four items, separated by commas:*the message ID, *the time the message is scheduled for, *the message name, *the long ID property of the object that the message will be sent to\n\n> **Tip:** You can see a list of all pending messages using the *Message Box* pending messages tab  the fifth icon along. For more details, see the section on the *Message Box*.\n\nFor more details, see the pendingMessages entry in the *LiveCode Dictionary*.\n\n> **Tip:** To cancel all currently pending messages indiscriminately, use the following repeat loop:\n\n```\nrepeat for each line l in the pendingMessages\n\tcancel (item 1 of l)`\nend repeat\n```\n\n## Tips for Writing Good Code\n\nIts worth taking time to establish some conventions in how you write code. There are many benefits to making your coding practices consistent. Consistently named variables are easier to debug during development because you will always know the scope of a particular variable (whether it's a global, or applies only to the current handler, etc.). It makes it easier to understand the code you have written when you come to read it 6 months later. By making appropriate use of functions and libraries, you make your program more modular and therefore easier to modify and add features to in the future. A comprehensive guide to writing good code is beyond the scope of this manual. But we thought it would be helpful to give you some hints and tips\n\n**Variable naming**\n\nUse consistent variable names to make your code easier to understand. It may not seem important now, but when you have forgotten how it works 6 months later it will help to make it readable. It also makes it easier to exchange you code with other members of the LiveCode community, when you need to get help with something.\n\n| Character | Example | Usage                   |  \n|-----------|---------|-------------------------|          \n| g         | gVar    | Global variables        |            \n| t         | tVar    | Handler-local variables |         \n| s         | sVar    | Script-local variables  |          \n| p         | pVar    | Parameters              |                  \n| k         | kVar    | Constants               |          \n| c         | cVar    | Custom properties       |\n\n\n**Variable scope**\n\nAs a general rule of thumb, use a variable with just enough scope and no more for the task at hand. In other words, if a handler local variable is all you need for a calculation, don't use a script local. If a script local would do, don't use a global. This makes it less likely that you will introduce unexpected errors into your code by using the same variable name for different purposes. A handler local variable only has meaning within that handler so you can safely use the same variable name in other handlers.\n\n**Use of comments**\n\nComment your code as you go. Don't write comments where the meaning is obvious. But even a sentence next to a complex routine will help you or others to quickly understand it later.\n\n**Use of functions**\n\nIf you're writing a lot of code, consider whether it can be written as a series of functions instead of as a single monolithic handler. This makes it much easier to understand the function of each discrete section of code. The more you can make these functions \"black boxes\", that take input and produce output without dependences, the easier it will be if you later want to change how that aspect of the code works.\n\n**Explicit Variables**\n\nIf you're working on a larger code base you may want to turn on the Variable Checking option in the Script menu of the Code Editor. This makes LiveCode require that you declare all variables (even script locals) before you can compile your script. It also requires you to place all literal strings in quotes. This method of coding can help you to quickly track down errors as you go by making you think a little about what variables you are going to use at an early stage, and pointing out spelling mistakes.\n\nWhat's most important is that you develop your own consistent style and then stick to it. Once you have been applying some of these techniques for a short time, they will become second nature.\n\nFor a more in-depth look at this subject, we recommend Fourth World's Scripting Style Guide at:\n\n<http://www.fourthworld.com/embassy/articles/scriptstyle.html>\n\n# Processing Text and Data\n\nLiveCode has first-class text and data processing capabilities. LiveCodes unique chunk expressions  the ability to refer to text using English-like statements like \"word 3 to 5 of myVariable\", combined with other powerful features which include regular expressions, XML processing, associative arrays, data encoding and decoding functions and compression and encryption algorithms  make it easy and simple to process text and data of any complexity. This chapter is a reference guide, for an interactive workshop and tutorial resources please see our web site:\n\n[http://www.runrev.com/developers/exploring-LiveCode/working-with-text/](http://www.runrev.com/developers/exploring-revolution/working-with-text/)\n\nThe section *Processing Text and Data* in the *Sample Scripts* within the product documentation contains additional code examples.\n\n## Using Chunk Expressions\n\nChunk expressions are the primary method of working with text in LiveCode. A chunk is an English-like way of describing an exact portion of text. You can use chunks both to retrieve a portion of text, and to edit text. This topic defines the types of chunks you can address and describes the syntax for specifying them.\n\n### Types of Chunks\n\nThe common types of chunks are the **character**, **word**, **line**, or **item**. An item can be delimited by any character you specify. In addition, the **token** chunk is useful when parsing script data.\n\nHere is an example of a chunk expression using the **word** chunk:\n\n```\nput word 1 to 3 of field \"text\" into myVariable\n```\n\n### Using Chunks with Containers\n\nYou can use a chunk of a *container* anywhere you use an entire container. For example, you can use the **add** command to add a number to a line of a field:\n\n```\nadd 1 to word 3 of field \"Numbers\"\n```\n\nYou can also use chunk expressions to replace (using the **put** command) or remove (using the **delete**command) any portion of a container.\n\n### Using Chunks with Properties\n\nYou *can* use chunk expressions to *read* portions of a *property* (such as the **script** property). However, since you change a property with the **set** command rather than the **put** command, you *can't* use a chunk expression to *change* a part of a property's value. Instead, **put** the property value into a variable, use the chunk expression to change the variable, then **set** the property to the variable's contents. The following example shows how to change the third line of an object's **script** property:\n\n```\nput the script of me into tempScript\nput \"-- Last changed by Jane\" into line 3 of tempScript\nset the script of me to tempScript\n```\n\n### The Character Chunk\n\nA **character** is a single character, which may be a letter, digit, punctuation mark, or control character.\n\nA **character** cannot contain any other chunk type. It can be contained in any other chunk type.\n\nYou can use the abbreviation **char** as a synonym for **character** in a chunk expression.\n\n> **Important:** Characters in chunk expressions are assumed to be single-byte characters. To successfully use chunk expressions with Unicode (double-byte) text, you must treat each double-byte character as a set of two single-byte characters. For example, to get the numeric value of the third Unicode character in a field, use a statement like the following:\n\n### The Word Chunk\n\nA **word** is a string of characters delimited by **space**, **tab**, or **return** characters or enclosed by double quotes.\n\nA word can include characters, or tokens, but not items or lines. Words can be contained in a line or item, but not in a token or character.\n\n### The item Chunk and the itemDelimiter Property\n\nBy default, an **item** is a string of characters delimited by commas.\n\nItems are delimited by a character specified in the **itemDelimiter** property. You can change the default *comma* to create your own chunk type by setting the **itemDelimiter** property to any character.\n\nAn item can contain characters, tokens, or words, but not lines. Items can be contained in a line, but not in a word, token, or character.\n\n### The line Chunk and the lineDelimiter Property\n\nBy default, a **line** is a string of characters delimited by the **return** character.\n\nLines are delimited by the character in the **lineDelimiter** property. By default, the **lineDelimiter** is set to **return**, but you can create your own chunk type by setting the **lineDelimiter** property to any character.\n\nA line can contain characters, tokens, words, or items. Lines cannot be contained in any other chunk type.\n\n### The Token Chunk\n\nA **token** is a string of characters delimited by certain punctuation marks. The **token** chunk is useful in parsing LiveCode statements, and is generally used only for analyzing scripts. For full details about the definition of the **token** chunk, see the LiveCode Dictionary.\n\nA token can contain characters, but not any other chunk type. Tokens can be contained in a word, item, or line, but not in a character.\n\n### Specifying a Chunk\n\nThe simplest chunk expression specifies a single chunk of any type. The following statements all include valid chunk expressions:\n\n```\nget char 2 of \"ABC\" *-- yields \"B\"*\nget word 4 of \"This is a test\" *-- yields \"test\"*\nget line 7 of myTestData\nput \"A\" into char 2 of myVariable\n```\n\nYou can also use the ordinal numbers **first**, **last**, **middle**, **second**, **third**, **fourth**, **fifth**, **sixth**, **seventh**, **eighth**, **ninth**, and **tenth** to designate single chunks. The special ordinal **any** specifies a *random* chunk.\n\nput \"7\" into last char of \"1085\" *-- yields \"1087\"*\n\n### Negative Indexes in Chunk Expressions\n\nTo count *backwards* from the end of the value instead of forward from the beginning, specify a *negative* number. For example, the number -1 specifies the last chunk of the specified type, -2 specifies the next-to-last chunk, and so forth. The following statements all include valid chunk expressions:\n\n```\nget item -1 of \"feather, ball, cap\" *-- yields \"cap\"*\nget char -3 of \"ABCD\" *-- yields \"B\"*\n```\n\n### Complex Chunk Expressions\n\nMore complex chunk expressions can be constructed by specifying a chunk within another chunk. For example, the chunk expression `word 4 of line 250`specifies the fourth word of line 250.\n\nWhen combining chunks of different types to construct a complex chunk expression, you must specify the chunk types in order. The following statements all include valid chunk expressions:\n\n```\nchar 7 of word 3 of myValue\nword 9 of item 2 of myValue\nlast char of word 8 of line 4 of myValue\n```\n\nThese, however, are not valid chunk expressions:\n\nword 8 of char 2 of myValue **--chars can't contain words**\n\nitem 9 of first word of myValue **--words can't contain items**\n\nline 3 of last item of myValue **--items can't contain lines**\n\n### Using Parentheses in Chunk Expressions\n\nYou use parentheses in chunk expressions for the same reasons they're used in arithmetic:\n\nTo make a complex expression clearer.\n\nTo change the order in which the parts of the expression are evaluated.\n\nFor example, consider the following statement:\n\n```\nput item 2 of word 3 of \"a,b,c i,j,k x,y,z\" **-- BAD**\n```\n\nThe desired result is \"y\", the second item in the third word. But the statement above causes an execution error, because it asks for an item of a word, and words can't contain items. You can obtain the desired result by using parentheses to change the order of evaluation:\n\n```\nput item 2 of (word 3 of \"a,b,c i,j,k x,y,z\") *-- good*\n```\n\nIn the example above, LiveCode gets the third word first, then gets the second item in that word. By adding parentheses around (word 3 of \"a,b,c i,j,k x,y,z\"), you force LiveCode to evaluate that part of the chunk expression first. The value of the expression in parentheses is \"x,y,z\", and item 2 of \"x,y,z\" is \"y\".\n\nAs with arithmetic expressions, the parts of a chunk expression that are in parentheses are evaluated first. If parentheses are nested, the chunk expression within the innermost set of parentheses is evaluated first. The part that is enclosed in parentheses must be a valid chunk expression, as well as being part of a larger chunk expression:\n\n```\nput line 2 of word 1 to 15 of myValue **-- won't work**\nput line 2 of word (1 to 15 of myValue) **-- won't work**\nput line 2 of word 1 to 15 (of myValue) **-- won't work**\nput line 2 of (word 1 to 15 of myValue) *-- works!*\n```\n\nThe first of the above examples doesn't work for much the same reason as the previous example: words can't contain lines. The second and third examples don't work because neither \"1 to 15 of myValue\" nor \"of myValue\" is a valid chunk expression. However, \"word 1 to 15 of myValue\" is a valid chunk expression, so the last example works.\n\n### Nonexistent Chunks\n\nIf you request a chunk number that doesn't exist, the chunk expression evaluates to empty. For example, the expression `char 7 of \"AB\"`yields empty.\n\nIf you attempt to change a chunk that doesn't exist, what happens depends on what kind of chunk you specify:\n\n**Nonexistent character or word:**\n\nPutting text into a character or word that doesn't exist *appends* the text to the end of the container, without inserting any extra spaces.\n\n**Nonexistent item:**\n\nPutting text into an item that doesn't exist *adds* enough **itemDelimiter** characters to bring the specified item into existence.\n\n**Nonexistent line:**\n\nPutting text into a line that doesn't exist *adds* enough **return** characters to bring the specified line number into existence.\n\n### Specifying a Range\n\nTo specify a portion larger than a single chunk, you specify the beginning and end of the range. These are all valid chunk expressions:\n\n```\nget char 1 to 3 of \"ABCD\" *-- yields \"ABC\"*\nget word 2 to -1 of myValue *-- second word to last word*\nput it into line 7 to 21 of myValue *-- replaces*\n```\n\nThe start and end of the range must be specified as the same chunk type, and the beginning of the range must occur *earlier* in the value than the end. The following are not valid chunk expressions:\n\n```\nchar 3 to 1 of myValue **-- won't work** end cannot be greater than start\nchar -1 to -4 of myValue **-- won't work** 4th from last comes before last\n```\n\n> **Important:** When using negative numbers in a range, remember that numerically, -x comes after `-x+1`. For example, -1 is greater than -2, and -4 is greater than -7. The greater number must come **last** in order to create a valid range.\n\n### Counting the Number of Words, Lines or Items\n\nThe **number** function returns the number of chunks of a given type in a value. For example, to find out how many lines are in a variable, use an expression such as:\n\n```\nthe number of lines in myVariable\n```\n\nYou can also nest chunk expressions to find the number of chunks in a single chunk of a larger chunk type:\n\n```\nthe number of chars of item 10 of myVariable\n```\n\n## Comparing and Searching\n\nLiveCode provides a number of ways of comparing and searching text. For most types of searching and comparing, you will find chunk expressions easy and convenient. However, if you have complex searching needs, you may prefer to use Regular Expressions, covered in the next section.\n\n### Checking if a Part is within a Whole\n\nYou use the **is in** operator to check if some text or data is within another piece of text or data. You can use the reverse **is not in** operator to check if text or data is not within another piece of text or data.\n\n```\n\"A\" is in \"ABC\" -- evaluates to true\n\"123\" is in \"13\" -- evaluates to false\n```\n\nYou can also use the **is in** operator to check whether some text or data is within a specified chunk of another container.\n\n```\n\"A\" is in item 1 of \"A,B,C\" -- evaluates to true\n\"123\" is in word 2 of \"123 456 789\" -- evaluates to false\n```\n\n### Case Sensitivity\n\nComparisons in LiveCode are case insensitive by default (except for Regular Expressions, which have their own syntax for specifying whether or not a match should be case sensitive). To make a comparison case sensitive, set the **caseSensitive** property to true. For more details, see the *caseSensitive* property in the *LiveCode Dictionary*.\n\n### Checking if text is True, False, a Number, an Integer, a Point, a Rectangle, a Date or a Color\n\nUse the **is a** operator for checking whether the user has entered data correctly and for validating parameters before sending them to a handler. The **is an** operator is equivalent to the **is a** operator.\n\nA value **is a**:\n\n**boolean** if it is either true or false\n\n**integer**if it consists of digits (with an optional leading minus sign)\n\n**number** if it consists of digits, optional leading minus sign, optional decimal point, and optional \"E\" or \"e\" (scientific notation)\n\n**point** if it consists of two numbers separated by a comma\n\n**rect** if it consists of four numbers separated by commas\n\n**date** if it is in one of the formats produced by the date or time functions\n\n**color** if it is a valid color reference\n\nThe text you are checking can contain leading or trailing white space characters in all the types except boolean. For example:\n\n```\n\" true\" is true -- evaluates to false\n```\n\nThe **is a** operator is the logical inverse of the **is not a** operator. When one is true, the other is false.\n\n```\n\"1/16/98\" is a date -- evaluates to true\n1 is a boolean -- evaluates to false\n45.4 is an integer -- evaluates to false\n\"red\" is a color -- evaluates to true\n```\n\n> **Tip:** To restrict a user to typing numbers in a field, use the following script\n\n```\non keyDown pKey\n\tif pKey is a number then pass keyDown`\nend keyDown\n```\n\nThe **keyDown** message will only be passed if the key the user pressed is a number. If you trap a **keyDown** message and dont pass it, the key will not be entered into the field. For more details, see the **keyDown** message in the *LiveCode Dictionary*.\n\n### Check if a Word, Item or Line Matches Exactly\n\nThe **is among** operator tells you whether a whole chunk exists exactly within in a larger container. For example, to find out whether the whole word \"free\" is contained within a larger string, use the **is among** operator:\n\n```\n\"free\" is among the words of \"Live free or die\" *-- true*\n\"free\" is among the words of \"Unfree world\" *-- false*\n```\n\nThe second example evaluates to false because, although the string \"free\" is found in the value, it's a portion of a larger word, not an entire word.\n\n### Check if one String Starts or Ends With Another\n\nTo check if one string begins with or ends with another, use the **begins with** or **ends with** binary operators. For example:\n\n```\nfoobar begins with foo -- true\nfoobar ends with bar -- true\nline 5 of tList begins with \"the\"\n```\n\n### Replacing Text\n\nTo replace one string with another, use the **replace** command. (If you want the search string to contain a regular expression, see the section on the *replaceText command* below instead.)\n\n```\nreplace \"A\" with \"N\" in thisVariable -- changes A to N\n```\n\nTo delete text using replace, replace a string with the empty constant.\n\n```\nreplace return with empty in field 1 -- runs lines together\n```\n\nFor more details, see the *replace command* in the *LiveCode Dictionary*.\n\n### Retrieving the Position of a Matching Chunk\n\nThe **offset, lineOffset, itemOffset** and **wordOffset** functions can be used to locate the position chunks within a larger container,. For example, this expression returns the character number where the letter \"C\" was found:\n\n```\nget offset(\"C\",\"ABC\") *-- returns 3*\n```\n\nThe **lineOffset**, **itemOffset**, and **wordOffset** functions can be used similarly to locate lines, items, and words within a larger value.\n\nTo check if an item, line or word matches *exactly* using offset, set the **wholeMatches** property to true.\n\n### Chunks Summary\n\nA chunk expression describes the location of a piece of text in a longer string.\n\nChunk expressions can describe characters, `items`, tokens, words, and lines of text.\n\nTo count backward from the end of a string, use negative numbers. For example, `word` -2 indicates the second-to-last `word`.\n\nYou can combine chunk expressions to specify one chunk that is contained in another chunk, as in `word 2 of line 3 of myVariable`.\n\nFor a range of chunks, specify the start and end points of the range, as in `line 2 to 5 of myVariable`.\n\nTo check if a chunk is within another, use the `is in`operator. To check if a chunk `is a`specified type of data, use the `is a`operator. To check if a chunk starts or ends with another uses the `begins with`or ends with operators.\n\nTo check if a chunk is contained exactly within a string use the `is among` operator. To get an index specifying where a chunk can be found in a container, use the `offset`, line `offset`, item `offset`, and word `offset` functions. To match only a complete chunk within a string, set the wholeMatches to true before using `offset`.\n\n## Regular Expressions\n\nRegular expressions allow you to check if a *pattern* is contained within a string. Use regular expressions when one of the search or comparison chunk expressions does not do what you need (see the section on *Comparing and Searching* above).\n\nLiveCode supports searching for a pattern, replacing a pattern, or filtering the lines in a container depending on whether or not each line contains the pattern. Regular expressions use PERL compatible or \"PCRE\" syntax. Figure 52, below, shows the supported syntax. For more details on the supported syntax, see the PCRE manual at <http://www.pcre.org/man.txt>\n\n### Searching using a Regular Expression\n\nUse the **matchText** function to check whether a string contains a specified pattern.\n\n```\nmatchText(string,regularExpression[,foundTextVarsList])\n```\n\nThe *string* is any expression that evaluates to a string.\n\nThe *regularExpression* is any expression that evaluates to a regular expression.\n\nThe optional *foundTextVarsList* consists of one or more names of existing variables, separated by commas.\n\n```\nmatchText(\"Goodbye\",\"bye\") -- returns true\nmatchText(\"Goodbye\",\"^Good\") -- also returns true\nmatchText /\n(phoneNumber,\"([0-9]+)-([0-9]+-[0-9]+)\",areaCode,phone)\n```\n\nFor more details on this function see the *matchText* function in the *LiveCode Dictionary*.\n\nIf you need to retrieve the positions of the matched substrings in the optional *foundTextVarsList*, use the *matchChunk* function instead of the *matchText* function. These functions are otherwise identical.\n\n### Replacing using a Regular Expression\n\nUse the **replaceText** function to search for a regular expression and replace the portions that match. (If you simply want to replace text without using a regular expression, see the **replace** command instead.)\n\n```\nreplaceText(stringToChange,matchExpression,replacementString)\n```\n\nThe *stringToChange* is any expression that evaluates to a string.\n\nThe *matchExpression* is a regular expression.\n\nThe *replacementString* is any expression that evaluates to a string.\n\n```\nreplaceText(\"malformed\",\"mal\",\"well\")--returns \"wellformed\"\nreplaceText(field \"Stats\",return,comma)-- makes comma-delimited\n```\n\nFor more details, see the *replaceText* function in the *LiveCode Dictionary*.\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------|\n| **[chars]**             | matches any one of the characters inside the brackets                                                                                  | A[BCD]E matches \"ACE\", but not \"AFE\" or \"AB\"                   |\n| **[^chars]**            | matches any single character that is not inside the brackets                                                                           | [^ABC]D matches \"FD\" or \"ZD\", but not \"AD\" or \"CD\"             |\n| **[char-char]**         | matches the range from the first char to the second char. The first chars ASCII value must be less than the second chars ASCII value | A[B-D] matches \"AB\" or \"AC\", but not \"AG\"                      \n| |                                                                                                                                                                                                                                    \n| |                                                                                                                                                                    [A-Z0-9] matches any alphanumeric character                     |\n| **.**                   | matches any single character (except a linefeed)                                                                                       | A.C matches \"ABC\" or \"AGC\", but not \"AC\" or \"ABDC\"             |\n| **^**                   | matches the following character at the beginning of the string                                                                         | ^A matches \"ABC\" but not \"CAB\"                                 |\n| **$**                   | matches the preceding character at the end of a string                                                                                 | B$ matches \"CAB\" but not \"BBC\"                                 |\n| **\\***                  | matches zero or more occurrences of the preceding character or pattern                                                                 | ZA\\*B matches \"ZB\" or \"ZAB\" or \"ZAAB\", but not \"ZXA\" or \"AB\"   \n| |                                                                                                                                                                                                                                    \n| |                                                                                                                                                                    [A-D]\\*G matches \"AG\" or \"G\" or \"CAG\", but not \"AB\"             |\n| **+**                   | matches one or more occurrences of the preceding character or pattern                                                                  | ZA+B matches \"ZAB\" or \"ZAAB\", but not \"ZB\"                     \n| |                                                                                                                                                                                                                                    \n| |                                                                                                                                                                    [A-D]+G matches \"AG\" or \"CAG\", but not \"G\" or \"AB\"              |\n| **?**                   | matches zero or one occurrences of the preceding character or pattern                                                                  | ZA?B matches \"ZB\" or \"ZAB\", but not \"ZAAB\"                     \n| |                                                                                                                                                                                                                                    \n| |                                                                                                                                                                    [A-D]?G matches \"AG\" or \"CAGZ\", but not \"G\" or \"AB\"             |\n| **|**                   | matches either the pattern before or the pattern after the |.                                                                          | A|B matches \"A\" or \"B\"                                         \n| |                                                                                                                                                                                                                                    \n| |                                                                                                                                                                    [ABC]|[XYZ] matches \"AY\" or \"CX\", but not \"AA\" or \"ZB\".         |\n| **\\\\**                  | Causes the following character to be matched literally, even if it has special meaning in a regular expression                         | A\\\\.C matches \"A.C\", but not \"A\\\\.C\" or \"ABC\"\\\\\\\\ matches \"\\\\\" |\n| **any other character** | matches itself                                                                                                                         | ABC matches \"ABC\"                                              |\n\nFigure 50  Regular Expression Syntax\n\n### Filtering using a Wildcard Expression\n\nUse the **filter** command to remove lines in a container that either do, or do not match a specified wildcard expression. Wildcard expressions are similar to regular expressions.\n\n```\nfilter container {with | without} wildcardExpression\n```\n\nThe *container* is any expression that evaluates to a container.\n\nThe *wildcardExpression* is a pattern used to match certain lines.\n\n```\nfilter myVariable with \"A?2\"\nfilter me without \"\\*[a-zA-Z]\\*\"\n```\n\nFor more details, including the format of wildcard expressions, see the *filter command* in the *LiveCode Dictionary*.\n\n## International Text Support\n\nLiveCode provides a number of methods for working with international text. This includes the ability to render and edit Unicode text and convert between various encoding types. We recommend that you consider how you are going to implement international text support as early as possibly in the design of your application.\n\n### What are Text Encodings?\n\nFundamentally computers use numbers to store information, converting those numbers to text to be displayed on the screen. A text encoding describes which number converts to a given character. There are many different encoding systems for different languages. Below is a table containing examples of some common encodings.\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|------------------|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **ASCII**        | Single byte  English | ASCII is a 7-bit encoding, using one byte per character. It includes the full Roman alphabet, Arabic numerals, Western punctuation and control characters. See <http://en.wikipedia.org/wiki/ASCII> for more information.                                                                                                                                                                                                                         |\n| **ISO8859**      | Single byte           | ISO8859 is a collection of 10 encodings. They are all 8-bit, using one byte per character. Each shares the first 128 ASCII characters. The upper 80 characters change depending on the language to be displayed. For example ISO8859-1 is used in Western Europe, whereas ISO8859-5 is used for Cyrillic. **NB:** LiveCode only supports ISO8859-1. You should use Unicode to represent other languages, converting if necessary (see below).     |\n| **Windows-1252** | Single byte  English | This is a superset of ISO8859-1 which uses the remaining 48 characters not used in the ISO character set to display characters on Windows systems. For example curly quotes are contained within this range.                                                                                                                                                                                                                                      |\n| **MacRoman**     | Single byte  English | MacRoman is a superset of ASCII. The first 128 characters are the same. The upper 128 characters are entirely rearranged and bear no relation to either Windows-1252 or ISO8859-1. However while many of the symbols are in different positions many are equivalent so it is possible to convert between the two.                                                                                                                                 |\n| **UTF-16**       | Double byte  Any     | UTF-16 typically uses two bytes per code point (character) to display text in all the worlds languages (see *Introduction to Unicode*, below). UTF-16 will take more memory per character than a single-byte encoding and so is less efficient for displaying English.                                                                                                                                                                           |\n| **UTF-8**        | Multi-byte - Any      | UTF-8 is a multi-byte encoding. It has the advantage that ASCII is preserved. When displaying other languages, UTF-8 combines together multiple bytes to define each code point (character). The efficiency of UTF-8 depends on the language you are trying to display. If you are displaying Western European it will take (on average) 1.3 bytes per character, for Russian 2 bytes (equivalent to UTF-16) but for CJK 3-4 bytes per character. |\n\nFigure 51  Common text encodings\n\n### What are scripts?\n\nA script is a way of writing a language. It takes the encoding of a language and combines it with its alphabet to render it on screen as a sequence of glyphs. The same language can sometimes be written with more than one script (common among languages in India). Scripts can often be used to write more than one language (common among European languages).\n\nScripts can be grouped together into four approximate classes. The \"small\" script class contains a small alphabet with a small set of glyphs to represent each single character. The \"large\" script class contains a large alphabet and with a larger set of glyphs. The \"contextual\" script class contains characters that can change appearance depending on their context. And finally the \"complex\" script class contains characters that are a complex function of the context of the character  there isnt a 1 to 1 mapping between code point and glyph.\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|----------------|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Roman**      | Small script      | The Roman encoding has relatively few distinct characters. Each character has a single way of being written. It is written from left to right, top to bottom. Every character has a unique glyph. Characters do not join when written. For example: The quick brown fox.     |\n| **Chinese**    | Large script      | The Chinese encoding has a large number of distinct characters. Each character has a single way of being written.                                                                                                                                                            |\n| **Greek**      | Contextual script | Every character except sigma has a unique glyph. Sigma changes depending on whether it is at the end of a word or not. Characters do not join when written. The text runs left to right, top to bottom. For example: ![](images/image90.png)                            |\n| **Arabic**     | Contextual script | The glyph chosen is dependent on its position in a word. All characters have initial, medial and terminal glyphs. This results in a calligraphic (joined up) style of display. The text runs right to left, top to bottom display. For example: ![](images/image91.png) |\n| **Devanagari** | Complex script    | In this script there is no direct mapping from character to glyph. Sequences of glyphs combine depending on their context. The text runs from left to right, top to bottom.                                                                                                  |\n\nFigure 52  Common scripts\n\n### Introduction to Unicode\n\nThe purpose of Unicode is to provide a way to display all of the worlds languages. Before Unicode multiple encodings were needed to display text from different parts of the world (see above). In order to use international text in LiveCode, it is necessary to use Unicode.\n\n### How does Unicode work?\n\nUnicode is an international standard (see <http://unicode.org/>). It works by assigning a unique number to every character in all of the worlds languages and works regardless of the platform, program or language in use. In order to have enough space to provide a unique number for every character, Unicode has a 21-bit space of code points. Most characters (though not all) have a 1-1 code unit to character mapping. Each code unit has implicit properties to aid in generalized processing. Most languages have their own specific range of code point values.\n\nAll existing text encodings can round-trip through Unicode, which means that they can be converted into Unicode and then back into their original format without losing data. LiveCode has a number of functions you can use to encode and decode Unicode.\n\nUnicode is not an encoding as such, instead it can be represented in several different encodings (see table above)  UTF-8, UTF-16 or UTF-32.\n\nThe Unicode standard defines algorithms for case mapping, sorting, searching and word-breaking. LiveCode currently has limited support for these functions but can be easily extended using externals.\n\n### Using Unicode in LiveCode Fields and Objects\n\nLiveCode fields and other controls use the UTF-16 encoding for Unicode. In order to use Unicode in a field or in the labels of controls, paste in Unicode text, or set the **textFont** of the control to \",unicode\".\n\nCurrently LiveCode fields support display of complex scripts but does not yet support display of right to left text. Support is planned in the future.\n\nUse the **unicodeText** to get and set the contexts of a field as UTF-16 using a script.\n\n```\nset the unicodeText of field 1 to URL \"binfile:Chinese.txt\" -- displays a file containing UTF-16 text in a field\nput the unicodeText of field 1 into tUnicodeText\n-- retrieves the contents of a field allowing it to\n-- be converted or manipulated by script\n```\n\nTo set the title of a stack to a UTF-16 string use the **unicodeTitle** property.\n\n### Manipulating Unicode  Using UTF-8\n\nWhile LiveCode fields support display of Unicode in UTF-16, LiveCodes chunk expressions are currently not aware of Unicode. Support is planned in the future. At present you should write your own functions to process Unicode text.\n\nIf you want to use the**charToNum** and **numToChar** functions to encode or decode Unicode (UTF-16) characters you should set the local property **useUnicode** to true.\n\n> **Important:** We recommend you use UTF-8 in your application whenever you want to store or manipulate Unicode data. UTF-8 has the advantage that it preserves ASCII punctuation. This means that you can still use the *word*, *item* and *line* chunk expressions to manipulate UTF-8. You cannot use the character chunk as that will return individual bytes.\n\nUTF-8 will round trip through the LiveCode externals interface. Both Mac OS X and Windows have a full set of Unicode-compliant string handling functions that are easy to wrap around. You may want to consider implementing an external if you wish to use these functions to manipulate UTF-8.\n\nYou should convert to and from UTF-16 as necessary for use with fields (see below).\n\n### Converting between UTF-16 and Other Encodings\n\nUse the **uniEncode** function to encode Unicode as UTF-16. Pass to the **uniEncode** function the encoding you are converting from and it will convert the data, assuming the data to be properly encoded in the encoding you have specified.\n\n```\nput uniEncode(inputText,\"Japanese\") into tDisplayText -- converts Shift-JIS to UTF-16\n```\n\nTo convert from UTF-16 back to UTF-8 or to another character set, use the **uniDecode** function. Pass to it the data as UTF-16 together with the desired encoding.\n\n```\nput uniDecode(field \"Japanese\",\"UTF8\") into tUTF8 -- converts a field to UTF8\n```\n\n### Converting between MacRoman and Windows-1252\n\nUse the **ISOToMac** and the **MacToISO** functions to convert between MacRoman and Windows-1252.\n\n> **Tip:** LiveCode automatically performs this translation on the contents of fields and object labels when a stack is loaded on a different platform from the one it was saved on. However data stored in custom properties is not translated as it is treated as binary data, and data in external files is also not affected. You may therefore want to manually translate between the two character sets using these functions.\n\n```\nput ISOToMac(tISOText) into tMacText -- convert from Windows-1252 to MacRoman\nput MacToISO(tMacText) into tMacText -- convert from MacRoman to Windows-1252\n```\n\n## Using Arrays\n\nFor an introduction to arrays, see the section on *Array Variables* in the chapter *Coding in LiveCode*.\n\n### When to Use Arrays\n\nEach element in an array can be accessed in constant time. This compares favorably with other functions that become look up information by counting through a variable from the beginning (for example the offset functions). If you consider a problem that requires the computer to search through the data several times then if the computer has to start at the beginning of the variable, the search will get slower and slower as the search function gets further through the data.\n\nEach element in an array can contain data of any length, making it easier to group together records that contain assorted lengths or delimiter characters.\n\nArrays can contain nested elements. This makes them ideal for representing complex data structures such as trees and XML data that would be hard to represent as a flat structure.\n\nEach sub-array in an array can be accessed and operated on independently. This makes it possible to copy a sub-array to another array, get the keys of a sub-array, or pass a sub-array as a parameter in a function call.\n\nLiveCode includes various functions for converting information to and from arrays, and for performing operations on the contents of arrays.\n\nThese characteristics make arrays useful for a number of data processing tasks, including tasks that involve processing or comparing large amounts of data. For example, arrays are ideal if you want to count the number of instances of a specific word in a piece of text. It would be possible to implement such a word count by iterating through each word and checking if it is present in a list of words, then adding a comma followed by a count to that list of words. Such a method is cumbersome to implement and as the list of words gets longer the routine will slow down because LiveCode has to search the list from the start with each new word. Conversely, implementation with an array is simple. Because each element in an array can be named using a text string, we can create an element for each word and add to the elements contents. Not only is the code much shorter but it is also an order of magnitude faster.\n\n```\non mouseUp\n\t--cycle through each word adding each instance to an array\n\trepeat for each word tWord in field \"sample text\"\n\t\tadd 1 to tWordCount[tWord]\n\tend repeat\n\t-- combine the array into text\n\tcombine tWordCount using return and comma\n\tanswer tWordCount\nend mouseUp\n```\n\n| Text in field \"Sample Text:| Resulting value of tWordCount: |  \n|-----------------------------------------------------|------------------------------------|\n| Single Line  execute single line and short scripts | Global,4 |                                                      \n| Multiple Lines  execute multiple line scripts | Line,3 |                                                            \n| Global Properties  view and edit global properties | Lines,1 |                                                        \n| Global Variables  view and edit global variables | Multiple,2                          \n| |                                                                                           \n| |                                                       Properties,2                        \n| |                                                                                           \n| |                                                       Single,2                            \n| |                                                                                           \n| |                                                       Variables,2                         \n| |                                                                                           \n| |                                                       and,3                               \n| |                                                                                           \n| |                                                       edit,2                              \n| |                                                                                           \n| |                                                       execute,2                           \n| |                                                                                           \n| |                                                       scripts,2                           \n| |                                                                                           \n| |                                                       short,1                             \n| |                                                                                           \n| |                                                       view,2                              \n| |                                                                                           \n| |                                                       ,4  |\n\nFigure 53  Results of running word count script\n\n### Array Functions in LiveCode\n\nThe following is a list of all the functions in LiveCode that work with arrays. For a full description of each one, see the corresponding entry in the LiveCode Dictionary.\n\nEach of these functions can be used on subarrays within an array. Instead of referring to the array variable, refer to x[x]\n\n**add** adds a value to every element in an array where the element is a number\n\n**combine** converts an array into text, placing delimiters you specify between the elements\n\n**customProperties** returns an array of the custom properties of an object\n\n**delete variable** remove an element from an array\n\n**divide** divides each element in an array where the element is a number. For example:\n\n```\ndivide tArray by 3\n```\n\n| Contents of array: | Resulting value of tWordCount: |\n|------------------------|------------------------------------|                     \n| A = 1 | 0.333333 |                                        \n| B = 2 | 0.666667 |                                         \n| C = 3 | 1 |                                         \n| D = 4 | 1.333333 |                                           \n| E = 5 | 1.666667 | \n\nFigure 54  Results of running the divide command on an array \n\n**element** keyword is used in a repeat loop to loop through every element in an array\n\n**extents** finds the minimum and maximum row and column numbers of an array whose keys are integers\n\n**intersect** compares arrays, removing elements from one array if they have no corresponding element in the other\n\n**keys** returns a list of all the elements within an array\n\n**matrixMultiply** performs a matrix multiplication on two arrays whose elements are numbers and whose keys are sequential numbers\n\n**multiply** multiplies a value in every element in an array where the element is a number\n\n**properties** returns an array of the properties of an object\n\n**split** convert text to an array using delimiters that you define\n\n**sum** - returns the sum total of all the elements in an array where the element is a number\n\n**transpose** swaps the order of the keys in each element in an array whose elements are numbers and whose keys are sequential numbers\n\n**union** combines two arrays, eliminating duplicate elements\n\n## Encoding and Decoding\n\nLiveCode includes a number of built-in functions for encoding and decoding data in a variety of popular formats.\n\n### Styled Text\n\nLiveCode supports encoding and decoding styled text as HTML and RTF. This feature is useful when you want to adjust text styles programmatically, or import or export text with style information.\n\n> **Important:** At present HTML conversion support only extends to the styles that the LiveCode field object is capable of rendering.\n\nTo convert the contents of a field to HTML compatible tags, use the **HTMLText** property. This property is documented in detail in the LiveCode Dictionary. You can also set this property to display styled text in a field.\n\n> **Tip:** You can get and set the HTMLText property of a chunk within a field, allowing you to view or change text attributes on a section of the text. \n\nFor example, to set the text style of line 2 of a field to bold:\n\n```\non mouseUp\n\tput the htmltext of line 2 of field \"sample text\" into tText`\n\treplace \"\\<p\\>\" with \"\\<p\\>\\<b\\>\" in tText\n\treplace \"\\</p\\>\" with \"\\</b\\>\\</p\\>\\>\" in tText\n\tset the htmltext of line 2 of field \"sample text\" to tText`\nend mouseUp\n```\n\nWhile this is not as simple as directly applying the style to the text using:\n\nset the textStyle of line 2 of field \"sample\" to \"bold\"\n\nIt does allow you to search and replace text styles or perform multiple complex changes to the text based on pattern matching. Performing a series of changes on the HTMLText in a variable then setting the text of a field once can be quicker than updating the style repeatedly directly on the field.\n\nUse the **HTML** keyword with the *Drag and Drop* features and the *Clipboard* features to perform conversion of data to and from HTML when exchanging data with other applications. For more information see the section on *Drag and Drop* in the chapter *Scripting a User Interface*.\n\nUse the **RTFText** property and **RTF** keyword to work with the RTF format.\n\nUse the **unicodeText** property and **Unicode** keyword to work with Unicode. For more information see the section on *International Text Support*, above.\n\n### URLs\n\nTo encode and decode URLs, use the **URLEncode** and **URLDecode** functions. The **URLEncode** function will make text safe to use with a URL  for example it will replace *space* with *+*. These functions are particularly useful if you are posting data to a web form using the **POST** command, using the **launch URL** command or sending email using the **revMail** function. For more information see the *LiveCode Dictionary*.\n\n| **Text:**                    | **URL Encoded result:**              |\n|------------------------------|--------------------------------------|                              \n| \"Jo Bloggs\" \\<jo@blogs.com\\> |%22Jo+Bloggs%22+%3Cjo%40blogs.com%3E  |                                      \nFigure 55  Results of encoding a URL\n\n### Binary Data  Base64 (for MIME Email Attachments and Http Transfers)\n\nTo encode and decode data in Base64 (e.g. to create an email attachment), use the **base64Encode** and **base64Decode** functions. These functions are useful anywhere you want to convert binary data to text data and back. For more information see the *LiveCode Dictionary*.\n\n### Binary Data  Arbitrary Types\n\nUse the **binaryEncode** and **binaryDecode** functions to encode or decode binary data. These functions are documented in detail in the *LiveCode Dictionary*.\n\n### Character to Number conversion\n\nTo convert a character to and from its corresponding ASCII value use the **charToNum** and **numToChar** functions.\n\n```\nput charToNum(\"a\") -- results in 97\n```\n\nTo convert Unicode characters, set the **useUnicode** local property to true. For more information see the section on *International Text Support*, above.\n\n### Data Compression\n\nTo compress and decompress data using GZIP, use the **compress** and **decompress** functions.\n\nThe following routine asks the user to select a file, then creates a GZip compressed version with a \".gz\" extension in the same directory as the original.\n\n```\non mouseUp\n\tanswer file \"Select a file:\"\n\tif it is empty then exit mouseUp\n \tput it & \".gz\" into tFileCompressed\n \tput compress(URL (\"binfile:\" & it)) into URL (\"binfile:\" & tFileCompressed)\nend mouseUp\n```\n\n### Encryption\n\nTo encrypt or decrypt data use the **encrypt** and **decrypt** commands. These commands are documented in the LiveCode Dictionary.\n\n### Generating a Checksum\n\nUse the **MD5Digest** to generate a digest of some data. Use this function later to determine if the data was changed or to check that transmission of information was complete.\n\n> **Tip:** In this example we save the MD5Digest of a field when the user opens it for editing. In the field script place:\n\n```\non openField\n\tset the cDigest of me to md5Digest(the htmlText of me)\nend openField\n```\n\nIf the field is modified (including if a text style is changed anywhere) then a subsequent check of the MD5Digest will return a different result. In the following example we check this digest to determine whether or not to bring up a dialog alerting the user to save changes:\n\n```\non closeStackRequest\n \tif the cDigest of field \"sample text\" is not md5Digest(the htmlText of field \"sample text\") then\n \t\tanswer \"Save changes before closing?\" with \"No\" or \"Yes\"\n \t\tif it is \"Yes\" then\n \t\t\tsave this stack\n \t\tend if\n\tend if\nend closeStackRequest\n```\n\n## XML\n\nExtensible Markup Language, or XML, is a general-purpose language for exchanging structured data between different applications and across the Internet. It consists of text documents organized into a tree structure. It can generally be understood by both human and machine.\n\nLiveCode includes comprehensive support for XML through its built-in XML library. Additionally, standards exist to support exchange of XML over a network connection (or \"web services\")  most notably through the XML-RPC and SOAP protocols. LiveCode includes a library for using XML-RPC and there are examples of using LiveCode to build SOAP applications available.\n\n### The XML Tree Structure\n\nXML is simply a data tree. It must start with a root node, be well formed and nested. Tags may not overlap. For more information on XML see <http://en.wikipedia.org/wiki/XML>\n\nFigure 52 below shows a typical XML tree. In this example we have represented a simple stack file as XML. The stack file has a single stack with two cards. On the first card there is a field named \"Hello\" with the contents \"Hello World!\". There is a second card, which is blank.\n\n![](images/image92.png)\n\nFigure 56  XML Tree Representation of a Stack\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|----------------------|--------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Root node**        | Root element, document element | The start of the XML document, which includes a declaration the file is XML, the version of XML in use and the text encoding                                        |\n| **Comment**          |                                | Comments can be placed anywhere in the tree. They start with \\<! and end with -\\>. They must not contain double dashes --                                           |\n| **Node**             | Element, tag                   | The items that makes up the content within an XML document                                                                                                          |\n| **Attributes**       |                                | Properties attributable to a given node. A node may have zero or more properties                                                                                    |\n| **Empty node**       | Empty element                  | A method of specifying that a node exists but is empty                                                                                                              |\n| **Entity reference** |                                | A method of specifying special characters. XML includes support for &, \\<, \\>,  and \". Additional entities can be defined using a Document Type Definition or DTD. |\n\n### When to use XML\n\nXML has a number of advantages and disadvantages. It is predominantly useful when exchanging data between different applications or systems. However like any method of data storage or transfer it is not suitable for all types of application.\n\nThe advantages of XML are: it is text based making it more easily readable by humans as well as just machines; it is self describing; it is based on international standards and in widespread use with a large number of editors available for it; the hierarchical structure makes it suitable for representing many types of document; and it is platform independent.\n\nThe disadvantages are that: it is sometimes less efficient than binary or even other forms of text representations of data; for simple applications it is more complicated than may strictly be necessary; and the hierarchical model may not be suitable for all data types.\n\nYou may decide that using XML is the best solution for your particular data storage or transmission requirements. Or you may be working on a project with others where using XML or a web service based on it is a requirement. However in many cases a binary format or database will be more appropriate. You should give consideration to the method you intend to use as early as possible in the design of your application.\n\n### Methods for Handling XML in LiveCode\n\nLiveCode includes a comprehensive XML library for working with XML documents. Using the XML library has the advantage that we include syntax and functions for performing the common operations on XML that you may need. However the disadvantage is that at present the library is implemented as an external command (included built-in to the LiveCode distribution) and thus does not benefit from native LiveCode-engine syntax. If you have simple XML processing requirements you may prefer to use LiveCodes built in chunk expression support to do the parsing, matching or construction of XML. For more information see the section on *Using Chunk Expressions*. However if you are working with complex XML then the library includes a comprehensive suite of features.\n\nIn addition to the XML library, LiveCode has a built-in script-based library for working with XML-RPC.\n\n> **Tip:** To see a list of commands for working with XML-RPC, filter the LiveCode Dictionary with the term XMLRPC.\n\nAn interactive stack demonstrating using the LiveCode XML library is available from <http://support.runrev.com/resources/xml.php>\n\n### The XML Library: Loading, Displaying and Unloading XML\n\nThis section discusses using the XML library in detail.\n\n**Getting Started  Creating an XML Tree in Memory**\n\nIn order to work with an XML document, you start by creating an XML tree of that document in memory. There are two functions **revCreateXMLTreeFromFile** and **revCreateXMLTree**. Use the former to load XML document from a file and create a tree in memory, use the latter to create an XML tree from another data source such as a variable, field or download.\n\n```\nrevCreateXMLTree(XMLText, dontParseBadData, createTree, sendMessages)\nrevCreateXMLTreeFromFile(filePath, dontParseBadData, createTree, sendMessages)\n```\n\nIn **revCreateXMLTree** the *XMLText*is the string containing the XML. In **revCreateXMLTreeFromFile** this parameter is replaced with the *filePath*  the file path to the XML document. Both functions return a single value  the ID of the tree that has been created.\n\n> **Important:** Both functions require you to specify all the parameters. You must store the ID returned by these functions in order to access the XML tree later in your script.\n\nThe dont*ParseBadData* specifies whether or not to attempt to parse poorly formed XML. If this is set to true then bad data will be rejected and generate an error instead of constructing the tree in memory.\n\nThe *createTree* specifies whether to create a tree in memory or not. You will generally want this to be true, unless you are intending only to read in an XML file to determine whether or not it is properly structured.\n\nThe *sendMessages* specifies whether or not messages should be sent when parsing the XML document. Messages can be useful if you want to implement functionality such as a progress bar, progressively render or progressively process data from a large XML file as it is being parsed. If you set this to true, **revXMLStartTree** will be sent when the parsing starts, **revStartXMLNode** will be sent when a new node is encountered, **revEndXMLNode** will be sent when a node has been completed, **revStartXMLData** will be sent at the start of a new block of data and finally **revXMLEndTree** will be sent when processing is finished.\n\n**Retrieving information from an XML tree**\n\nNow that you have created your XML tree in memory (above) and stored the tree ID you can use the functions in this section to retrieve information from within the tree.\n\n> **Important:** Any text you fetch using the LiveCode XML library will be in the encoding specified in the root node of the XML tree.\n\n> **Note:** All the examples in this section assume that we have loaded the XML tree depicted in Figure 52  XML Tree Representation of a Stack, above. We assume that you have loaded this tree using the `revCreateXMLTree`function described above, and that this function has returned a value of 1 as the ID of the tree.\n\n**Retrieving the Root Node**\n\nTo retrieve the *root node* from your XML tree, use the **revXMLRootNode** function.\n\nrevXMLRootNode(treeID)\n\nThe *treeID* contains the ID of the XML tree you want to access. For example, using the following function with sample tree depicted above:\n\n```\nput revXMLRootNode(1) into tRootNode\n```\n\nResults in *tVar* containing: *stackFile*\n\n**Retrieving the First Child Element in a Node**\n\nTo retrieve the first child element use **revXMLFirstChild**.\n\nrevXMLFirstChild(treeID,parentNode)\n\nThe *parentNode* contains the path to the node we want to retrieve the first child from. Nodes are referenced using a file-path like format with / used to denote the root and delimit nodes.\n\nWe can use this function on our sample XML as follows:\n\n```\n-- pass the *stackFile* result in retrieved in tRootNode\n-- to the revXMLFirstChild function:\nput revXMLFirstChild(1,tRootNode) into tFirstChild\n-- EQUIVALENT to the following:\nput revXMLFirstChild(1,\"stackFile\") into tFirstChild\n```\n\nThis results in *tFirstChild* containing: */stackFile/stack*\n\n**Retrieving a list of Children in a Node**\n\nTo retrieve a list of children of a node use **revXMLChildNames**.\n\n```\nrevXMLChildNames(treeID, startNode, nameDelim, childName,includeChildCount)\n```\n\nThe *nameDelim* is the delimiter that separates each name that is returned. To get a list of names, specify return.\n\nThe *childName* is the name of the type of children to list.\n\n*includeChildCount* allows you to include the number of each child in square brackets next to the name.\n\nWe can use this function on our sample XML as follows:\n\n```\nput revXMLChildNames(1,\"/stackFile/stack\", return, \"card\", true) into tNamesList\n```\n\nThis results in *tNamesList* containing:\n\n*card[1]*\n\n*card[2]*\n\n**Retrieving the Contents of the Children in a Node**\n\nTo retrieve a list of children of a node including their contents, use **revXMLChildContents**.\n\n```\nrevXMLChildContents(treeID,startNode,tagDelim,nodeDelim, includeChildCount,depth)\n```\n\nSee above for an explanation of *treeID*, *startNode* and *tagDelim*.\n\nThe *nodeDelim* indicates the delimiter that separates the contents of the node from its name.\n\nThe *depth* specifies the number of generations of children to include. If you use 1 as the depth then all children are return.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLChildContents(1, \"/stackFile/stack\", space, return, true, -1) into tContents\n```\n\nThis results in *tContents* containing:\n\n*card[1] *\n\n*field[1] *\n\n*text[1] Hello World!*\n\n*htmlText[1] \\<p\\>Hello World\\</p\\>*\n\n*card[2]*\n\n**Retrieving the Number of Children in a Node**\n\nTo retrieve the number of children of a node **revXMLNumberOfChildren**.\n\n```\nrevXMLNumberOfChildren(treeID,startNode,childName,depth)\n```\n\nSee above for an explanation of *treeID*, *startNode, childName* and *depth*.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLNumberOfChildren(1, \"/stackFile/stack\", \"card\", -1)into tContents\n```\n\nThis results in *tContents* containing: *2*\n\n**Retrieving the Parent of a Node**\n\nTo retrieve a nodes parent use the **revXMLParent** function.\n\n```\nrevXMLParent(treeID,childNode)\n```\n\nSee above for an explanation of *treeID* and *startNode*.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLParent(1,\"stackFile/stack\") into tParent\n```\n\nResults in *tParent* containing: */stackFile*\n\n**Retrieving an Attributes from a Node**\n\nTo retrieve an attribute from a node use **revXMLAttribute**.\n\n```\nrevXMLAttribute(treeID,node,attributeName)\n```\n\nSee above for an explanation of *treeID* and *node*.\n\nThe *attributeName* is the name of the attribute you want to retrieve the value for.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLAttribute(1,\"/stackFile/stack\",\"rect\") into tRect\n```\n\nThis results in *tRect* containing: *117,109,517,509*\n\n**Retrieving all Attributes from a Node**\n\nTo retrieve all attributes from a node use **revXMLAttributes**.\n\n```\nrevXMLAttributes(treeID,node,valueDelim,attributeDelim)\n```\n\nSee above for an explanation of *treeID* and *node*.\n\nThe *valueDelim* is delimiter that separates the attributes name from its value.\n\nThe *attributeDelim* is delimiter that separates the attributes name & value pair from each other.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLAttributes(1, \"/stackFile/stack/card/field\", tab, return) into tFieldAttributes\n```\n\nThis results in *tFieldAttributes* containing:\n\nname Hello\n\nrect 100,100,200,125\n\n**Retrieving the Contents of Attributes**\n\nTo retrieve the contents of a specified attribute from a node and its children, use **revXMLAttributeValues**.\n\n```\nrevXMLAttributeValues(treeID, startNode, childName, attributeName, delimiter, depth)\n```\n\nSee above for an explanation of *treeID*, *startNode* and *depth*.\n\nThe *childName* is the name of the type of child to be searched. Leave this blank to include all types of children.\n\nThe *attributeName* is the name of the attribute to return the values for.\n\nThe *delimiter* is the delimiter to be used to separate the values returned.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLAttributeValues(1, \"/stackFile/\", , \"rect\", return, -1) into tRectsList\n```\n\nThis results in *tRectsList* containing:\n\n117,109,517,509\n\n100,100,200,125\n\n**Retrieving the Contents of a Node**\n\nTo retrieve the contents of a specified node, use **revXMLNodeContents**.\n\n```\nrevXMLNodeContents(treeID, node)\n```\n\nSee above for an explanation of *treeID* and *node*.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLNodeContents(1, \"/stackFile/stack/card/field/htmlText\") into tFieldContents\n```\n\nThis results in *tFieldContents* containing:\n\n\\<p\\>Hello World\\</p\\>\n\nThe entity references for the \\< and \\> symbols have been translated into text in this result.\n\n**Retrieving Siblings**\n\nTo retrieve the contents of the siblings of a node, use **revXMLNextSibling** and **revXMLPreviousSibling**.\n\n```\nrevXMLNextSibling(treeID,siblingNode)\nrevXMLPreviousSibling(treeID,siblingNode)\n```\n\nThe *siblingNode* is the path to the node to retrieve the siblings from.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLPreviousSibling(1, \"/stackFile/stack/card[2]\") into tPrev\nput revXMLNextSibling(1, \"/stackFile/stack/card\") into tNext\n```\n\nThis results in *tPrev* containing:\n\n/stackFile/stack/card[1]\n\nAnd *tNext* containing:\n\n/stackFile/stack/card[2]\n\n**Searching for a Node**\n\nTo search for a node based on an attribute, use **revXMLMatchingNode**.\n\nrevXMLMatchingNode(treeID, startNode, childName, \\\\ attributeName, attributeValue, depth, [caseSensitive])\n\nSee above for an explanation of *treeID*, *startNode* and *depth*.\n\nThe *childName* is the name of the children you want to include in the search. If you leave this blank all children are searched.\n\nThe *attributeName* is the name of the attribute you want to search.\n\n*attributeValue* is the search term you want to match.\n\n*caseSensitive optionally* specifies whether the search should be case sensitive. The default is false.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLMatchingNode(106,\"/\", ,\"name\", \"Hello\", -1) into tMatch\n```\n\nThis results in *tMatch* containing:\n\n/stackFile/stack/card[1]/field\n\n**Retrieving an Outline of the Tree (or Portion Thereof)**\n\nTo retrieve the contents of a specified node, use **revXMLTree**.\n\n```\nrevXMLTree(treeID, startNode, nodeDelim, padding, includeChildCount, depth)\n```\n\nSee above for an explanation of *treeID*, *startNode, includeChildCount* and *depth*.\n\nThe *nodeDelim* is the delimiter that separates each node in the tree. Use return to retrieve a list of nodes.\n\n*padding* is the character to use to indent each level in the tree.\n\nUsing this function on our example XML file as follows:\n\n```\nput revXMLTree(106,\"/\",return,space,true,-1) into tTree\n```\n\nThis results in *tTree* containing:\n\nstackFile[1]\n\nstack[1]\n\ncard[1]\n\nfield[1]\n\ntext[1]\n\nhtmlText[1]\n\ncard[2]\n\n**Retrieving the Tree as XML (or Portion Thereof)**\n\nTo retrieve the tree as XML use **revXMLText**. Use this function to save the XML to a file after modifying it.\n\n```\nrevXMLText(treeID, startNode, [formatTree])\n```\n\nSee above for an explanation of *treeID* and *startNode*.\n\nThe *formatTree* specifies whether or not to format the returned tree with return and space characters to make it easier to read by a human.\n\nUsing this function on our example XML file as follows:\n\n```\nask file \"Save XML as:\"\nput revXMLText(106,\"/\",true) into URL (\"file:\" & it)\n```\n\nThis results in the file the *user specifies* containing:\n\n\\<stackFile\\>\n\n\\<stack name=\"Example\" rect=\"117,109,517,509\"\\>\n\n\\<card\\>\n\n\\<field name=\"Hello\" rect=\"100,100,200,125\"\\>\n\n\\<text\\>Hello World!\\</text\\>\n\n\\<htmlText\\>&lt;p&gt;Hello World&lt;/p&gt;\\</htmlText\\>\n\n\\</field\\>\n\n\\</card\\>\n\n\\<card/\\>\n\n\\</stack\\>\n\n\\</stackFile\\>\n\n**Validating against a DTD**\n\nTo check the syntax of an XML file conforms to a DTD use **revXMLValidateDTD**. For more information on this function, see the *LiveCode Dictionary*.\n\n**Listing all XML Trees in Memory**\n\nTo generate a list of all XML trees in memory, use **revXMLTrees**. For more information on this function, see the *LiveCode Dictionary*.\n\n**Removing an XML Tree from Memory**\n\nTo remove an XML tree from memory, use **revDeleteXMLTree**. To remove all XML trees from memory, use **revDeleteAllXMLTrees**. Both functions take a single parameter  the ID of the tree to be deleted. You should delete a tree when you have stopped using it. For more information on these functions, see the *LiveCode Dictionary*.\n\nOnce an XML tree has been removed from memory, there is no way to get it back. Use the revXMLText function to retrieve the contents of the entire tree and save it first.\n\n### The XML Library: Editing XML\n\nThis section discusses how to edit XML trees. Before reading this section you should read the section above on loading, displaying and unloading XML.\n\n**Adding a new Child Node**\n\nTo add a new node use the **revAddXMLNode** command.\n\n```\nrevAddXMLNode treeID, parentNode, nodeName, nodeContents, [location]\n```\n\nSee above for an explanation of *treeID*.\n\nThe *parentNode* is the name of the node you want to add the child to.\n\nThe *nodeName* is the name of the new node to create.\n\n*nodeContents* is the contents of the new node.\n\n*location* - optionally specify \"before\" to place the new child at the start of the child nodes.\n\nUse this function to add a button to our example XML file as follows:\n\n```\nrevAddXMLNode 1, \"/stackFile/stack/card/\", \"button\", \"\"\n```\n\nThis results in our tree containing a new button:\n\n\\<?xml version=\"1.0\" encoding=\"UTF-8\"?\\>\n\n\\<!-- This is a comment. --\\>\n\n\\<stackFile\\>\n\n\\<stack name=\"Example\" rect=\"117,109,517,509\"\\>\n\n\\<card\\>\n\n\\<field name=\"Hello\" rect=\"100,100,200,125\"\\>\n\n\\<text\\>Hello World!\\</text\\>\n\n\\<htmlText\\>&lt;p&gt;Hello World&lt;/p&gt;\\</htmlText\\>\n\n\\</field\\>\n\n\\<button\\>\\</button\\>\n\n\\</card\\>\n\n\\<card/\\>\n\n\\</stack\\>\n\n\\</stackFile\\>\n\nTo create another node at the same level as another node, use the **revInsertXMLNode** command instead.\n\n**Appending XML to a tree**\n\nTo add a new node use the **revAppendXML** command.\n\n```\nrevAppendXML treeID, parentNode, newXML\n```\n\nSee above for an explanation of *treeID* and *parentNode*.\n\nThe *newXML* is XML you want to append to the tree.\n\n**Moving, Copying or Deleting a Node**\n\nTo move a node use the **revMoveXMLNode** command.\n\n```\nrevMoveXMLNode treeID, sourceNode, destinationNode [, location] [, relationship]\n```\n\nSee above for an explanation of *treeID*.\n\nThe *sourceNode* is the path to the node you want to move.\n\nThe *destinationNode* is the path to the node you to move to.\n\nThe *location* specifies where the node should be moved to in the list of siblings  it can be either \"before\" or \"after\".\n\nThe *relationship* allows you to specify whether to place the node alongside the destination as a sibling or below the destination as a child.\n\nTo copy a node use **revCopyXMLNode**.\n\nTo delete a node use **revDeleteXMLNode**.\n\n**Putting data into a Node**\n\nTo put data into a node use the **revPutIntoXMLNode** command.\n\n```\nrevPutIntoXMLNode treeID,node,newContents\n```\n\nSee above for an explanation of *treeID* and *node*.\n\nThe *newContents* is the text that the new node will contain.\n\n**Setting an Attribute**\n\nTo set an attribute use the **revSetXMLAttribute** command.\n\n```\nrevSetXMLAttribute treeID,node,attributeName,newValue\n```\n\nSee above for an explanation of *treeID* and *node*.\n\nThe *attributeName* is the name of the attribute you want to set the attribute on.\n\nThe *newValue* is the value to set for the attribute.\n\nUsing this function to add a \"showBorder\" property to our field:\n\n```\nrevSetXMLAttribute 1, \"/stackFile/stack/card/button\", \"showBorder\",\"true\"\n```\n\nThe field tag in our tree now looks like this:\n\n\\<field name=\"Hello\" rect=\"100,100,200,125\" showBorder=\"true\"\\>\n\n**Adding a DTD**\n\nTo add a DTD to the tree, use the **revXMLAddDTD** command.\n\n```\nrevXMLAddDTD treeID,DTDText\n```\n\nSee above for an explanation of *treeID*.\n\nThe *DTDText* is the text of the DTD to add.\n\n## Sorting\n\nSorting data is a common and fundamental operation. Sorting allows you to display data in a user-friendly fashion or code a number of algorithms. LiveCode's intuitive sort features give you the power and flexibility to perform any kind of sorting you may require.\n\n### The Sort Container Command: Overview\n\nTo sort data, use the **sort container** command.\n\n```\nsort [{lines | items} of] container [direction] [sortType] [by sortKey]\n```\n\nThe *container* is a field, button, or variable, or the message box.\n\nThe *direction* is either ascending or descending. If you don't specify a direction, the sort is ascending.\n\nThe *sortType* is one of text, numeric, or dateTime. If you don't specify a sortType, the sort is by text.\n\nThe *sortKey* is an expression that evaluates to a value for each line or item in the container. If the sortKey contains a chunk expression, the keyword **each** indicates that the chunk expression is evaluated for *each* line or item. If you don't specify a sortKey, the entire line (or item) is used as the sortKey.\n\nThe following example sorts the *lines* of a variable alphabetically:\n\n```\nsort lines of field \"sample text\" ascending text\nsort lines of tText descending text\n```\n\nThe following example sorts a collection of *items* numerically:\n\n```\nsort items of field \"sample csv\" ascending numeric\nsort items of tItems descending numeric\n```\n\n### The Sort Container Command: Using Sort Keys\n\nThe *sortKey* syntax allows you to sort each line or item based on the results of an evaluation performed on each line or item.\n\nTo sort the lines of a container by a specific item in each line:\n\n```\nsort lines of tContainer by the first item of each\nsort lines of tContainer by item 3 of each\n```\n\nThe *sortKey* expression will only be evaluated once for every element that is to be sorted. This syntax allows a variety of more complex sort operations to be performed.\n\nThe following example will extract the minimum and maximum integers present in a list:\n\n```\nset the itemDelimiter to \".\"\nsort lines of fld 1 numeric by char 2 to -1 of the first item of each\nput char 2 to -1 of the first item of the first line of fld 1 into tMinimumInteger\nput char 2 to -1 of the first item of the last line of fld 1 into tMaximumInteger\n```\n\n| **Original list:** | **Result:**     \n|--------------------|-----------------------|                 \n| F54.mov | tMinimumInteger is 3 |                                \n| M27.mov | tMaximumInteger is 54  |                               \n| M7.mov |                                \n| F3.mov |      \n| |                 \n\nFigure 57  Results of sort command using sort key\n\n### The Sort Container Command: Sorting Randomly\n\nTo sort randomly, use the **random** function to generate a random number as the *sortKey* for each line or item, instead of evaluating the line or item's contents. For example:\n\n```\nput the number of lines of tExampleList into tElementCount\nsort lines of tExampleList ascending numeric by random(tElementCount)\n```\n\n### The Sort Container Command: Stable Sorts  Sorting on Multiple Keys\n\nTo sort a list by multiple criteria you can sort multiple times. This is because LiveCode uses a stable sort, meaning that if two items have the same sort key their relative order in the output will not change. To perform a stable sort, start with the least significant or important criteria and work up to the most important or significant. For example:\n\n```\nsort lines of fld 1 ascending numeric by item 2 of each\nsort lines of fld 1 ascending text by the first item of each\n```\n\n| **Original list:** | **Result:** |\n|--------------------|-------------|                    \n| Oliver,1.54        | Elanor,5.67 |                            \n| Elanor,5.67        | Elanor,6.3  |                             \n| Marcus,8.99        | Marcus,8.99 |                            \n| Elanor,6.34        | Oliver,1.54 |                             \n| Oliver,8.99        | Oliver,8.99 |                             \n| Tim,3.44           | Tim,3.44    |       \n| |                                   \nFigure 58  Results of sorting multiple items\n\n> **Tip:** If you have a large data set and want to improve performance by only performing a single sort, you can construct a sort key that gives the appropriate ordering. In this example a good way to do that is to use the **format** function to construct a fixed length string, one element per sort:\n\n```\nsort lines of fld 1 ascending text by \\\\\nformat(\"%-16s%08.2f\", item 1 of each, item 2 of each)\n```\n\nThis formats each individual line similar to the following:\n\nOliver 00001.54\nElanor 00005.67\n\nThese lines now sort the required way as if the first field (the name) ties, the order is determined by the second field  due to the use of padding characters making all the fields the same size.\n\n### Sorting Cards\n\nTo sort cards, use the **sort** command.\n\n```\nsort [marked] cards [of stack] [direction] [sortType] by sortKey\n```\n\nThe *stack* is a reference to any open stack. If you don't specify a stack, the cards of the current stack are sorted.\n\nThe *direction* is either ascending or descending. If you don't specify a direction, the sort is ascending.\n\nThe *sortType* is one of text, international, numeric, or dateTime. If you don't specify a sortType, the sort is by text.\n\nThe *sortKey* is an expression that evaluates to a value for each card in the stack. Any object references within the sortKey are treated as pertaining to each card being evaluated, so for example, a reference to a field is evaluated according to that field's contents on each card. Typically the sort command is used with *background* fields that have their *sharedText* property set to false so that they contain a different value on each card.\n\nFor example to sort cards by the contents of the last name field on each:\n\n```\nsort cards by field \"Last Name\"\n```\n\nTo sort cards by the numeric value in a ZIP Code:\n\n```\nsort cards numeric by field \"ZIP code\"\n```\n\n> **Tip:** To sort cards by a custom expression that performs a calculation, you can create a custom function:\n```\nsort cards by myFunction() -- uses function below\n```\n\n```\nfunction myFunction\n\tput the number of buttons of this card into tValue\n\t-- perform any calculation on tValue here\n\treturn tValue\n\t-- sort will use this value\nend myFunction\n```\n\n# Programming a User Interface\n\nThe user interface for your application is often one of its most important features. In Chapter 4 we looked at how you build a user interface using LiveCodes tools and development environment. In this chapter we look at how you can edit, or even build a user interface programmatically. Everything you can do using the built-in tools you can also do programmatically. You can even create and modify a user interface at run time in a standalone application, or provide interactive methods for your users to modify specific aspects of your application. This set of capabilities allow you to produce applications that construct their interface using XML files or a custom data structure, programmatically construct aspects of complex interfaces, modify their look using user specified parameters, create themed or skinned interface options, build your own interface editing tools that plug-in to LiveCodes IDE and much more. You can also create custom objects and attach your own virtual behaviors and custom properties to them. We recommend you spend a little time becoming familiar with building an interface using the tools in the development environment before creating or editing an interface programmatically.\n\n## Referring to Objects\n\nIn general, you can refer to any object by its **name**, **number**, or **ID** property.\n\n### Referring to objects by name \n\nYou can refer to an object using its object type followed by its name. For example, to refer to a button named \"OK\", use the phrase `button \"OK\"`:\n\n```\nset the loc of button \"OK\" to 32,104\n```\n\nTo change an object's name, enter a name in the object's property inspector, or use the **set** command to change the object's **name** property:\n\n```\nset the name of field \"Old Name\" to \"New Name\"\nselect after text of field \"New Name\"\n```\n\n### Referring to objects by number\n\nA control's number is its layer on the card, from back to front. A card's number is its position in the stack. A stack's number is the order of its creation in the stack file. A main stack's number is always zero.\n\nYou can refer to an object using its object type followed by its number. For example, to refer to the third-from-the-back field on a card, use the phrase \"field 3\":\n\n```\nset the backgroundColor of field 3 to blue\n```\n\nTo change the number of a card or control, change the Layer box in the Size & Position pane of the object's property inspector, or use the **set** command to change the object's **layer** property:\n\n```\nset the layer of field \"Backmost\" to 1\n```\n\n> **Tip:** New objects are always created at the top layer. To refer to an object you've just created, use the ordinal **last**:\n\n```\ncreate button\nset the name of last button to \"My New Button\"\n```\n\n### Referring to objects by ID\n\nEach object in LiveCode has an ID number. The **ID** property never changes (except for stack IDs), and is guaranteed unique within the stack: no two objects in the same stack can have the same **ID** property.\n\nYou can refer to an object using its object type, then keyword `ID`, followed by its `ID` number. For example, to refer to a card whose **`ID`** property is 1154, use the phrase card `ID` 1154:\n\n```\ngo to card ID 1154\n```\n\nYou cannot change an object's **ID** property (except for a stack).\n\n> **Important:** Wherever possible, you should name your objects and refer to them by name instead of using number or ID. Both the number and ID properties will change if objects are copied and pasted. Additionally, your scripts will rapidly become difficult to read if there are many ID or numerical references to objects.\n\n### Referring to objects by ordinal\n\nYou can refer to an object using its object type followed by the ordinal numbers **first** through **tenth**, or the special ordinals **middle** and **last**. To refer to a random object, use the special ordinal **any**. For example, to refer to the last card in the current stack, use the special ordinal **last**:\n\n```\ngo to last card\n```\n\n### The special descriptor this\n\nUse the **this** keyword to indicate the current stack, or the current card of a stack:\n\n```\nset the backgroundColor of this stack to white\nsend \"mouseUp\" to this card\nset the textFont of this card of stack \"Menubar\" to \"Sans\"\n```\n\n### Control references\n\nA control is any object that can appear on a card. Fields, buttons, scrollbars, images, graphics, players, EPS objects, and groups are all controls. Stacks, cards, audio clips, and video clips are *not* controls.\n\nYou can refer to an object of any of these object types using the word \"control\", followed by an ID, name, or number:\n\n```\nhide control ID 2566\nsend mouseDown to control \"My Button\"\nset the hilite of control 20 to false\n```\n\nIf you use a name, as in the expression `control \"Thing\"`, the reference is to the first control (with the lowest **layer**) that has that name.\n\nWhen you refer to a control by number using its object type, the reference is to the Nth control of that type. For example, the phrase field 1 refers to the lowest field on the card. This may not be the lowest control, because there may be controls of other types underneath field 1. However, when you refer to a control by number using the word control, the reference is to the Nth control of any type. The phrase control 1 refers to the lowest control on the card, which may be of any type.\n\n> **Tip:** To refer to the object underneath the mouse pointer, use the **mouseControl** function.\n\n### Nested Object References\n\nTo refer to an object that belongs to another object, nest the references in the same order as the object hierarchy. For example, if there is a button called \"My Button\" on a card called \"My Card\", you can refer to the button like this:\n\n```\nshow button \"My Button\" of card \"My Card\"\n```\n\nYou can mix names, numbers, ordinal references, and IDs in a nested object reference, and you can nest references to whatever depth is required to specify the object. The only requirement is that the order of references be the same as the order of the object hierarchy, going from an object to the object that owns it. Here are some examples:\n\n```\nfield ID 34 of card \"Holder\"\nplayer 2 of group \"Main\" of card ID 20 of stack \"Demo\"\nfirst card of this stack\n```\n\nstack \"Dialog\" of stack \"Main\" *-- \"Dialog\" is a substack*\n\nIf you don't specify a card in referring to an object that is contained by a card, LiveCode assumes the object is on the current card. If you don't specify a stack, LiveCode assumes the object is in the current stack. You can reference a control in another stack by either of the following methods:\n\nUse a nested reference that includes the name of the stack:\n\n```\nfield 1 of stack \"My Stack\"\ngraphic \"Outline\" `of` card \"Tools\" `of` stack \"Some Stack\"\n```\n\nSet the **defaultStack** property to the stack you want to refer to first. The **defaultStack** specifies the current stack, so you can refer to any object in the **defaultStack** without including a stack name. This example sets a checkbox in the current stack to have the same setting as a checkbox in another stack called \"Other Stack\":\n\n```\nput the defaultStack into savedDefault -- so you can set it back later\nset the defaultStack to \"Other Stack\"\n\nput the hilite of button \"Me\" into meSettin -- this button is in \"Other Stack\"\nset the defaultStack to savedDefault\n\nset the hilite of button \"Me Too\" to meSetting -- this button is in the original stack\n```\n\nIf an object is in a group, you can include or omit a reference to the group in a nested reference to the object. For example, suppose the current card contains a button called \"Guido\", which is part of a group called \"Stereotypes\". You can refer to the button with any of the following expressions:\n\n```\nbutton \"Guido\"\nbutton \"Guido\" of card 5\nbutton \"Guido\" of group \"Stereotypes\"\nbutton \"Guido\" of group \"Stereotypes\" of card 5\n```\n\nIf there is no other button named \"Guido\" on the card, these examples are equivalent. If there is another button with the same name in another group (or on the card, but not in any group), you must either specify the group (as in the second and third examples) or refer to the button by its **ID** property, to be sure you're referring to the correct button.\n\n## Properties\n\nA property is an attribute of a LiveCode object. Each type of object has many built-in properties, which affect the object's appearance or behavior. You can also define custom properties for any object, and use them to store any kind of data.\n\nThis topic discusses how to use properties, how properties are inherited between objects, and how to create and switch between collections of property settings.\n\nTo fully understand this topic, you should know how to create objects, how to use an object's property inspector, and how to write short scripts.\n\n### Using Object Properties\n\nA property is an attribute of an object, and each object type has its own set of built-in properties appropriate for that type. An object can be *completely described* by its built-in properties; if you could make all the properties of two objects identical, they'd be the same object. It is thus possible to describe an object entirely as an array of properties, or to export and import properties using text or XML files. More details on some of the methods you can use to do this are covered later in this chapter.\n\n> **Note:** Since no two objects can have the same **ID** property, it's not possible in practice for two different objects to become the same object, because the **ID** will always be different.\n\nBuilt-in properties determine the appearance and behavior of stacks and their contents--fonts, colors, window types, size and placement, and much more  as well as much of the behavior of the LiveCode application. By changing properties, you can change almost any aspect of your application. When you combine the ability to change properties with the ability to create and delete objects programmatically, you can modify every aspect of your application (subject to any limitations of the license agreement applicable to your edition of LiveCode).\n\n### Referring to properties\n\nProperty references consist of `the` word `the`, `the` property name, `the` word of, and a reference to `the` object:\n\n```\nthe armedIcon of button \"My Button\"\nthe borderWidth of field ID 2394\nthe name of card 1 of stack \"My Stack\"\n```\n\nProperties are sources of value, so you can get the value of a property by using it in an expression:\n\n```\nput the height of field \"Text\" into myVar\nput the width of image \"My Image\" + 17 after field \"Values\"\nif item 1 of the location of me \\> zero then beep\n```\n\nFor example, to use the **width** property of a button as part of an arithmetic expression, use a statement like the following:\n\n```\nadd the width of button \"Cancel\" to totalWidths\n```\n\nThe value of the property  in this case, the width of the button in pixels  is substituted for the property reference when the statement is executed.\n\nTo see a list of all the language words (including properties) applicable to a particular object type, open the *Documentation* window, click *Dictionary*, *right-click* on the *header bar* to turn on the object type you want, then sort the list by clicking on that object header.\n\n### Changing properties\n\nTo change the value of a property, you use the **set** command:\n\n```\nset the borderColor of group \"My Group\" to \"red\"\nset the top of image ID 3461 to zero\n```\n\nYou can also see and change many of an object's properties by selecting the object and choosing *Object Inspector*. See the chapter *Building a User Interface* for more details.\n\nMost built-in properties affect the appearance or behavior of the object. For example, a button's **height**, **width**, and **location** are properties of the button. Changing these properties in a handler causes the button's appearance to change. Conversely, dragging or resizing the button changes the related properties.\n\n**Read-only properties**\n\nSome properties can be read, but not set. These are called read-only properties. Trying to set a read-only property causes an execution error.\n\nTo find out whether a property is read-only, check its entry in the LiveCode Dictionary.\n\n**Changing a part of a property**\n\nProperties are not containers, so you cannot use a chunk expression to change a *part* of the property. However, you can use a chunk expression to *examine* part of a property. For example, you cannot set line 1 of a property to a new value: you must set the whole property. For more details see the section *Chunk Expressions* in the chapter on *Processing Text and Data*.\n\nTo change one part of a property, first put the property value into a variable, change the required part of the variable, then set the property back to the new variable contents:\n\n```\nput the rect of me into tempRect\nput \"10\" into item 2 of tempRect\nset the rect of me to tempRect\n```\n\n**Custom properties and virtual properties**\n\nA custom property is a property that you define. You can create as many custom properties for an object as you want, and put any kind of data into them, including binary data or array data. You can even store a file in a custom property.\n\nVirtual properties are custom properties that trigger a custom script action when you change them, allowing you to implement \"virtual\" object behaviors.\n\n*Custom properties* and *virtual properties* are covered in their respective sections later in this chapter.\n\n### Property Inheritance\n\nMost properties are specific to the object they are part of, and affect only that object.\n\nHowever, some properties of an object, such as its color and text font, take on the settings of the object above it in the object hierarchy. For example, if a field's background color property is not specified (that is, if its **backgroundColor** property is empty), the field takes on the background color of the card that owns it. If no background color is specified for the card either, the stack's background color is used, and so on. This means you can set a background color for a stack, and every object in it will automatically use that background color, without your having to set it for each object.\n\nThis process of first checking the object, then the object's owner, then the object that owns that object, and so on, is called *inheritance* of properties. Each object inherits the background color of the object above it in the hierarchy. Similar inheritance rules apply to the **foregroundColor**, **topColor**, **bottomColor**, **borderColor**, **shadowColor**, and **focusColor** properties, to their corresponding pattern properties, and to the **textFont**, **textSize**, and **textStyle** properties.\n\n### Overriding inheritance\n\nInheritance is used to determine an object's appearance only if the object itself has no setting for the property. If an inheritable property of an object is not empty, that setting overrides any setting the object might inherit from an object above it in the object hierarchy.\n\nFor example, if a button's **backgroundColor** property is set to a color reference instead of being empty, the button uses that background color, regardless of the button's owners. If the object has a color of its own, that color is always used.\n\n**The effective keyword**\n\nIf an inheritable property of an object is empty, you can't simply check the property to find out what color or font settings the object displays. In this case, use the **effective** keyword to obtain the inherited setting of the property. The **effective** keyword searches the object's owners, if necessary, to find out what setting is *actually* used.\n\nFor example, suppose you have a field whose **textFont** property is empty. The **textFont** of the card that the field is on is set to \"Helvetica\", so the field inherits this setting and displays its text in the Helvetica font. To find out what font the field is using, use the expression `the effective textFont`:\n\n```\nget the textFont of field \"My Field\" *-- empty*\nget the effective textFont of field \"My Field\" *-- Helvetica*\n```\n\nYou can use the **effective** keyword with any inherited property.\n\n## Global Properties\n\nLiveCode also has global properties, which affect the *overall behavior* of the application. Global properties are accessed and changed the same way as object properties. They do not belong to any particular object, but otherwise they behave like object properties.\n\n> **Tip:** To see a list of all global properties, open the *Message Box*, and choose the *Global Properties* icon  the third icon from the left at the top of the window. To see a list of all properties in the language, including both global and object properties, use the propertyNames global property.\n\nA few properties are *both* global *and* object properties. For example, the **paintCompression** is a global property, and also a property of images. For these properties, the global setting is separate from the setting for an individual object.\n\nSome other global properties are affected by *system settings*. For example, the default value of the **playLoudness** property is set by the operating system's sound volume setting.\n\n### Referring to global properties\n\nYou refer to global properties using **the** and the property name:\n\n```\nthe defaultFolder\nthe emacsKeyBindings\nthe fileType\n```\n\nSince global properties apply to the whole application, you don't include an object reference when referring to them.\n\nGlobal properties are sources of value, so you can get the value of a global property by using it in an expression:\n\n```\nget the stacksInUse\nput the recentNames into field \"Recent Cards\"\nif the ftpProxy is empty then exit setMyProxy\n```\n\n### Changing global properties\n\nTo change a global property, you use the **set** command, in the same way as for object properties:\n\n```\nset the itemDelimiter to \"/\"\nset the grid to false\nset the idleTicks to 10\n```\n\nSome global properties can be changed by other commands. For example, the **lockScreen** property can either be set directly, or changed using the **lock screen** and **`unlock screen`** commands. The following two statements are equivalent:\n\n```\nset the lockScreen to false *-- does the same thing as...*\nunlock screen\n```\n\n### Saving and restoring global properties\n\nObject properties are part of an object, so they are saved when the stack containing their object is saved. Global properties, however, are not associated with any object, so they are not saved with a stack. If you change the value of a global property, the change is lost when you quit the application.\n\nIf you want to use the same setting of a global property during a different session of your application, you must save the setting  in a Preferences file, in a custom property, or elsewhere in a saved file  and restore it when your application starts up.\n\n## Text Related Properties\n\nNormally, properties are applied only to objects or, in the case of global properties, to the entire application. However, a few properties also apply to chunks in a field or to single characters in a field.\n\n### Text style properties\n\nCertain text-related properties can be applied either to an entire field or to a chunk of a field:\n\n```\nset the textFont of word 3 of field \"My Field\" to \"Courier\"\nset the foregroundColor of line 1 of field 2 to \"green\"\nif the textStyle of the clickChunk is \"bold\" then beep\n```\n\nThe following field properties can be applied to either an entire field or to a chunk of the field:\n\n\ntextFont, textStyle, and textSize\n\ntextShift\n\nbackgroundColor and foregroundColor\n\nbackgroundPattern and foregroundPattern (Unix systems)\n\nEach chunk of a field inherits these properties from the field, in the same way that fields inherit from their owners. For example, if a word's **textFont** property is empty, the word is displayed in the field's font. But if you set the word's **textFont** to another font name, that word  and only that word  is displayed in its own font.\n\nTo find the text style of a chunk in a field, whether that chunk uses its own styles or inherits them from the field, use the **effective** keyword:\n\n```\nget the effective textFont of word 3 of field ID 2355\nanswer the effective backgroundColor of char 2 to 7 of field \"My Field\"\n```\n\n> **Tip:** If a chunk expression includes more than one style, the corresponding property for that chunk reports \"mixed\". For example, if the first line of a field has a **textSize** of \"12\", and the second line has a **textSize** of \"24\", an expression like the textSize of line 1 to 2 of field \"My Field\" reports \"mixed\".\n\n### Formatted text properties\n\nThe **htmlText**, **RTFText**, and **unicodeText** properties of a chunk are equal to the text of that chunk, along with the formatting information that's appropriate for the property.\n\nFor example, if a field contains the text \"This is a test.\", and the word \"is\" is boldfaced, the htmlText of word 2 reports \"\\<b\\>is\\</b\\>\".\n\nFor more information on these properties see the chapter on *Processing Text and Data*, as well as the individual entries for these properties in the *LiveCode Dictionary*.\n\n**The formattedRect and related properties**\n\nThe **formattedRect** property (along with the **formattedWidth**, **formattedHeight**, **formattedLeft**, and **formattedTop**) reports the position of a chunk of text in a field. These properties are read-only.\n\nThe **formattedRect**, **formattedLeft**, and **formattedTop** properties can be used for a chunk of a field, but not the entire field. The **formattedWidth** and **formattedHeight** apply to both fields and chunks of text in a field.\n\n**The imageSource, linkText, and visited properties**\n\nThe **imageSource** of a character specifies an image to be substituted for that character when the field is displayed. You use the **imageSource** to display images inside fields:\n\n```\nset the imageSource of char 17 of field 1 to 49232\nset the imageSource of char thisChar of field \"My Field\" to \"http://www.example.com/banner.jpg\"\n```\n\nThe **linkText** property of a chunk lets you associate hidden text with part of a field's text. You can use the **linkText** in a **linkClicked** handler to specify the destination of a hyperlink, or for any other purpose.\n\nThe **visited** property specifies whether you have clicked on a text group during the current session. You can get the visited property for any chunk in a field, but it is meaningless unless the chunk's **textStyle** includes \"link\".\n\nThe **imageSource**, **linkText**, and **visited** properties are the only properties that can be set to a chunk of a field, but not to the entire field or any other object. Because they are applied to text in fields, they are listed as field properties in the LiveCode Dictionary.\n\n## Creating and Deleting Objects\n\nLiveCode allows you to create and delete objects programmatically. You may optionally specify all the properties for a new object before creating it.\n\n### The Create Object Command\n\nYou use the **create** command to create a new object.\n\n```\ncreate [invisible] *type* [*name*] [in *group*]\n```\n\nThe *type* is any control that can be on a card: field, button, image, scrollbar, graphic, player, or EPS.\n\nThe *name* is the name of the newly created object. If you don't specify a *name*, the object is created with a default name.\n\nThe *group* is any group that's on the current card. If you specify a *group*, the new object is a member of the group, and exists on each card that has the group. If you don't specify a group, the object is created on the current card and appears only on that card.\n\n```\ncreate button \"Click Me\"\ncreate invisible field in first group\n```\n\nFor more details, see the *create command* in the *LiveCode Dictionary*. For details on how to specify the properties of an object before creating it, see the section on *Creating Objects Off-screen Using Template Objects*, below.\n\n### The Delete Object Command\n\nYou can use the **delete** command to remove objects from the stack.\n\ndelete {*object}*\n\nThe *object* is any available object.\n\n```\ndelete this card\ndelete button \"New Button\"\n```\n\nFor more details, see the *delete command* in the *LiveCode Dictionary*.\n\n### Creating Objects Off-screen Using Template Objects\n\nLiveCode uses *template objects* to allow you to specify the properties for an object before it is created. The template objects are off-screen models  there is one for each possible type of object, e.g. button, field, graphic, etc.\n\nIf you need to create a new object and then set some properties on the object, it is more efficient to make the changes to the template object, then create the object. Because the object can be created with all of its properties set correctly, there is no need to lock the screen and update or reposition the object after creating it. For example, the LiveCode development environment uses the template objects internally to create new objects from the main tool palette.\n\nYou set properties on template objects in the same way you set properties on normal objects.\n\nset the {property} of the template{Objecttype} to {value}\n\nFor example, to create a button with the name \"Hello World\", positioned at 100,100:\n\n```\nset the name of the templateButton to \"Hello World\"\nset the location of the templateButton to 100,100\ncreate button\n```\n\nWhen you have used the templateObject to create a new object, you should reset it before using it again. Resetting the templateObject sets all off its properties back to defaults.\n\nreset the template[Objecttype]\n\nFor example, to reset the `templateButton`:\n\n```\nreset the templateButton\n```\n\nFor more details on the template objects, search the *LiveCode Dictionary* for \"*template*\".\n\n## Property Arrays using the Properties Property\n\nIn addition to retrieving individual object properties, you can retrieve or set an entire set as an array using the **properties** property. You can use this to edit, copy, export or import properties.\n\n```\nset the properties of *object* to *propertiesArray*\nput the properties of *object* into propertiesArray\n```\n\nThe **properties** of an object is an array containing that object's significant built-in properties.\n\n```\nput the properties of button 1 into myArray\nset the properties of last player to the properties of player \"Example\"\n```\n\n> **Tip:** This example handler shows you how to write the properties of an object to a text file.\n\n```\non mouseUp\n\tput the properties of button 1 into tPropertiesArray\n\tcombine tPropertiesArray using return and \"|\"\n\task file \"Save properties as:\"\n\tif it is not empty then put tPropertiesArray into URL (\"file:\" & it)\nend mouseUp\n```\n\nIn this example, each property name will be written followed by the \"|\" character and the property value and then a return character.\n\nFor more details, see the *properties property* in the *LiveCode Dictionary*.\n\n## Property Profiles\n\nA property profile is a collection of object property settings, which is stored as a set. A profile for an object can contain settings for almost any properties of the object.\n\nYou can include values for most built-in properties in a profile, and create as many different property profiles as you need for any object. Once you've created a profile, you can switch the object to the profile to change all the property values that are defined in the profile.\n\nFor example, suppose you create a property profile for a field that includes settings for the field's color properties. When you switch to that profile, the field's colors change, while all other properties (not included in the profile) remain the same.\n\nUse property profiles when you want to:\n\n- Create \"skins\" for your application\n- Display your application in different languages\n- Present different levels--\"novice\",\"expert\", and so on\n- Use different user-interface standards for different platforms\n\nFor details on how to create property profiles using the IDE, see the section on *Property Profiles* in the chapter *Building a User Interface*.\n\n### Profile names\n\nProfile names follow the same rules as variable names. A profile name must be a single word, consisting of letters, digits, and underscores, and must start with either a letter or an underscore.\n\n> **Tip:** If you want to use a single command to switch several objects to a particular profile, give the profile the same name for each of the objects it applies to.\n\n### The master profile\n\nEvery object has a master profile that holds the default settings for all its properties. If you don't set an object's profile, the master profile is used. When you create a new profile, you can change settings for various properties to make them different from the master profile's settings.\n\nIf you don't specify a property setting in a profile, the master profile's setting is used, so you don't have to specify all properties of an object when you create a profile--only the ones you want to change.\n\nBy default, the master profile is named \"Master\". You can change the master profile's name in the *Property Profiles* pane of the *Preferences* window.\n\n### Switching between profiles\n\n**Switching a single object**\n\nTo switch an object's profile, you can use either the object's property inspector or the **revProfile** property.\n\n```\nset the revProfile of player \"My Player\" to \"MyProfile\"\n```\n\n**Switching all the objects on a card**\n\nTo switch the profiles of all the objects on a card, use the **revSetCardProfile** command:\n\n```\nrevSetCardProfile \"MyProfile\",\"My Stack\"\n```\n\nThe statement above sets the profile of all objects on the current card of the stack named \"My Stack\". (Although the **revSetCardProfile** command changes a card, you specify a stack name, not a card name.)\n\nIf an object on the card does not have a profile with the specified name, the object is left untouched.\n\n**Switching all the objects in a stack**\n\nTo switch the profiles of all the objects in a stack, use the **revSetStackProfile** command:\n\n```\nrevSetStackProfile \"MyProfile\",\"My Stack\"\n```\n\nThe statement above sets the profile of all objects in the stack named \"My Stack\".\n\nIf an object in the stack does not have a profile with the specified name, the object is left untouched.\n\n**Switching all the objects in a stack file**\n\nTo switch the profiles of all the objects in every stack in a stack file, use the **revSetStackFileProfile** command:\n\n```\nrevSetStackFileProfile \"MyProfile\",\"My Stack\"\n```\n\nThe statement above sets the profile of all objects in the stack named \"My Stack\", along with any other stacks in the same stack file.\n\nIf an object in any of the stacks does not have a profile with the specified name, the object is left untouched.\n\n### Creating a profile in a handler\n\nIn addition to creating property profiles in the property inspector, you can create a profile in a handler.\n\nTo enable creating profiles, check the \"Create profiles automatically\" box in the \"Property Profiles\" pane of the Preferences window. If this box is checked, setting the **revProfile** property of an object automatically creates the profile.\n\nThis ability is particularly useful if you want to create a number of profiles, as shown in the following example:\n\n```\non mouseUp\n\t-- creates a profile for each card in the stack\n\trepeat with thisCard = 1 to the number of cards\n\t\tset the revProfile of card x to \"myNewProfile\"\n\tend repeat\nend mouseUp\n```\n\nThe handler above creates a profile called \"myNewProfile\" for all the cards in the current stack.\n\nIn order for this handler to work, the \"Create profiles automatically\" option in the \"Property Profiles\" pane of the Preferences window must be turned on.\n\nYou can control this behavior either in Preferences window or using the **gRevProfileReadOnly** keyword. If you don't want to save property changes when switching profiles, do one of the following:\n\nSet the **gRevProfileReadOnly** variable to true:\n\n```\nglobal gRevProfileReadOnly\nput true into gRevProfileReadOnly\n```\n\nIn the \"Property Profiles\" pane of the Preferences window, uncheck the box labeled \"Don't save changes in profile\".\n\nThe two methods of changing this setting are equivalent: changing the **gRevProfileReadOnly** variable also changes the preference setting, and vice versa.\n\nFor more details, see *gRevProfileReadOnly* in the *LiveCode Dictionary*.\n\n### Adding profile settings in a handler\n\nYou can add a property setting to a profile by switching to the profile, then setting the property:\n\n```\nset the revProfile of button 1 to \"MyProfile\"\nset the foregroundColor of button 1 to \"red\"\nset the revProfile of button 1 to \"Master\"\n```\n\nBy default, if you change a property and then switch profiles, the property you changed and its current setting is saved with the profile.\n\n## Custom Properties\n\nA custom property is a property that you create for an object, in addition to its built-in properties. You can define custom properties for any object, and use them to store any kind of data.\n\nThis topic discusses how to *create* and *use* custom properties, and how to *organize* custom properties into *sets* (or *arrays*). The following section covers how to create virtual properties and use **getProp** and **setProp** handlers to handle custom property requests.\n\n### Using Custom Properties\n\nA custom property is a property that you define. You can create as many custom properties for an object as you want, and put any kind of data into them (even binary data). You can even store a file in a custom property.\n\nUse a custom property when you want to:\n- associate data with a specific object\n- save the data with the object in the stack file\n- access the data quickly\n\n### Creating a Custom Property\n\nYou create a custom property by setting the new property to a value. If you set a custom property that doesn't exist, LiveCode automatically creates the custom property and sets it to the requested value.\n\nThis means that you can create a custom property in a handler or the message box, simply by using the **set** command. The following statement creates a custom property called \"endingTime\" for a button:\n\n```\nset the endingTime of button \"Session\" to the long time\n```\n\nYou can create custom properties for any object. However, you cannot create global custom properties, or custom properties for a chunk of text in a field. Unlike some built-in properties, a custom property applies only to an object.\n\n> **Important:** Each object can have its own custom properties, and custom properties are not shared between objects. Creating a custom property for one object does not create it for other objects.\n\n### The Content of a Custom Property\n\nYou set the value of a custom property by using its property name together with the **set** command, in the same way you set built-in properties:\n\n```\nset the myCustomProperty of button 1 to false\n```\n\nYou can see and change all of an object's custom properties in the Custom Properties pane of the object's property inspector: click the custom property you want to change, then enter the new value.\n\n**Changing a part of a property**\n\nLike *built-in properties*, custom properties are *not* containers, so you cannot use a chunk expression to change a part of the custom property. Instead, you put the property's value into a variable and change the variable, then set the custom property back to the new variable contents:\n\n```\nput the lastCall of this card into myVar\nput \"March\" into word 3 of myVar\nset the lastCall of thisCard to myVar\n```\n\n### Custom Property Names\n\nThe name of a custom property must consist of a single word and may contain any combination of letters, digits, and underscores (\\_). The first character must be either a letter or an underscore.\n\nAvoid giving a custom property the same name as a variable. If you refer to a custom property in a handler, and there is a variable by the same name, LiveCode uses the contents of the variable as the name of the custom property. This usually causes unexpected results.\n\n> **Important:** It is important to avoid giving custom properties the same name as existing engine properties *unless* those properties are only ever accessed in the context of a custom property set. Unintended effects may result if you attempt to use the name of an engine property as a custom property.\n\nCustom property names beginning with \"**rev**\" are reserved for LiveCode's own custom properties. Naming a custom property with a reserved name may produce unexpected results when working in the development environment.\n\n### Referring to Custom Properties\n\nCustom property references look just like built-in property references: the word the, the property name, the word of, and a reference to the object.\n\nFor example, to use a custom property called \"lastCall\" that belongs to a card, use a statement like the following:\n\n```\nput the lastCall of this card into field \"Date\"\n```\n\nLike built-in properties, custom properties are sources of value, so you can get the value of a custom property by using it in an expression. The property's value is substituted for the property reference when the statement is executed. For example, if the card's \"lastCall\" custom property is \"Today\", the example statement above puts the string \"Today\" into the \"Date\" field.\n\n### Nonexistent Custom Properties\n\nCustom properties that don't exist evaluate to empty. For example, if the current card doesn't have a custom property called \"astCall\", the following statement empties the field:\n\nput the lastCall of this card into field \"Date\" * empty*\n\n> **Note:** Referring to a nonexistent custom property does not cause a script error. This means that if you misspell a custom property name in a handler, you won't get an error message, so you might not notice the problem right away.\n\n### Finding out Whether a Custom Property Exists\n\nThe **customKeys** property of an object lists the object's custom properties, one per line:\n\n```\nput the customKeys of button 1 into field \"Custom Props\"\n```\n\nTo find out whether a custom property for an object exists, you check whether it's listed in the object's **customKeys**. The following statement checks whether a player has a custom property called \"doTellAll\":\n\n```\nif \"doTellAll\" is among the lines of the customKeys of player \"My Player\" then*...*\n```\n\nYou can also look in the *Custom Properties* pane of the object's property inspector, which lists the custom properties. See the chapter on *Building a User Interface* for more details.\n\n### Custom Properties & Converting Text Between Platforms\n\nWhen you move a stack developed on a Mac OS or OS X system to a Windows or Unix system (or vice versa), LiveCode automatically translates text in fields and scripts into the appropriate character set. However, text in custom properties is not converted between the ISO and Macintosh character sets. This is because custom properties can contain binary data as well as text, and converting them would garble the data.\n\nCharacters whose ASCII value is between 128 and 255, such as curved quotes and accented characters, do not have the same ASCII value in the Mac OS character set and the ISO 8859-1 character set used on Unix and Windows systems. If such a character is in a field, it is automatically translated, but it's not translated if it's in a custom property.\n\nBecause of this, if your stack displays custom properties to the user--for example, if the stack puts a custom property into a field--and if the text contains special characters, it may be displayed incorrectly if you move the stack between platforms. To avoid this problem, use one of these methods:\n\nBefore displaying the custom property, convert it to the appropriate character set using the **macToISO** or **ISOToMac** function. The following example shows how to convert a custom property that was created on a Mac OS system, when the property is displayed on a Unix or Windows system:\n\n```\nif the platform is \"MacOS\" then\n\tanswer the myPrompt of button 1\nelse\n\tanswer macToISO(the myPrompt of button 1)\nend if\n```\n\nInstead of storing the custom property as text, store it as HTML, using the **HTMLText** property of fields:\n\n```\nset the myProp of this card to the HTMLText of field 1\n```\n\nBecause the **HTMLText** property encodes special characters as entities, it ensures that the custom property does not contain any special characters--only the platform-independent encodings for them. You can then set a field's **HTMLText** to the contents of the custom property to display it:\n\n```\nset the HTMLText of field \"Display\" to the myProp of this card\n```\n\n### Storing a file in a custom property\n\nYou can use a URL to store a file's content in a custom property:\n\n```\nset the myStoredFile of stack \"My Stack\" to URL \"binfile:mypicture.jpg\"\n```\n\nYou restore the file by putting the custom property's value into a URL:\n\n```\nput the myStoredFile of stack \"My Stack\" into URL \"binfile:mypicture.jpg\"\n```\n\nBecause a custom property can hold any kind of data, you can store either text files or binary files in a custom property. You can use this capability to bundle media files or other files in your stack.\n\nMany Mac OS Classic files have a resource fork. To store and restore such a file, you can use the **resfile** URL scheme to store the content of the resource fork separately.\n\n> **Tip:** To save space, compress the file before storing it:\n\n```\nset the myStoredFile of stack \"My Stack\" to compress(URL \"binfile:mypicture.jpg\")\n```\n\nWhen restoring the file, decompress it first:\n\n```\nput decompress(the myStoredFile of stack \"My Stack\") into URL \"binfile:mypicture.jpg\"\n```\n\nFor more information about using URL containers, see the chapter on *Working with Files, URLs and Sockets*.\n\n### Deleting a custom property\n\nAs described above, the **customKeys** property of an object is a list of the object's custom properties. You can set the **customKeys** of an object to control which custom properties it has.\n\nIn LiveCode, there is no command to delete a custom property. Instead, you place all the custom property names in a variable, delete the one you don't want from that variable, and set the object's **customKeys** back to the modified contents of the variable. This removes the custom property whose name you deleted.\n\nFor example, the following statements delete a custom property called \"propertyToRemove\" from the button \"My Button\":\n\n```\nget the customKeys of button \"My Button\"\nset the wholeMatches to true\ndelete line lineOffset(\"propertyToRemove\",it) of it\nset the customKeys of button \"My Button\" to it\n```\n\nYou can also delete a custom property in the *Custom Properties* pane of the object's *Property Inspector*. Select the property's name and click the *Delete* button to remove it.\n\n## Custom Property Sets\n\nCustom properties can be organized into *custom property sets*  or arrays of custom properties. A custom property set is a group of custom properties that has a name you specify.\n\nWhen you refer to a custom property, LiveCode looks for that property in the object's currently-active custom property set. When you create or set a custom property, LiveCode creates it in the currently-active custom property set, or sets the value of that property in the currently-active set. One custom property set is active at any one time, but you can use array notation to get or set custom properties in sets other than the current set.\n\nThe examples in the previous section assume that you haven't created any custom property sets. If you create a custom property without creating a custom property set for it, as shown in the previous examples, the new custom property becomes part of the object's default custom property set.\n\n### Creating custom property sets\n\nTo make a custom property set active, you set the object's **customPropertySet** property to the set you want to use. As with custom properties and local variables, if the custom property set you specify doesn't exist, LiveCode automatically creates it, so you can create a custom property set for an object by simply switching to that set.\n\nThe following statement creates a custom property set called \"Alternate\" for an object, and makes it the active set:\n\n```\nset the customPropertySet of the target to \"Alternate\"\n```\n\nThe statement above creates the custom property set.\n\nYou can also view, create, and delete custom property sets in the Custom pane of the object's property inspector.\n\nYou can list all the custom property sets of an object using its **customPropertySets** property.\n\nAs with custom properties, you can create custom property sets for any object. But you can't create global custom property sets, or custom property sets for a chunk of a field.\n\n### Custom property set names\n\nThe names of custom property sets should consist of a single word, with any combination of letters, digits, and underscores (\\_). The first character should be either a letter or an underscore.\n\nIt is possible to create a custom property set with a name that has more than one word, or that otherwise doesn't conform to these guidelines. However, this is not recommended, because such a custom property set can't be used with the array notation described below.\n\n> **Note:** When you use the Custom Properties pane in the property inspector to create a custom property set, the pane restricts you to these guidelines.\n\n### Referring to custom property sets\n\nTo switch the active custom property set, set the object's **customPropertySet** property to the name of the set you want to use:\n\n```\nset the customPropertySet of button 3 to \"Spanish\"\n```\n\nAny references to custom property refer to the current custom property set. For example, suppose you have two custom property sets named \"Spanish\" and \"French\", and the French set includes a custom property called \"Paris\" while the Spanish set does not. If you switch to the Spanish set, the **customKeys** of the object does not include \"Paris\", because the current custom property set doesn't include that property.\n\nIf you refer to a custom property that isn't in the current set, the reference evaluates to empty. If you set a custom property that isn't in the current set, the custom property is created in the set. You can have two custom properties with the same name in different custom property sets, and they don't affect each other: changing one does not change the other.\n\nThe **customProperties** property of an object includes only the custom properties that are in the current custom property set. To specify the **customProperties** of a particular custom property set, you include the set's name in square brackets:\n\n```\nput the customProperties[mySet] of this card into myArray\n```\n\n### Finding out whether a custom property set exists\n\nThe **customPropertySets** property of an object lists the object's custom property sets, one per line:\n\n```\nanswer the customPropertySets of field \"My Field\"\n```\n\nTo find out whether a custom property set for an object exists, you check whether it's listed in the object's **customPropertySets**. The following statement checks whether an image has a custom property set called \"Spanish\":\n\n```\nif \"Spanish\" is among the lines of the customPropertySets of image ID 23945 then*...*\n```\n\nYou can also look in the Custom Properties pane of the object's property inspector, which lists the custom property sets in the \"Set\" menu halfway down the pane.\n\n### The default custom property set\n\nAn object's default custom property set is the set that's active if you haven't used the **customPropertySet** property to switch to another set. Every object has a default custom property set; you don't need to create it.\n\nIf you create a custom property without first switching to a custom property set  as in the earlier examples in this topic  the custom property is created in the default set. If you don't set the **customPropertySet** property, all your custom properties are created in the default set.\n\nThe default custom property set has no name of its own, and is not listed in the object's **customPropertySets** property. To switch from another set to the default set, you set the object's **customPropertySet** to empty:\n\n```\nset the customPropertySet of the target to empty\n```\n\n### Using multiple custom property sets\n\nSince only one custom property set can be active at a time, you can create separate custom properties with the same name but different values in different sets. Which value you get depends on which custom property set is currently active.\n\n**A translation example**\n\nSuppose your stack uses several custom properties that hold strings in English, to be displayed to the user by various commands. Your stack might contain a statement such as this:\n\nanswer the standardErrorPrompt of this stack\n\nThe statement above displays the contents of the custom property called \"standardErrorPrompt\" in a dialog box.\n\nSuppose you decide you want to translate your application into French. To do this, you make your original set of English custom properties into a custom property set (which you might call \"myEnglishStrings\"), and create a new set called \"myFrenchStrings\" to hold the translated properties.\n\nEach set has the same-named properties, but the values in one set are in French and the other in English. You switch between the sets depending on what language the user chooses. The statement:\n\nanswer the standardErrorPrompt of this stack\n\nprovides either the English or French, depending on which custom property set is active: \"myEnglishStrings\" or \"myFrenchStrings\".\n\n### Copying custom properties between property sets\n\nWhen it's created, a custom property set is empty, that is, there aren't any custom properties in it. You put custom properties into a new custom property set by creating the custom properties while the set is active:\n\n```\n-- create new set and make it active:\nset the customPropertySet of button 1 to \"MyNewSet\"\n-- now create a new custom property in the current set:\nset the myCustomProp of button 1 to true\n```\n\nYou can also use the **customProperties** property (which was discussed earlier in this topic) to copy custom properties between sets. For example, suppose you have created a full set of custom properties in a custom property set called \"myEnglishStrings\", and you want to copy them to a new custom property set, \"frenchStrings\", so you can translate them easily. The following statements create the new custom property set, then copy all the properties from the old set to the new one:\n\n```\n-- create the new set:\nset the customPropertySet of this stack to \"frenchStrings\"\n-- copy the properties in the English set to the new set:\n\nset the customProperties[\"frenchStrings \"] of this stack to the customProperties[\"frenchStrings \"] of this stack\n```\n\n> **Caution:** Custom property sets in the development environment\n\n### Arrays, custom properties, and custom property sets\n\nAll the custom properties in a custom property set form an array. The array's name is the custom property set name, and the elements of the array are the individual custom properties in that custom property set.\n\n**Referring to custom properties using array notation**\n\nYou can use array notation to refer to custom properties in any custom property set. This lets you get and set any custom property, even if it's not in the current set, without changing the current set.\n\nFor example, suppose a button has a custom property named \"myProp\" which is in a custom property set called \"mySet\". If \"mySet\" is the current set, you can refer to the \"myProp\" property like this:\n\n```\nget the myProp of button 1\nset the myProp of the target to 20\n```\n\nBut you can also use array notation to refer to the \"myProp\" property, even if \"mySet\" is not the current set. To refer to this custom property regardless of which custom property set is active, use statements like the following:\n\n```\nget the mySet[\"myProp\"] of button 1\nset the mySet[\"myProp\"] of the target to 20\n```\n\n> **Note:** Because the default custom property set has no name, you cannot use array notation to refer to a custom property in the default set.\n\n**Storing an array in a custom property set**\n\nIf you store a set of custom properties in a custom property set, the set can be used just like an array. You can think of the custom property set as though it were a single custom property, and the properties in the set as the individual elements of the array.\n\nTo store an array variable as a custom property set, use a statement like the following:\n\n```\nset the customProperties[\"myProperty\"] of me to theArray\n```\n\nThe statement above creates a custom property set called \"myProperty\", and stores each element in \"theArray\" as a custom property in the new set. To retrieve a single element of the array, use a statement like this:\n\n```\nget the myProperty[\"myElement\"] of field \"Example\"\n```\n\n### Deleting a custom property set\n\nAs described above, the **customPropertySets** property of an object is a list of the object's custom property sets. You can set the **customPropertySets** of an object to control which custom property sets it has.\n\nIn LiveCode, there is no command to delete a custom property set. Instead, you place all the custom property set names in a variable, delete the one you don't want from that variable, and set the **customPropertySets** back to the modified contents of the variable. This removes the custom property set whose name you deleted.\n\nFor example, the following statements delete a custom property set called \"mySet\" from the button \"My Button\":\n\n```\nget the customPropertySets of button \"My Button\"\nset the wholeMatches to true\ndelete line lineOffset(\"mySet\",it) of it\nset the customPropertySets of button \"My Button\" to it\n```\n\nYou can also delete a custom property set in the Custom Properties pane of the object's property inspector. Select the set's name from the Set menu, then click the Delete button to remove it.\n\n## Attaching Handlers to Custom Properties\n\nWhen you change a custom property, LiveCode sends a **setProp** trigger to the object whose property is being changed. You can write a **setProp** handler to trap this trigger and respond to the attempt to change the property. Like a message, this trigger uses the message path, so you can place the **setProp** handler anywhere in the object's message path.\n\nSimilarly, when you get the value of a custom property, LiveCode sends a **getProp** call to the object whose property is being queried. You can write a **getProp** handler to reply to the request for information. Like a function call, the **getProp** call also traverses the message path.\n\nUsing **getProp** and **setProp** handlers, you can:\n- validate a custom property's value before setting it\n- report a custom property's value in a format other than what it's stored as\n- ensure the integrity of a collection of properties by setting them all at once\n- change an object's behavior when a custom property is changed\n\n**setProp** triggers and **getProp** calls are not sent when a built-in property is changed or accessed. They apply only to custom properties.\n\n### Responding to changing a custom property\n\nWhen you use the **set** command to change a custom property, LiveCode sends a **setProp** trigger to the object whose property is being changed.\n\nA **setProp** trigger acts very much like a message does. It is sent to a particular object. If that object's script contains a **setProp** handler for the property, the handler is executed; otherwise, the trigger travels along the message path until it finds a handler for the property. If it reaches the end of the message path without being trapped, the **setProp** trigger sets the custom property to its new value. For more information about the message path, see the section on the *Message Path*.\n\nYou can include as many **setProp** handlers in a script for as many different custom properties as you need.\n\n### The structure of a *setProp* handler\n\nUnlike a message handler, a `setProp` handler begins with the word `setProp` instead of the word `on`. This is followed by the handler's name (which is the same as the name of the custom property) and a parameter that holds the property's new value. A `setProp`handler, like all handlers, ends with the word \"end\" followed by the handler's name.\n\nThe following example shows a setProp handler for a custom property named \"percentUsed\", and can be placed in the script of the object whose custom property it is:\n\n```\nsetProp percentUsed newAmount\n\t-- responds to setting the percentUsed property\n\tif newAmount is not a number or newAmount \\< zero or newAmount \\> 100 then\n\t\tbeep 2\n\t\texit percentUsed\n\tend if\n\tpass percentUsed\nend percentUsed\n```\n\nWhen you set the \"percentUsed\" custom property, the \"percentUsed\" handler is executed:\n\n```\nset the percentUsed of scrollbar \"Progress\" to 90\n```\n\nWhen this statement is executed, LiveCode sends a **setProp** trigger to the scrollbar. The new value of 90 is placed in the *newAmount* parameter. The handler makes sure that the new value is in the range 0100; if not, it beeps and exits the handler, preventing the property from being set.\n\nFor more details about the **setProp** control structure, see **setProp** in the LiveCode Dictionary.\n\n**Passing the setProp trigger**\n\nWhen the **setProp** trigger reaches the engine--the last stop in the message path--the custom property is set. If the trigger is trapped and doesn't reach the engine, the custom property is not set.\n\nTo let a trigger pass further along the message path, use the **pass** control structure. The **pass** control structure stops the current handler and sends the trigger on to the next object in the message path, just as though the object didn't have a handler for the custom property.\n\nIn the \"percentUsed\" handler above, if the *newAmount* is out of range, the handler uses the **exit** control structure to halt; otherwise, it executes the **pass** control structure. If the *newAmount* is in the right range, the pass control structure lets the property be set. Otherwise, since the trigger is not passed, it never reaches the engine, so the property is not changed.\n\nYou can use this capability to check the value of any custom property before allowing it to be set. For example, if a custom property is supposed to be boolean (true or false), a setProp handler can trap the trigger if the value is anything but true or false:\n\n```\nsetProp myBoolean newValue\n\tif newValue is true or newValue is false\n\tthen pass myBoolean\nexit myBoolean\n```\n\n**Using the message path with a setProp trigger**\n\nBecause **setProp** triggers use the message path, a single object can receive the **setProp** triggers for all the objects it owns. For example, **setProp** triggers for all controls on a card are sent to the card, if the control's script has no handler for that property. You can take advantage of the message path to implement the same **setProp** behavior for objects that all have the same custom property.\n\nIf a **setProp** handler sets its custom property, for an object that has that **setProp** handler in its message path, a runaway recursion will result. To avoid this problem, set the **lockMessages** property to true before setting the custom property.\n\n> **Note:** To refer to the object whose property is being set, use the **target** function. The **target** refers to the object that first received the **setProp** trigger--the object whose custom property is being set--even if the handler being executed is in the script of another object.\n\n**Setting properties within a setProp handler**\n\nIn the \"lastChanged\" example in the box above, the handler sets the custom property directly, instead of simply passing the **setProp** trigger. You must use this method if the handler makes a change to the property's value, because the **pass** control structure simply passes on the original value of the property.\n\nIf you use the **set** command within a **setProp** handler to set the same custom property for the current object, no **setProp** trigger is sent to the target object. (This is to avoid runaway recursion, where the **setProp** handler triggers itself.) Setting a different custom property sends a **setProp** trigger. So does setting the handler's custom property for an object other than the one whose script contains the **setProp** handler.\n\nUsing this method, you can not only check the value of a property, and allow it to be set only if it's in range, you can also change the value so that it is in the correct range, has the correct format, and so on.\n\nThe following example is similar to the \"percentUsed\" handler above, but instead of beeping if the *newAmount* is out of range, it forces the new value into the range 0100:\n\n```\nsetProp percentUsed newAmount\n\tset the percentUsed of the target to max(zero,min(100,newAmount))\nend percentUsed\n```\n\n**Nonexistent properties**\n\nIf the custom property specified by a setProp handler doesn't exist, the setProp handler is still executed when a handler sets the property. If the handler passes the **setProp** trigger, the custom property is created.\n\n**Custom property sets and setProp handlers**\n\nA setProp handler for a custom property set behaves differently from a setProp handler for a custom property that's in the default set.\n\nWhen you set a custom property in a custom property set, the **setProp** trigger is named for the set, not the property. The property name is passed in a parameter using a special notation. This means that, for custom properties in a set, you write a single setProp handler for the set, rather than one for each individual property.\n\nThe following example handles **setProp** triggers for all custom properties in a custom property set called *myFrenchStrings*, which contains custom properties named *standardErrorPrompt*, *filePrompt*, and perhaps other custom properties:\n\n```\nsetProp myFrenchStrings[myPropertyName] newValue\n-- The myPropertyName parameter contains the name of\n-- the property that's being set\n\tswitch myPropertyName\n\tcase \"standardErrorPrompt\"\n\t\tset the myFrenchStrings[\"standardErrorPrompt\"] of the target to return & newValue & return\n\t\texit myFrenchStrings\n\tbreak\n\tcase \"filePrompt\"\n\t\tset the myFrenchStrings[\"filePrompt\"] of the target to return& newValue & return\n\texit myFrenchStrings\n\tbreak\n\tdefault\n\t\tpass myFrenchStrings\n\tend switch\nend myFrenchStrings\n```\n\nAs you can see from the **exit**, **pass**, and **end** control structures, the name of this setProp handler is the same as the name of the custom property set that it controls--\"myFrenchStrings\". Because there is only one handler for all the custom properties in this set, the handler uses the **switch** control structure to perform a different action for each property that it deals with.\n\nSuppose you change the \"standardErrorPrompt\" custom property:\n\n```\nset the customPropertySet of this stack to \"myFrenchStrings\"\nset the standardErrorPrompt of this stack to field 1\n```\n\nLiveCode sends a **setProp** trigger to the stack, which causes the above handler to execute. The property you set  \"standardErrorPrompt\"  is placed in the \"myPropertyName\" parameter, and the new value--the contents of field 1  is placed in the \"newValue\" parameter. The handler executes the case for \"standardErrorPrompt\", putting a **return** character before and after the property before setting it.\n\nIf you set a custom property other than \"standardErrorPrompt\" or \"filePrompt\" in the \"myFrenchStrings\" set, the default case is executed. In this case, the **pass** control structure lets the **setProp** trigger proceed along the message path, and when it reaches the engine, LiveCode sets the custom property.\n\n> **Note:** As mentioned above, you can address a custom property in a set either by first switching to that set, or using array notation to specify both set and property. The following example:\n\nRegardless of how you set the custom property, if it is a member of a custom property set, the **setProp** trigger has the name of the set--not the custom property itself--and you must use a setProp handler in the form described above to trap the **setProp** trigger.\n\n### Responding to a request for the value of a custom property\n\nWhen you use a custom property in an expression, LiveCode sends a getProp call to the object whose property's value is being requested.\n\nA getProp call acts very much like a custom function call. It is sent to a particular object. If that object's script contains a **getProp** handler for the property, the handler is executed, and LiveCode substitutes the value it returns for the custom property reference. Otherwise, the call travels along the message path until it finds a handler for the property. If the getProp call reaches the end of the message path without being trapped, LiveCode substitutes the custom property's value in the expression.\n\nYou can include as many **getProp** handlers in a script as you need.\n\n**The structure of a getProp handler**\n\nUnlike a message handler, a `getProp` handler begins with the word `getProp`instead of the word `on`. This is followed by the handler's name (which is the same as the name of the custom property). A `getProp` handler, like all handlers, ends with the word \"end\" followed by the handler's name.\n\nThe following example is a getProp handler for a custom property named \"percentUsed\":\n\n```\ngetProp percentUsed\n\tglobal lastAccessTime\n\tput the seconds into lastAccessTime\n\tpass percentUsed\nend lastChanged\n```\n\nWhen you use the \"percentUsed\" custom property in an expression, the handler is executed:\n\n```\nput the percentUsed of card 1 into myVariable\n```\n\nWhen this statement is executed, LiveCode sends a getProp call to the card to retrieve the value of the \"percentUsed\" property. This executes the getProp handler for the property. The example handler stores the current date and time in a global variable before the property is evaluated. For more details, see *getProp* in the *LiveCode Dictionary*.\n\n**Returning a value from a getProp handler**\n\nWhen the getProp trigger reaches the engine  the last stop in the message path  LiveCode gets the custom property from the object and substitutes its value in the expression where the property was used.\n\nTo let a trigger pass further along the message path, use the **pass** control structure. The **pass** control structure stops the current handler and sends the trigger on to the next object in the message path, just as though the object didn't have a handler for the custom property.\n\nTo report a value other than the value that's stored in the custom property--for example, if you want to reformat the value first  you use the **return** control structure instead of passing the getProp call. The following example is a getProp handler for a custom property named \"lastChanged\", which holds a date in **seconds**:\n\n```\ngetProp lastChanged\nget the lastChanged of the target\nconvert it to long date\nreturn it\nend lastChanged\n```\n\nThe **return** control structure, when used in a getProp handler, reports a property value to the handler that requested it. In the above example, the converted date  not the raw property  is what is reported. As you can see from the example, you're not limited to returning the actual, stored value of the custom property. In fact, you can return any value at all from a getProp handler.\n\n> **Important:** If you use a custom property's value within the property's getProp handler, no getProp call is sent to the target object. This is to avoid runaway recursion, where the **getProp** handler calls itself.\n\nA handler can either use the **return** control structure to return a value, or use the **pass** control structure to let LiveCode get the custom property from the object.\n\nIf the getProp call is trapped before it reaches the engine and no value is returned in the getProp handler, the custom property reports a value of **empty**. In other words, a getProp handler must include either a **return** control structure or a **pass** control structure, or its custom property will always be reported as empty.\n\n**Using the message path with a getProp call**\n\nBecause getProp calls use the message path, a single object can receive the getProp calls for all the objects it owns. For example, getProp calls for all controls on a card are sent to the card, if the control's script has no handler for that property. You can take advantage of the message path to implement the same **getProp** behavior for objects that all have the same custom property.\n\nIf a **getProp** handler is not attached to the object that has the custom property and it uses the value of the custom property, a runaway recursion will result. To avoid this problem, set the **lockMessages** property to true before getting the custom property's value.\n\n**Nonexistent properties**\n\nIf the custom property specified by a getProp handler doesn't exist, the getProp handler is still executed if the property is used in an expression. Nonexistent properties report **empty**; getting the value of a custom property that doesn't exist does not cause a script error.\n\n**Custom property sets and getProp handlers**\n\nA getProp handler for a custom property set behaves differently from a getProp handler for a custom property that's in the default set.\n\nWhen you use the value of a custom property in a custom property set, the getProp call is named for the set, not the property. The property name is passed in a parameter using array notation. This means that, for custom properties in a set, you write a single getProp handler for the set, rather than one for each individual property.\n\nThe following example handles getProp calls for all custom properties in a custom property set called *expertSettings*, which contains custom properties named *fileMenuContents*, *editMenuContents*, and perhaps other custom properties:\n\n```\ngetProp expertSettings[thePropertyName]\n\t-- The thePropertyName parameter contains the name of\n\t-- the property that's being set\n\tswitch thePropertyName\n\tcase \"fileMenuContents\"\n\t\tif the expertSettings[fileMenuContents] of the target is empty then return \"(No items\"\n\t\telse pass expertSettings\n\tbreak\n\tcase \"editMenuContents\"\n\t\tif the expertSettings[editMenuContents] of the target is empty then return the noviceSettings[editMenuContents] of the target\n\t\telse pass expertSettings\n\tbreak\n\tdefault\n\t\tpass expertSettings\n\tend switch\nend expertSettings\n```\n\nAs you can see from the **pass** and **end** control structures, the name of this getProp handler is the same as the name of the custom property set that it controls  \"expertSettings\". Because there is only one handler for all the custom properties in this set, the handler uses the **switch** control structure to perform a different action for each property that it deals with.\n\nSuppose you get the \"fileMenuContents\" custom property:\n\n```\nset the customPropertySet of button 1 to \"expertSettings\"\nput the fileMenuContents of button 1 into me\n```\n\nLiveCode sends a getProp call to the button, which causes the above handler to execute. The property you queried  \"fileMenuContents\"  is placed in the \"thePropertyName\" parameter. The handler executes the case for \"fileMenuContents\": if the property is empty, it returns \"(No items\". Otherwise, the **pass** control structure lets the getProp call proceed along the message path, and when it reaches the engine, LiveCode gets the custom property.\n\n## Virtual Properties\n\nA virtual property is a custom property that exists only in a **setProp** and/or **getProp** handler, and is never actually set. Virtual properties are never attached to the object. Instead, they act to trigger **setProp** or **getProp** handlers that do the actual work.\n\nWhen you use the **set** command with a virtual property, its setProp handler is executed, but the **setProp** trigger is not passed to the engine, so the property is not attached to the object. When you use a virtual property in an expression, its getProp handler returns a value without referring to the object. In both cases, using the property simply executes a handler.\n\nYou can use virtual properties to:\n- Give an object a set of behaviors\n- Compute a value for an object\n- Implement a new property that acts like a built-in property\n\n### When to use virtual properties\n\nBecause they're not stored with the object, virtual properties are transient: that is, they are re-computed every time you request them. When a custom property depends on other properties that may be set independently, it's appropriate to use a virtual property.\n\nFor example, the following handler computes the current position of a scrollbar as a percentage (instead of an absolute number):\n\n```\ngetProp asPercentage *-- of a scrollbar*\n\tput the endValue of the target - the startValue of the target into valueExtent\n\treturn the thumbPosition of me \\* 100 div valueExtent\nend asPercentage\n```\n\nThe \"asPercentage\" custom property depends on the scrollbar's **thumbPosition**, which can be changed at any time (either by the user or by a handler). Because of this, if we set a custom property for the object, it would have to be re-computed every time the scrollbar is updated in order to stay current. By using a virtual property, you can ensure that the value of the property is never out of date, because the getProp handler re-computes it every time you call for the \"asPercentage\" of the scrollbar.\n\nVirtual properties are also useful solutions when a property's value is large. Because the virtual property isn't stored with the object, it doesn't take up disk space, and only takes up memory when it's computed.\n\nAnother reason to use a virtual property is to avoid redundancy. The following handler sets the width of an object, not in pixels, but as a percentage of the object's owner's **width**:\n\n```\nsetProp percentWidth newPercentage\n\tset the width of the target to the width of the owner of the target * newPercentage div 100\nend percentWidth\n```\n\nSuppose this handler is placed in the script of a card button in a 320-pixel-wide stack. If you set the button's \"percentWidth\" to 25, the button's **width** is set to 80, which is 25% of the card's 320-pixel width. It doesn't make much sense to store an object's percentWidth, however, because it's based on the object's **width** and its owner's **width**.\n\nConsider using virtual properties whenever you want to define an attribute of an object, but it doesn't make sense to store the attribute with the object  because it would be redundant, because possible changes to the object mean it would have to be re-computed anyway, or because the property is too large to be easily stored.\n\n### Handlers for a virtual property\n\nAs you can see by looking at the example above, a handler for a virtual property is structured like a handler for any other custom property. The only structural difference is that, since the handler has already done everything necessary, there's no need to actually attach the custom property to the object or get its value from the object. When you set a virtual property or use its value, the **setProp** trigger or **getProp** call does not reach the engine, but is trapped by a handler first.\n\n**Virtual property setProp handlers**\n\nA setProp handler for an ordinary custom property includes the **pass** control structure, allowing the **setProp** trigger to reach the engine and set the custom property (or else it includes a **set** command that sets the property directly). A handler for a virtual property, on the other hand, does not include the **pass** control structure, because a virtual property should not be set. Since the property is set automatically when the trigger reaches the end of the message path, a virtual property's handler does not pass the trigger.\n\nIf you examine an object's custom properties after setting a virtual property, you'll find that the custom property hasn't actually been created. This happens because the **setProp** handler traps the call to set the property; unless you pass the setProp trigger, the property isn't passed to LiveCode, and the property isn't set.\n\n**Virtual property getProp handlers**\n\nSimilarly, a getProp handler for an ordinary custom property either gets the property's value directly, or passes the getProp call so that the engine can return the property's value. But in the case of a virtual property, the object doesn't include the property, so the getProp handler must return a value.\n\n### Creating new object properties\n\nYou can use virtual properties to create a new property that applies to all objects, or to all objects of a particular type. Such a property acts like a built-in property, because you can use it for any object. And because a virtual property doesn't rely on a custom property being stored in the object, you don't need to prepare by creating the property for each new object you create: the virtual property is computed only when you use it in an expression.\n\nThe following example describes how to implement a virtual property called \"percentWidth\" that behaves like a built-in property.\n\n**Setting the \"percentWidth\" property**\n\nSuppose you place the \"percentWidth\" handler described above in a stack script instead of in a button's script:\n\n```\nsetProp percentWidth newPercentage\n\tset the width of the target to the width of the owner of the target * newPercentage div 100\nend percentWidth\n```\n\nBecause **setProp** triggers use the message path, if you set the \"percentWidth\" of any object in the stack, the stack receives the **setProp** trigger (unless it's trapped by another object first). This means that if the handler is in the stack's script, you can set the \"percentWidth\" property of any object in the stack.\n\nIf you place the handler in a backscript, you can set the \"percentWidth\" of any object, anywhere in the application.\n\nTo refer to the object whose property is being set, use the **target** function. The **target** refers to the object that first received the **setProp** trigger--the object whose custom property is being set--even if the handler being executed is in the script of another object.\n\n**Getting the \"percentWidth\" property**\n\nThe matching getProp handler, which lets you retrieve the \"percentWidth\" of an object, looks like this:\n\n```\ngetProp percentWidth\n\treturn 100 \\* (the width of the target div the width of the owner of the target)\nend percentWidth\n```\n\nIf you place the handler above in a card button's script, the following statement reports the button's width as a percentage:\n\n```\nput the percentWidth of button \"My Button\" into field 12\n```\n\nFor example, if the stack is 320 pixels wide and the button is 50 pixels wide, the button's **width** is 15% of the card **width**, and the statement puts \"15\" into the field.\n\nLike the **setProp** handler for this property, the **getProp** handler should be placed far along the message path. Putting it in a stack script makes the property available to all objects in the stack; putting it in a backscript makes the property available to all objects in the application.\n\n**Limiting the \"percentWidth\" property**\n\nMost built-in properties don't apply to all object types, and you might also want to create a virtual property that only applies to certain types of objects. For example, it's not very useful to get the width of a substack as a percentage of its main stack, or the width of a card as a percentage of the stack's width.\n\nYou can limit the property to certain object types by checking the **target** object's name:\n\n```\nsetProp percentWidth newPercentage\n\tif word 1 of the name of the target is \"stack\" or word 1 of the name of the target is \"card\" then exit setProp\n\tset the width of the target to the width of the owner of the target * newPercentage div 100\nend percentWidth\n```\n\nThe first word of an object's **name** is the object type, so the above revised handler ignores setting the \"percentWidth\" if the object is a card or stack.\n\n## Managing Windows, Palettes and Dialogs\n\nLiveCode provides complete control over all aspects of window management, including moving, re-layering, and changing window mode.\n\n### Moving a window\n\nUsually, you use either the **location** or **rectangle** property of a stack to move the stack window.\n\nThe**location** property specifies the center of the stack's window, relative to the top left corner of the main screen. Unlike the **location** of controls, the **location** of a stack is specified in absolute coordinates. The following statement moves a stack to the center of the main screen:\n\n```\nset the location of stack \"Wave\" to the screenLoc\n```\n\nThe **rectangle** property of a stack specifies the position of all four edges, and can be used to resize the window as well as move it:\n\n```\nset the rectangle of this stack to \"100,100,600,200\"\n```\n\n> **Tip:** To open a window at a particular place without flickering, set the stack's **location** or **rectangle** property to the desired value either before going to it, or in the stacks preOpenStack handler.\n\nYou can also use associated properties to move a window. Changing a stack's **bottom** or **top** property moves the window up or down on the screen. Changing the **left** or **right** property moves the window from side to side.\n\n### Changing a window's layer\n\nYou bring a window to the front by using the **go** command:\n\n```\ngo stack \"Alpha\"\n```\n\nIf the stack is already open, the **go** command brings it to the front, without changing its mode.\n\nTo find out the layer order of open stack windows, use the **openStacks** function. This function lists all open stack windows in order from front to back.\n\n**The palette layer**\n\nNormally, palette windows float above editable windows and modeless dialog boxes. A palette will always above a standard window, even if you bring the standard window to the front. This helps ensure that palettes, which usually contain tools that can be used in any window, cannot disappear behind document windows. It's also a good reason to make sure you design palette windows to be small, because other windows cannot be moved in front of them if the palette blocks part of the window.\n\n**The system palette layer**\n\nSystem windows--stacks whose **systemWindow** property is true--float above all other windows, in every running application. This means that even if the user brings another application to the front, your application's system windows remain in front of all windows.\n\nSystem windows are always in front of other windows, and you cannot change this behavior.\n\n### The active window\n\nIn most applications, commands are applied to the active window. Since LiveCode gives you the flexibility to use several different window types, not all of which are editable, the current stack is not always the same as the active window. The current stack is the target of menu choices such as **View -\\> Go Next** and is the stack specified by the expressionthis stack.\n\nFor example, executing the **find** command may have unexpected results if stacks of different modes are open, because under these conditions, the search may target a stack that is not the frontmost window.\n\n**Finding the current stack**\n\nThe current stack--the stack that responds to commands--is designated by the **defaultStack** property. To determine which stack is the current stack, use the following rules:\n\n**1.** If any stacks are opened in an editable window, the current stack is the frontmost unlocked stack. (A stack is unlocked if its **cantModify** property is set to false.)\n\n**2.** If there are no unlocked stacks open, the current stack is the frontmost locked stack in an editable window.\n\n**3.** If there are no stacks open in an editable window, the current stack is the frontmost stack in a modeless dialog box.\n\n**4.** If there are no editable or modeless windows open, the current stack is the frontmost palette.\n\nAnother way of expressing this set of rules is to say that the current stack is the frontmost stack with the lowest **mode** property. You can find out which stack has the lowest **mode** using the **topStack** function.\n\n**The topStack function and the defaultStack property:**\n\nThe **defaultStack** property specifies which stack is the current stack. By default, the **defaultStack** is set to the **topStack**, although you can change the **defaultStack** to any open stack.\n\nThe **topStack** function goes through the open stacks first by **mode**, then by layer. For example, if any editable windows are open, the topmost editable window is the **topStack**. If there are no editable windows, the **topStack** is the topmost modeless dialog box, and so on.\n\n**Changing the current stack**\n\nTo operate on a stack other than the current stack, set the **defaultStack** property to the stack you want to target before executing the commands. Usually, the **defaultStack** is the **topStack**, but you can change it if you want to override the usual rules about which window is active.\n\n**A note about Unix systems**\n\nIf your system is set up to use pointer focus rather than click-to-type or explicit focus, you may experience unexpected results when using LiveCode, since the current stack will change as you move the mouse pointer. It is recommended that you configure your system to use explicit focus when using LiveCode or any other applications created in LiveCode.\n\n### Creating a backdrop\n\nFor some applications, you may want to create a solid or patterned backdrop behind your application's windows. This backdrop prevents other applications' windows from being seen  although it does not close those windows  so it's appropriate for applications like a game or kiosk, where the user doesn't need to see other applications and where you want to keep distractions to a minimum.\n\n> **Note:** In LiveCode Media edition, you cannot turn off the backdrop property.\n\nTo create a backdrop, you set the **backdrop** property to either a valid color reference, or the **ID** of an image you want to use as a tiled pattern:\n\n```\nset the backdrop to \"\\#99FF66\" *-- a color*\nset the backdrop to 1943 *-- an image ID*\n```\n\nIn the LiveCode development environment, you can create a backdrop by choosing **View -\\> Backdrop**. Use the Preferences dialog box to specify a backdrop color to use.\n\n### Open, Closed, and Hidden Windows\n\nEach open stack is displayed in a stack window. A stack can be open without being visible, and can be loaded into memory without being open.\n\n**Hidden stacks**\n\nA stack window can be either shown or hidden, depending on the stack's **visible** property. This means a window can be open without being visible on the screen.\n\n> **Tip:** To list all open stacks, whether they're visible or hidden, use the **openStacks** function.\n\n**Loaded stacks**\n\nA stack can also be loaded into memory without actually being open. A stack whose window is closed (not just hidden) is not listed by the **openStacks** function. However, it takes up memory, and its objects are accessible to other stacks. For example, if a closed stack that's loaded into memory contains a certain image, you can use the image as a button icon in another stack.\n\nA stack can be loaded into memory without being open under any of the following conditions:\n\nA handler in another stack referred to a property of the closed stack. This automatically loads the referenced stack into memory.\n\nThe stack is in the same stack file as another stack that is open.\n\nThe stack was opened and then closed, and its **destroyStack** property is set to false. (If the **destroyStack** property is false, the stack is closed, but not unloaded, when its window is closed.)\n\n> **Tip:** To list all stacks in memory, whether they're open or closed, use the **revLoadedStacks** function.\n\n### The states of a stack\n\nA stack, then, can be in any of four states:\n\n**Open and visible:**The stack is loaded into memory, its window is open, and the window is visible.\n\n**Open and hidden:**The stack is loaded into memory, its window is open, but the window is hidden. The stack is listed in the Window menu and in the Application Browser.\n\n**Closed but loaded into memory:**The stack is loaded into memory, but its window is not open and it is not listed by the **openStacks** function or in the Window menu. However, its objects are still available to other stacks, and it is listed in the Application Browser. A stack that is closed but loaded into memory has a **mode** property of zero.\n\nTo remove such a stack from memory, choose **Tools -\\> Application Browser**, find the stack's name, and **Control-click** it (Mac OS or OS X) or Right-click it (Unix or Windows) in the Application Browser window and choose \"Close and Remove from Memory\" from the contextual menu.\n\n**Closed:**The stack is not loaded into memory and has no effect on other stacks.\n\n### **Window Types and the Mode Property**\n\nIn a script, you can find out a stack window's type by checking the stack's **mode** property. This read-only property reports a number that depends on the window type. For example, the **mode** of an editable window is 1, and the **mode** of a **palette** is 4.\n\nYou can use the **mode** property in a script to check what sort of window a stack is being displayed in:\n\n```\nif the mode of this stack is 5 then *-- modal dialog box*\n\tclose this stack\nelse -- some other type of window\n\tbeep\nend if\n```\n\nFor complete information about the possible values of the **mode** property, see its entry in the LiveCode Dictionary.\n\n### Window Appearance\n\nDetails of a window's appearance, such as the height of its title bar and the background color or pattern in the window itself, are mainly determined by the stack's mode. There are a few additional elements of window appearance that you can control with specific properties.\n\n**The metal property**\n\nOn OS X systems, you use a stack's **metal** property to give the stack window a textured metal appearance. This metal appearance applies to the stack's title bar and its background.\n\n> **Tip:** The metal appearance, in general, should be used only for the main window of an application, and only for windows that represent a physical media device such as a CD player. See Apple's Aqua user-interface guidelines for more information.\n\n**Window background color**\n\nThe background color or pattern of a window's content area--the part that isn't part of the title bar--is determined by the window type and operating system, by default. For example, on OS X systems, a striped background appears in palettes and modeless dialog boxes.\n\nIf you want a window to have a specific color or pattern, you can set the stack's **backgroundColor** or **backgroundPattern** property:\n\n```\nset the backgroundColor of stack \"Alpha\" to \"aliceblue\"\nset the backgroundPattern of stack \"Beta\" to 2452 *-- img ID*\n```\n\nThis color or pattern overrides the usual color or background pattern.\n\n### The Decorations Property\n\nMost of the properties that pertain to a window's appearance can also be set in the stack's **decorations** property. The **decorations** of a stack consists of a comma-separated list of decorations:\n\n```\nset the decorations of stack \"Gamma\" to \"title,minimize\"\n```\n\nThe statement above sets the stack's**minimizeBox** property to true, as well as showing its title bar, and sets other stack properties (**maximizeBox**, **closeBox**, **metal**) to false. Conversely, if you set a stack's **minimizeBox** property to true, its **decorations** property is changed to include \"minimize\" as one of its items. In this way, the **decorations** property of a stack interacts with its **closeBox**, **minimizeBox**, **zoomBox**, **metal**, **shadow**, and **systemWindow** properties.\n\n**The decorations property and menu bars in a window**\n\nOn Unix and Windows systems, the menu bar appears at the top of the window. On these systems, whether a window displays its menu bar is determined by whether the stack's **decorations** property includes \"menu\":\n\n```\nset the decorations of this stack to \"title,menu\"\n```\n\nOn Mac OS and OS X systems, the menu bar appears at the top of the screen, outside any window. On these systems, the \"menu\" decoration has no effect.\n\n**Title bar**\n\nThe user drags the title bar of a window to move the window around the screen. In general, if the title bar is not displayed, the user cannot move the window. You use the **decorations** property (discussed below) to hide and show a window's title bar.\n\nWhen the user drags the window, LiveCode sends a **moveStack** message to the current card.\n\nThe **decorations** property affects only whether the window can be moved by dragging it. Even if a stack's **decorations** property does not include the title bar decoration, you can still set a stack's **location**, **rectangle**, and related properties to move or resize the window.\n\n**Window title**\n\nThe title that appears in the title bar of a window is determined by the stack's **label** property. If you change a stack's **label** in a script, the window's title is immediately updated.\n\nIf the **label** is empty, the title bar displays the stack's **name** property. (If the stack is in an editable window whose **cantModify** is false, an asterisk appears after the window title to indicate this, and if the stack has more than one card, the card number also appears in the window title. These indicators do not appear if the stack has a**label**.)\n\nBecause the window title is determined by the stack's **label** property instead of its **name** property, you have a great deal of flexibility in changing window title. Your scripts refer to the stack by its **name**--which doesn't need to change--not its **label**, so you can change the window title without changing any scripts that refer to the stack.\n\n**The close box**\n\nThe close box allows the user to close the window by clicking it. To hide or show the close box, you set the stack's **closeBox** property:\n\n```\nset the closeBox of stack \"Bravo\" to false\n```\n\nWhen the user clicks the close box, LiveCode sends a **closeStackRequest** message, followed by a **closeStack** message, to the current card.\n\nThe **closeBox** property affects only whether the window can be closed by clicking. Even if a stack's **closeBox** property is false, you can still use the **close** command in a handler or the message box to close the window.\n\n**The minimize box or collapse box**\n\nThe terminology and behavior of this part of the title bar varies depending on platform. On Mac OS systems, the collapse box shrinks the window so only its title bar is shown. The minimize box (OS X and Windows systems) or iconify box (Unix systems) shrinks the window to a desktop icon.\n\nTo hide or show the minimize box or collapse box, you set the stack's **minimizeBox** property:\n\n```\nset the minimizeBox of this stack to true\n```\n\n> **Tip:** On OS X and Unix systems, you can set a stack's **icon** property to specify the icon that appears when the stack is minimized.\n\nWhen the user clicks the minimize box or collapse box, LiveCode sends an **iconifyStack** message to the current card.\n\n**The maximize box or zoom box**\n\nThe terminology and behavior of this part of the title bar varies depending on platform. On Mac OS and OS X systems, the zoom box switches the window between its current size and maximum size. The maximize box (Unix and Windows systems) expands the window to its maximum size.\n\nTo hide or show the zoom box or maximize box, you set the stack's **zoomBox** property:\n\n```\nset the zoomBox of stack \"Hello\" to false\n```\n\nWhen the user clicks the zoom box or maximize box, LiveCode sends a **resizeStack** message to the current card.\n\n### Making a stack resizable\n\nA stack's **resizable** property determines whether the user can change its size by dragging a corner or edge (depending on operating system) of the stack window.\n\n> **Tip:** To move and resize controls automatically to fit when a stack is resized, use the \"Geometry\" pane in the control's property inspector.\n\nSome stack modes cannot be resized, regardless of the setting of the stack's **resizable** property. Modal dialog boxes, sheets, and drawers cannot be resized by the user, and do not display a resize box.\n\nThe **resizable** property affects only whether the window can be resized by dragging a corner or edge. Even if a stack's **resizable** property is set to false, you can still set a stack's **location**, **rectangle**, and related properties to move or resize the window.\n\nWhen the user resizes a stack, LiveCode sends a **resizeStack** message to the current card.\n\n### Irregularly-Shaped and Translucent Windows\n\nYou can set a stacks **windowShape** property to the transparent, or *alpha channel* of an image that has been imported together with its alpha channel. This allows you to create a window with \"holes\" or a window with variable translucency. You can apply a shape to any type of stack, regardless of the mode it is opened, allowing such a window to exhibit modal behavior as a dialog, float as a palette, etc.\n\nYou may use either a GIF or PNG image for irregularly shaped windows. If you want translucency you must use PNG images. Translucency is currently only supported on Windows and Mac OS X systems.\n\n## Programming Menus & Menu Bars\n\nMenus in LiveCode are not a separate object type. Instead, you create a menu from either a button or a stack, then use special commands to display the menu or to include it in a menu bar.\n\nThis topic discusses menu bars, menus that are not in the menu bar (such as contextual menus, popup menus, and option menus), how to make menus with special features such as checkmarks and submenus, and how to use a stack window as a menu for total control over menu appearance.\n\nTo easily create menu bars that work cross-platform, choose **Tools -\\> Menu Builder**. See the section on the *Menu Builder* in the chapter on *Building a User interface* for more details. The details about menu bars in this topic are needed only if you want edit menu bars by script, for example if you want to include specific features not supported by the Menu Builder.\n\n### Menu Types\n\nLiveCode supports several menu types: *pulldown* menus, *option* menus (usually called popup menus on Mac OS and OS X), *popup* menus (usually called contextual menus on Mac OS and OS X), and *combo boxes*.\n\nEach of these menu types is implemented by creating a button. If the button's **style** property is set to \"menu\", clicking it causes a menu to appear. The button's **menuMode** property determines what kind of menu is displayed.\n\nEven menu bars are created by making a pulldown-menu button for each menu, then grouping the buttons to create a single menu bar. The menu bar can be moved to the top of the stack window (on Unix and Windows systems). To display the menu bar in the standard location at the top of the screen on Mac OS and OS X systems, you set the stack's **menubar** property to the group's name. The name of each button is displayed in the menu bar as a menu, and pulling down a menu displays the contents of the button as a list of menu items.\n\n### Button Menus\n\nYou can create a button menu by dragging out one of the menu controls from the tools palette. However, if you want to create one by script, the easiest is to create a button and set the **style** of the button to \"menu\". Next, you can set the **menuMode** of the button to the appropriate menu type. You can either set the **menuMode** in a handler, or use the Type menu in the button's property inspector to set the menu type.\n\nTo create the individual menu items that will appear in the menu, set the button's **text** property to the menu's contents, one menu item per line. You can either set this property in a handler, or fill in the box labeled \"Menu items\" on the Basic Properties pane of the property inspector.\n\nWhen you click the button, the specified menu type appears, with the text you entered displayed as the individual menu items in the menu.\n\n> **Tip:** To dynamically change the menu's contents at the time it's displayed, put a **mouseDown** handler in the button's script that puts the desired menu items into the button. When the menu appears, it displays the new menu items.\n\nFor menus that retain a state (such as option menus and combo boxes), the button's **label** property holds the text of the currently chosen menu item.\n\n**Handling the menuPick message**\n\nWhen the user chooses an item from the menu, LiveCode sends the **menuPick** message to the button. The message parameter is the name of the menu item chosen. If you want to perform an action when the user chooses a menu item, place a **menuPick** handler like this one into the button's script:\n\n```\non menuPick theMenuItem\n\tswitch theMenuItem\n\tcase \"Name of First Item\"\n\t\t-- do stuff here for first item\n\tbreak\n\tcase \"Name of Second Item\"\n\t\t-- do stuff here for second item\n\tbreak\n\tcase \"Name of Third Item\"\n\t\t-- do stuff here for third item\n\tbreak\n\tend switch\nend menuPick\n```\n\n**Changing the currently-chosen menu item**\n\nFor menus that retain a state (such as option menus and combo boxes), you can change the currently-chosen menu item by changing the button's **label** property to the text of the newly chosen item\n\nIf you change the currently-chosen menu item in option menus, also set the button's **menuHistory** property to the line number of the newly chosen item. This ensures that the new choice will be the one under the mouse pointer the next time the user clicks the menu.\n\n### Creating Cascading Menus\n\nTo create a cascading menu (also called a submenu, pull-right menu, or hierarchical menu), add a tab character to the start of menu items that you want to place in the submenu.\n\nFor example, the following text, when placed in a menu button, creates two menu items, then a submenu containing two more items, and finally a last menu item:\n\n**First Item**\n\n**Second Item**\n\n**Third Item Is A Submenu**\n\n**First Item In Submenu**\n\n**Second Item In Submenu**\n\n**Last Menu Item Not In Submenu**\n\nThe depth of a submenu item is determined by the number of tab characters before the menu item's name. The submenu item becomes part of the closest line above the submenu item that has one fewer leading tab character.\n\nThis means that the first line of a menu cannot start with a tab character, and any line in the button's text can have at most one more tab character than the preceding line.\n\n> **Important:** You cannot create a cascading combo box at all, and cascading option menus do not work properly on all platforms. In general, you should create cascading menus only as a part of a pulldown menu.\n\n**Cascading menus and the menuPick message**\n\nWhen the user chooses a menu item in a cascading menu, the parameter of the **menuPick** message contains the menu item name and the name of the submenu it's part of, separated by a vertical bar (`|`). For example, if the user chooses the \"Second Item In Submenu\" from the menu described above, the parameter sent with the **menuPick** message is:\n\n```\nThird Item Is A Submenu|Second Item In Submenu\n```\n\n### Ticks, Dashes & Checks in Menus\n\nThere are several special characters that you can put at the start of a line in the button's contents to change the behavior of the menu item:\n\n- A dash on a line by itself creates a divider line\n!c checks the menu item\n!n unchecks the menu item\n!r places a diamond at the start of the menu item\n!u removes the diamond\n\nIf you include any of the above special characters in a submenu item, the special character must be placed at the start of the line  before the tab characters that make it a submenu item.\n\n> **Note:** You cannot create divider lines in combo boxes or in option menus on Windows systems.\n\nThere are three other special characters that can appear anywhere in a line:\n\nPutting the `&`character anywhere in a line underlines the next character and makes it the keyboard mnemonic for that menu item on Windows systems. The `&`character does not appear in the menu, and is not sent with the parameter to the **menuPick** message when you choose the item from a menu.\n\nPutting the `/`character anywhere in a line makes the next character the keyboard equivalent for the menu item. Neither the `/`nor the character following it appear in the menu, nor do they appear in the parameter to the **menuPick** message.\n\nTo put an `&`or / character in the text of a menu, double the characters: &`&`or //.\n\nPutting the `(`character anywhere in a line disables the menu item. To put a `(`character in a menu item without disabling it, precede it with a backslash: \\\\(.\n\n> **Note:** You cannot disable lines in combo boxes or in option menus on Windows systems.\n\nAll of the above special characters are filtered out of the parameter sent with the **menuPick** message when the user chooses a menu item. The parameter is the same as the characters that are actually displayed in the menu.\n\n> **Note:** The font and color of a button menu is determined by the button's font and color properties. However, on Mac OS systems, the font and color of the option menus and popup menus is controlled by the operating system's settings if the **lookAndFeel** is set to \"Appearance Manager\", rather than by the button's font and color properties.\n\n**Enabling and disabling menu items**\n\nTo enable or disable a menu item in a handler, you can add or remove the \"(\" special character, but it is generally easier to use the **enable menu** and **disable menu** commands:\n\n```\nenable menuItem 3 of button \"My Menu\"\ndisable menuItem 4 of me\n```\n\nThese commands simply add or remove the `(`special character at the start of the designated line of the button's contents.\n\n### Menu Bars on Unix and Windows Systems\n\nA menu bar is made up of a group of menu buttons, with the **menuMode** property of each button set to \"pulldown\".\n\n> **Tip:** The Menu Builder can automatically create a menu bar for you. To use the Menu Builder, choose **Tools -\\> Menu Builder**.\n\nTo create a menu bar by hand without using the Menu Builder:\n\n**1.** Create a button for each menu, set the **style** of each button to \"menu\", and set the **menuMode** of the button to \"pulldown\". You can either set these properties in a handler, or simply choose **Object -\\> New Control Pulldown Menu** to create each button.\n\n**2.** Put the menu items into each button's contents. In each button's script, create a **menuPick** handler to perform whatever actions you want to do when a menu item is chosen.\n\n**3.** Select the buttons and form them into a group, then move the group to the appropriate position at the top of the window. For Windows systems, set the **textFont** of the group to the standard font for Windows menus, \"MS Sans Serif\".\n\n> **Important:** The buttons in your menu bar should not overlap. Overlapping buttons may cause unexpected behavior when the user tries to use a menu.\n\n### Menu Bars on Mac OS Systems\n\nTo create a Mac OS menu bar, you follow the same steps as for a Unix and Windows menu bar above. This places a group of buttons, each of whose **menuMode** property is set to \"pulldown\", at the top of your stack window.\n\nNext, you set the **menubar** property of your stack to the name of the group. This does two things: it displays the menus in the menu bar at the top of the screen, and it shortens the stack window and scrolls it up so that the group of menu buttons is not visible in the window. Since the menus are in the menu bar, you don't need to see them in the stack window as well.\n\n> **Important:** If your stack has more than one card, make sure that the group is placed on all the cards. (To place a group on a card, choose **Object menu Place Group**, or use the **place** command.) This ensures that the menu bar will be accessible on all cards of the stack, and prevents the stack from changing size as you move from card to card (to accommodate shortening the stack window for the menu bar group).\n\n**The default menu bar**\n\nIf other stacks in your application don't have their own menu bars, set the **defaultMenubar** global property to the name of your menu group, as well as setting the stack's **menubar** property. The **defaultMenubar** is used for any stack that doesn't have a menu bar of its own.\n\n> **Tip:** For a custom menu bar to work correctly inside the LiveCode development environment, you must set the **defaultMenubar** to the name of your menu group. This overrides the LiveCode IDE menu bar. You can get the menu bar back by choosing the pointer tool.\n\n**Button menu references**\n\nIf the button is a button menu that's being displayed in the menu bar, you can use the word \"menu\" to refer to it:\n\n```\nget menuItem 2 of menu \"Edit\"\n-- same as 'get line 2 of button \"Edit\"'\n```\n\nBecause menus are also buttons, you can use a button reference to get the same information. But you may need to specify the group and stack the button is in, to avoid ambiguity. (For example, if there is a standard button named \"Edit\" on the current card, the expression `button \"Edit\"`refers to that button, not to the one in the menu bar.) An unambiguous button reference to a menu might look like this:\n\n```\nget line 2 of button \"Edit\" of group \"Menu\" of stack \"Main\"\n```\n\nThe above statement produces the same information as the form using \"`menu`\", but you need to know the group name and possibly which stack it's in, so the `menu` *`menu`Name*form is a little more convenient.\n\n**The layer of menu buttons**\n\nFor a menu bar to work properly on Mac OS and OS X systems, the menus must be in layer order within the group. That is, the button for the File menu must be numbered 1, the button for the Edit menu must be 2, and so on. The Menu Builder takes care of this automatically; you only need to worry about layering if you're creating the menu bar by hand.\n\n**Changing menus dynamically**\n\nIf you want to dynamically change a menu's contents with a **mouseDown** handler at the time the menu is displayed, you must place the **mouseDown** handler in the group's script. When a menu button is being displayed in the Mac OS menu bar, it does not receive **mouseDown** messages, but its group does.\n\n**The editMenus property**\n\nWhen you set the **menubar** property of a stack to the name of a group, the stack is resized and scrolled up so the part of the window that holds the menus is not visible. To reverse this action so you can see, select and edit the buttons that make up your menu bar, set the **editMenus** property to true. This resizes the stack window so the button menus are again visible, and you can use the tools in the LiveCode development environment to make changes to them.\n\nTo scroll the stack window again so that the menus are hidden, set the **editMenus** property back to false.\n\n**Special menu items**\n\nA few menu items on Mac OS and OS X are handled directly by the operating system. To accommodate these special menu items while allowing you to create a fully cross-platform menu bar, LiveCode treats the last two menu items of the Help menu (for Mac OS and OS X), the File menu (OS X), and the Edit menu (OS X) differently.\n\nBy following these guidelines, you can make sure your menus will appear properly on all operating systems without having to write special code or create platform-specific menu bars.\n\n**The Help menu and the \"About This Application\" menu item**\n\nWhen LiveCode sets up the Mac OS menu bar, it automatically makes the last button the Help menu (regardless of the button's name). The standard Help menu items, such as \"About This Application\" and \"Show Balloons\" on Mac OS Classic, are included for you automatically; you don't need to include them in your Help menu button, and you can't eliminate them from the Help menu.\n\nLiveCode moves the last menu item in the Help menu to the \"About This Application\" position. On Mac OS systems, this is the first menu item in the Apple menu. On OS X systems, it's the first menu item in the Application menu. Therefore, the last menu item in your Help menu button should be an appropriate \"About\" item. The menu item above it must be a divider line (a dash), and above that must be at least one menu item to be placed in the Help menu.\n\n**The File menu and the \"Quit\" menu item**\n\nOn OS X systems, the \"Quit\" menu item is normally placed in the Application menu (which is maintained by the operating system) rather than in the File menu, as is standard on other platforms. To accommodate this user-interface standard, LiveCode removes the last two menu items of the File menu when a standalone application is running on an OS X system. Therefore, the last menu item in your File menu button should be \"Quit\". The menu item above it should be a divider line (a dash).\n\n**The Edit menu and the \"Preferences\" menu item**\n\nOn OS X systems, the \"Preferences\" menu item is also normally placed in the Application menu. To accommodate this user-interface standard, LiveCode removes the last two menu items of the Edit menu when a standalone application is running on an OS X system. Therefore, the last menu item in your Edit menu button should be \"Preferences\". The menu item above it should be a divider line (a dash).\n\n> **Note:** The Preferences menu item is treated in this special way only if its name starts with the string \"Preferences\".\n\n> **Tip:** If your application's user interface is presented in a language other than English, set the **name** of the Edit menu button to \"Edit\", and set its **label** to the correct translation. This ensures that the engine can find the Edit menu, while making sure that the menu is shown in the correct language.\n\n**Choosing the special menu items**\n\nWhen the user chooses any of these special menu items, a **menuPick** message is sent to the button that the menu item is contained in. This ensures that your button scripts will work on all platforms, even if LiveCode displays a menu item in a different menu to comply with user-interface guidelines.\n\nFor example, if the user chooses \"About This Application\" from the Apple menu on a Mac OS system, a **menuPick** message is sent to the Help menu button, with \"About This Application\" as its parameter. You handle the message for the About menu item in the Help menu button's script, even though LiveCode displays this menu item in a different menu on the Mac.\n\n### Stack Menus\n\nButton menus can be used for most kinds of standard menus. However, if you want to create a menu with a feature that is not supported by button menus--for example, if you want a popup menu that provides pictures, rather than text, as the choices--you can create a menu from a stack.\n\n**Creating a stack menu**\n\nTo create a stack menu, you create a stack with a control for each menu item. Since the stack menu is a stack and each menu item is an object, the menu items receive mouse messages such as **mouseEnter**,**mouseLeave**, and **mouseUp**.\n\nWhen the user chooses an item from the stack menu, a **mouseUp** message is sent to that control. To respond to a menu item choice, instead of handling the **menuPick** message, you can place a **mouseUp** handler in the script of the object.\n\nTo create a stack menu that looks like a standard menu, create a button in the stack for each menu item. The button's **autoArm** and **armBorder** properties should be set to true. Or you can choose \"Menu Item\" item in the \"New Control\" submenu of the Object menu to create a button with its properties set to the appropriate values.\n\nBe sure to set the **rectangle** of the stack to the appropriate size for the menu. Remember, when you open the menu, the stack will be displayed exactly as it looks in an editable window.\n\nFinally, either set the **menuName** property of a button to a reference to the stack, or place a **mouseDown** handler containing a **pulldown**, **popup**, or **option** command in the script of an object. When you click the button or object, the stack menu appears.\n\n**Displaying a stack menu**\n\nStack menus can be associated with a button, just like button menus. But when you click the button, instead of displaying a menu with the button's contents, LiveCode displays a stack with the behavior of a menu.\n\nYou can also display a stack menu without associating it with a button, by using the **pulldown**, **popup**, or **option** command. Normally, you use these commands in a **mouseDown** handler, so that the menu appears under the mouse pointer:\n\n```\non mouseDown -- in card script\n\tpopup stack \"My Menu Panel\"\nend mouseDown\n```\n\n### Displaying Context Sensitive Menus\n\nThere are also several commands to display a context menu. Usually, you use these commands in a **mouseDown** handler  normally either in your card or stack script:\n\n**popup** command: opens a stack as a popup menu\n\n**pulldown** command: opens a stack as a pulldown menu\n\n**option** command: opens a stack as an option menu\n\n> **Note:** If you set a button's **menuName** property to the name of a stack, the stack menu is displayed automatically when the user clicks the button. You need the **popup**, **pulldown**, and **option** commands only if you want to display a stack menu in some way other than when a button is clicked.\n\n## Searching and Navigating Cards using the Find Command\n\nThe find command in LiveCode allows you to search the fields of the current stack, then navigate to and highlight the results of the search automatically. While it is possible to build such a command using the comparison features detailed in the chapter *Processing Text and Data*, for most purposes the find command provides a complete, pre-built solution.\n\nfind [*form*] textToFind [*in field*]\n\nThe *form* can be one of the following:\n\n*normal*\n\n*characters* or character (or chars or char)\n\n*words* or *word*\n\n*string*\n\n*whole*\n\nIf no *form* is specified, the find normal form is used.\n\nThe *textToFind* is any expression that evaluates to a string.\n\nThe *field* is any expression that evaluates to a field reference. If the *field* is not specified, the **find** command searches all the fields in the current stack (except fields whose dontSearch property is set to true).\n\n```\nfind \"heart\"\nfind string \"beat must go on\" in field \"Quotes\"\n```\n\nWhen the find command finds a match, it highlights the match on the screen  if necessary navigating to the card that contains the match and scrolling the field so the text is in view.\n\nThe find command can also be used to return the location of the text that was found.\n\nTo reset the find command so that it starts searching at the beginning again:\n\n```\nfind empty\n```\n\nFor more details on the find command and associated options, see the *find command* in the *LiveCode Dictionary*.\n\n## Using Drag and Drop\n\nLiveCode allows you complete control over drag and drop  both within LiveCode windows and between LiveCode and other applications.\n\n### Initiating a Drag Drop\n\nTo begin a drag and drop operation, the user clicks and holds the mouse pointer. This sends a `mouseDown`message to the object.\n\nIf you drag from within a field, a **dragStart** message is sent. To allow drags from a locked field or from another object type, in the object's **mouseDown** handler, set the **dragData** property to the data you want to drag. When there is a value in the **dragData**, a drag and drop is initiated when the mouse is clicked and then moved.\n\n```\nset the dragData[\"text\"] to \"text being dragged\"\n```\n\nYou can set the **dragData** to contain any of the following types of data:\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------|------------------------------------------------------------------------|\n| text    | The plain text being dragged.                                          |\n| HTML    | The styled text being dragged, in the same format as the **htmlText**  |\n| RTF     | The styled text being dragged, in the same format as the **RTFText**   |\n| Unicode | The text being dragged, in the same format as the **unicodeText**      |\n| image   | The data of an image (in PNG format)                                   |\n| files   | The name and location of the file or files being dragged, one per line |\n\n> **Note:** LiveCode automatically handles the mechanics of dragging and dropping text between and within unlocked fields. To support this type of drag and drop operation, you don't need to do any scripting.\n\nFor more details, see the entries for *dragStart* and *dragData* in the *LiveCode Dictionary*.\n\n### Tracking During a Drag Drop Operation\n\nYou can use the **dragEnter** message to show an outline around an object or change the cursor when the mouse moves into it during a drag operation.\n\n```\non dragEnter -- show a green outline around the drop target\n\tset the borderColor of the target to \"green\"\nend dragEnter\n```\n\nYou can use the **dragMove** message to update the screen whenever the cursor moves during a drag and drop operation.\n\n```\non dragMove -- in a field script\n\t-- set the cursor so it shows you can only drop onto a link\n\tif the textStyle of the mouseChunk contains \"link\"\n\tthen set the cursor to the ID of image \"Drop Here\"\n\telse set the cursor to the ID of image \"Dont Drop\"\nend dragMove\n```\n\nYou can use the **dragLeave** message to remove any outline around an object or change the cursor when the mouse moves out of an object during a drag operation.\n\n```\non dragLeave\n\t-- remove any outline around the drop no-longer-target\n\tset the borderColor of the target to empty\nend dragLeave\n```\n\nFor more details, see the entries for *dragEnter*, *dragMove* and *dragLeave* in the *LiveCode Dictionary*.\n\n### Responding to a Drag and Drop\n\nTo perform an action when the user drops data onto a locked field or another object type, you handle the **dragDrop** message.\n\nThe **dragDrop** message is sent when the user drops data on an object.\n\n```\non dragDrop -- check whether a file is being dropped\n\tif the dragData[\"files\"] is empty then beep 2\n\tpass dragDrop\nend dragDrop\n```\n\nYou must set the **acceptDrop** property to true before a drop will be allowed. Usually, you set this property to true in a **dragEnter** handler.\n\nYou can use the **dragDestination** function to retrieve the long id of the object that the dragged data was dropped on. You can use the **dragSource** function to retrieve the long id of the object that was the source of the drag.\n\nWhen a drag drop has been completed, a **dragEnd** message is sent to the object the drag and drop started from.\n\n```\non dragEnd -- remove data being dragged\nd\telete the dragSource\nend dragEnd\n```\n\nYou can use the **dropChunk** function to retrieve the location of the text that was dropped in a field. For example, you could select the text that was dropped by doing the following:\n\n```\nselect the dropChunk\n```\n\nFor more details, see the entries for *dragDrop*, *dragEnter, dragDestination, dragEnd, dragSource* , *dropChunk* and *acceptDrop* in the *LiveCode Dictionary*.\n\n### Prevent Dragging and Dropping to a Field\n\nYou prevent dropping data into a field during a drag and drop by setting the **acceptDrop** property to false when the mouse pointer enters the field.\n\nIf the **acceptDrop** is set to false, when you drop data, no **dragDrop** message is sent to the field. Since the drop is automatically processed only when LiveCode receives a **dragDrop** message, this prevents the usual automatic drop behavior.\n\nUsually, you should set the **acceptDrop** in a **dragEnter** handler, as in the following example:\n\n```\non dragEnter -- in a field script\n\tset the acceptDrop to false\nend dragEnter\n```\n\nIf you want to prevent dragging text within a field, intercept the dragStart message:\n\n```\non dragStart\n\t-- do nothing\nend dragStart\n```\n\nFor more details, see the entries for *acceptDrop*, *dragDrop* and *dragEnter* in the *LiveCode Dictionary*.\n\n# Working With Databases\n\nWith the LiveCode Database library, your application can communicate with external SQL databases. *(Database access is not available in LiveCode Media.)* You can get data from single-user and multi-user databases, update data in them, get information about the database structure, and display data from the database in your stack. And with the Database Query Builder, you can automate the process of querying a database and populating fields with the data, with no scripting required. For a discussion of when it is appropriate to use an external database with LiveCode, see the topic When to Use a Database in Chapter 2.\n\nThis chapter discusses how to install necessary software to communicate with databases, how to set up automatic database queries using the Database Query Builder, and how to use the Database library to communicate between LiveCode and a database.\n\nThis topic does not include discussion of how to set up and create a SQL database, which is beyond the scope of the LiveCode documentation.\n\nTo fully understand this topic, you should know how to write short scripts and should understand the basic concepts of SQL databases (rows and columns, database cursors, and SQL queries).\n\nA few terms used in this topic, such as \"field\" and \"cursor\", are part of the standard terminology for working with databases, but have a different meaning in the context of LiveCode development. When going back and forth between database work and more general application development, be sure you understand which meaning is applicable in the context you're currently working in. When referring to database-specific terms, the documentation usually uses phrases like \"database field\" or \"database cursor\" to remind you of the context. See the Glossary within the product documentation for definitions of any term you are unsure of.\n\n## Introduction to Database Access\n\nA database is an external resource that holds information, structured in a special form for quick access and retrieval. Databases can be:\n\n- any size from small to extremely large\n- located on the same system as the application or on a remote server\n- accessible by one user at a time or by many users at once\n\n### SQL Databases\n\nA SQL database is a database that you access and control using SQL, a standard database-access language which is widely supported. You use SQL queries (statements in the SQL language) to specify the part of the database you want to work with, to get data, or to make changes to the database.\n\nLiveCode's database access is fully-featured. You can send any SQL statement to a database. You can open multiple databases (or multiple connections to the same database), maintain multiple record sets (database cursors) per connection, and send and receive binary data as well as text. You can do all this using the *Database Query Builder*, or in scripts that use the commands and functions in the *Database library*.\n\nTo see a list of LiveCode terms in the Database library, open the *Dictionary*, and type \"*database*\" into the search filter field. You can also find a interactive workshop and tutorial materials on our web site at:\n\n<http://www.runrev.com/developers/lessons-and-tutorials/explore-livecode/databases/>\n\n### Why use an External Database?\n\nSee the section on When to use a Database in Chapter 2.\n\n### The Basics of Database Structure\n\nA database is built of records, which in turn are built out of database fields. A field is the smallest part of a database that can be separately addressed. Each database field contains a particular kind of information. This might be a name, a file path, a picture, or any other kind of information. Each record contains one value for each of its fields. A set of records is called a database table, and one or more tables comprise a database.\n\nHere's an example: suppose you have a database of customers for your business. The fields of this database might include the customer name, a unique customer ID number, and shipping address. Each record consists of the information for a single customer, so each record has a different customer name, shipping address, and so on.\n\n> **Note:** You may have noticed that the database structure being described resembles a multiple-card stack that has the same fields on each card. A database field is like a field in a stack, and a record is like a card. A stack set up this way can act as a database, in fact, but lacks some of the features of an external database, such as the ability to perform SQL queries and the ability to perform robustly when accessed by more than one user.\n\nYou can also think of the set of customer records as a grid (like a spreadsheet). Each row is a record, and each column is a field, so each cell in the grid contains a different piece of information about a particular customer. Here's an example:\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|--------|-------------------|---------------|-------------|\n| **ID** | **Customer Name** | **Address**   | **Country** |\n| 123    | Jane Jones        | 234 E. Street | U.K.        |\n| 836    | Acme Corporation  | PO Box 23788  | USA         |\n| 823    | CanCo, Inc.       | 1 CanCo Blvd. | Japan       |\n\nFigure 59  Example Database Grid\n\nThere are three rows in this grid (each is the record for a particular customer) and four columns (each is one of the fields).\n\nA row of the database means one single customer record, which has one value for each field. A column of the database means the set of all values for one of the fields, one for each record (for example, the set of all customer addresses).\n\nMore generally, each row describes one of the things in the database, and each column describes a particular state for each thing in the database.\n\nThe set of all customer records makes a table. Your database might include only this table, or it might include other related tables, such as a list of all sales. You can also connect related data from different tables of the same database. For example, if each record in the Sales table includes the ID number of the customer who bought the product, you can link all the sales records for a customer to that customer's record in the Customers table.\n\n### SQL and Record Sets  Database Cursors\n\nSQL works primarily with sets of records, rather than individual rows. When you send a SQL query to a database, the query typically selects certain records which you can perform further operations on. The set of records resulting from a SQL query is called a database cursor, or record set. SQL queries let you describe the characteristics of the records you require, instead of processing each record one by one to find out whether it matches your criteria.\n\nFor example, consider the customer table we talked about in the previous section. To work with only US customers, you can write a SQL query that selects only records where the country field is \"USA\". This subset of records then becomes a record set. You can find out more about the fields and records contained in this record set, and move from record to record within this subset of the database. You can create more than one record set to work with more than one set of records at a time.\n\n> **Note:** Different database implementations have different limitations on movement within a record set. For example, some databases won't let you move backward within a record set: instead, you must start at the first record and move forward in order to examine the data.\n\n### Choosing a Database\n\nLiveCode directly supports the following database implementations:\n\n- Oracle\n- MySQL\n- SQLite\n- PostgreSQL\n- Valentina\n\nLiveCode also supports connecting to a database via ODBC. You can use ODBC to use Access, FileMaker, MS SQL Server and many other database implementations. See below for more information about ODBC.\n\nLiveCode's database commands and functions use the same syntax regardless of what type of database you are connecting to. You don't need to learn a separate database language for each type. Instead, when you first open a database with the **revOpenDatabase** function, you specify the type as one of the parameters so LiveCode knows what type of database it's dealing with. The Database library handles the details of each type behind the scenes for you.\n\nWhen you use the *Database Query Builder*, you simply select the database type you want to use. Like the Database library, the *Database Query Builder* handles the details for you. You can easily switch between database types.\n\n## Reasons to Choose a Database Type\n\nWhich type of database to choose depends on a number of factors. If you need to work with an existing database, or already have a database manager installed, the decision is made for you. Likewise, if you're already an expert at a particular database implementation, you'll probably prefer to go on using that one.\n\nOther factors in your choice may include price, performance, licensing model (commercial or open source), and platform support. If your users are on a particular set of platforms, you'll need to choose a database that is supported on all those platforms. Runtime do not endorse any particular database type, the information provided on the different types is for informational purposes only.\n\n### Overview of ODBC\n\nOpen Database Connectivity (ODBC) is a system that allows developers to access any type of compatible database in a standard way.\n\nTo communicate with a database, you usually have to add code that uses the database's own proprietary protocols. Without ODBC, in order to create a program that can communicate with--for example--FileMaker, Access, and Oracle databases, LiveCode would have to include code for three different database protocols. With ODBC, LiveCode can communicate with any of these database types using the same code.\n\n**ODBC Managers**\n\nTo work with databases through ODBC, you need two pieces of software: an ODBC manager, plus a database driver for the specific database type you're using.\n\nWindows 2000 and Windows XP, and OS X version 10.2 and later, include ODBC software with the operating system. For earlier versions, and for Mac OS and Unix systems, you can download an ODBC manager and a set of drivers. (See the section below titled \"Software for Database Access\" for more information.)\n\n### **Performance for Direct Access Versus ODBC Access**\n\nTypically, accessing a database via ODBC takes more configuration and is slower than accessing the database directly. For this reason, LiveCode provides the ability to access MySQL, PostgreSQL and Oracle databases directly without going through the ODBC protocol. This ability will be valuable for anyone doing complex or extensive professional database work.\n\nThe syntax of the functions in the Database library is identical for all database types, so you do not need to rewrite your scripts to take advantage of the increased efficiency of direct access.\n\n## Software for Database Access\n\nTo provide connectivity to databases, LiveCode works with database drivers--software that translates application requests into the protocol required by a specific database.\n\n### Finding Database Drivers\n\nDatabase drivers for certain database types are included in the LiveCode distribution. (The list of included database types depends on the platform.) The sections below list which database drivers are included with which platforms.\n\nIf you have installed LiveCode, you have all the software needed to use the included database types. For other database types, you will need to obtain the appropriate database drivers before you can work with those databases.\n\n> **Important:** This section includes links to third-party web sites and contains information about third-party software. This information is provided for your convenience, but RunRev is not responsible for the software packages and sites referenced. Runtime regrets that it cannot provide any support for installation and configuration of any databasae.\n\n### MySQL\n\nMySQL database drivers are included as part of the LiveCode installation on Linux, Mac OS X, and Windows systems.\n\n### Oracle\n\nLiveCode includes drivers for Oracle on Windows and (currently) PPC Mac OS X.\n\nTo obtain an Oracle database driver for your platform, visit the Oracle web site at *http://www.oracle.com*.\n\n### PostgreSQL\n\nA PostgreSQL database driver is included as part of the LiveCode installation on Linux, Mac OS X and Windows systems.\n\n### SQLite\n\nDrivers for accessing this database are included with LiveCode. No additional installation is necessary.\n\n### ODBC managers and database drivers\n\nTo use a database via ODBC, you must install the necessary ODBC software for your platform. (Some operating systems include an ODBC installation.) ODBC software includes one or more database drivers, plus an ODBC manager utility.\n\n**ODBC on Windows systems**\n\nWindows 2000 and Windows XP include the MDAC (Microsoft Data Access Components) package as part of the standard system installation. To configure ODBC on Windows systems, use the ODBC Data Sources control panel.\n\nFor earlier versions of Windows, you can download MDAC from the Microsoft web site at *http://www.microsoft.com/data/download.htm*.\n\n**ODBC on Mac OS X systems**\n\nOS X version 10.2 and later includes iODBC software as part of the standard system installation. To configure ODBC on OS X systems, use the ODBC Administrator application in the Utilities folder.\n\n**ODBC on Unix systems**\n\nLiveCode supports iODBC and UnixODBC on Unix systems. You can download the iODBC software from the iODBC web site at *http://www.iodbc.org/*. You can download the unixODBC software from the unixODBC web site at *http://www.unixodbc.org*.\n\n**Creating a DSN for ODBC access**\n\nOnce you have installed the necessary software, you use the ODBC manager to create a DSN, which is a specification that identifies a particular database.\n\nYou use the DSN to connect to the database via ODBC. The following example opens a connection to a database whose DSN is named \"myDB\":\n\n```\nget revOpenDatabase(\"ODBC\",\"myDB\",,\"jones\",\"pass\")\n```\n\nTo connect to a database using the Database Query Builder, you enter the DSN's name in the Database Query Builder window.\n\nOne of the advantages of setting up a DSN is that if you wish to change the location of the database, you only have to edit the DSN settings, not your application code. You can think of a DSN as a kind of shortcut or alias to your database.\n\nPrinting is a vital aspect of many applications. LiveCode provides a comprehensive set of printing capabilities. Whether you want a simple print out of your stack, want to print labels or produce complex reports, LiveCode has the features you need.\n\n## Introduction to Printing\n\nLiveCode supports a number of methods of printing. You can use the *print card command* and have LiveCode manage the layout of cards on the paper. Alternatively you can use the *print into rectangle commands* which allow you to take full control over the layout of your print out. The former method is most suited to implementing simple print functionality, while the latter is better suited for more complex layout printing or printing reports. Finally, you can use the built-in field printing script library to print the contents of any text field using a simple command.\n\nLiveCode also includes a full set of features to access and set printer device options, including options such as margins, page range and number of copies. On Mac OS X systems you can also print directly to a PDF file  even without showing the user a print dialog if choose to. On Windows systems this option will create an XPS file and on Unix systems a Postscript file. This feature is invaluable if you want to produce a high resolution file PDF, XPS or Postscript file respectively, from your stack.\n\n## Controlling Printer Device Settings\n\nLiveCode gives you full programmatic control over your printer device and any available settings.\n\n### Choosing a Printer\n\nUse the **`availablePrinters`** to list the printers available on the user's system. Printers can include fax modems and networked devices. If the `availablePrinters` is empty, no printer is assigned. For example, to place a list of the available printers into a list field:\n\n```\nput the availablePrinters into field \"list of printers\"\n```\n\nSet the **printerName** to the printer you want to use to print. You can use any printer listed in the availablePrinters. This property is useful when producing an in-house utility that needs to print to a specific printer on the corporate network, or for automatically restoring the user's previous printer choice stored in a preferences file.\n\n```\nset the printerName to the cSavedPrinter of stack \"My Preferences\"\n```\n\nThe **printerFeatures** provides a list of the features supported by the currently selected printer. Features will vary widely from device to device, but typical features may include things such as \"collate\", \"color\" and \"duplex\". Use this property to enable and disable output options in any custom printer settings dialog.\n\n### Choosing Output Mode (e.g. Print to File)\n\nThe **printerOutput** global property allows you to choose the output mode for subsequent printing commands. This property is set by the system to the default printer on startup and will be changed if you open a system print dialog in which the user chooses a different printer. If this property is set to *device* it will output to the physical printer. Alternatively, you can set it to a file path to print to a file. On Mac OS X this will create a PDF file, on Windows an XPS file and on UNIX a postscript file. On Mac OS X you can set this to *preview* to create a preview.\n\nFor example, to save the current card to a file:\n\n```\nask file \"Save as:\nset the printerOutput to (\"file:\" & it )\nprint this card\n```\n\n### Working with Printer Dialogs\n\nIn most applications that need to print, you will want to provide a way to bring up the standard OS Print and Page Setup dialogs. Typically you would make these dialogs available from Print and Page Setup items in the File menu of your application. When the user makes changes in these dialogs the changes are made accessible to you in global properties. We discuss how to save and utilize these properties below.\n\n> **Note:** It is not necessary to bring up the standard OS dialogs to alter printer settings. You may set the appropriate printer setting directly by script instead.\n\nOn Linux & Unix systems you will need a recent version of GTK installed in order to display the OS printer dialog. If you don't have this installed, LiveCode will display its own printer dialog which has been built as a stack and script library. This dialog mimics the standard system printer dialog and sets the LiveCode printing global properties directly.\n\n> **Tip:** You may force LiveCode to use its own internal print settings dialog by setting the `systemPrintSelector`global property to false. Advanced users may customize the printer dialog that LiveCode uses by running `toplevel \"print dialog\"`or `toplevel \"page setup\"`in the Message Box. Remember to save a copy of the stack as it will be overwritten each time you upgrade your copy of LiveCode.\n\n> **Important:** The LiveCode print and page setup dialogs must be included in a standalone application if you use them. Ensure that the check box Print Dialog is turned on in the Standalone Application Settings dialog for your application. You do not need to include these dialogs if you only use the OS native print dialogs. For more information on including resources in your standalone application, see the chapter on Building Standalone Applications.\n\nTo bring up the standard OS printer dialog, use the **`answer printer`** command.\n\n```\nanswer printer\n```\n\nIf the user does not press the cancel button then any changes to the printer settings will be reflected in the global printing properties, discussed below.\n\nTo bring up the standard OS page setup dialog, use the **`answer page setup`** command.\n\n```\nanswer page setup\n```\n\n### Saving Printer Settings\n\nTo save or set a complete set of options relating to the current printer which includes every setting in the OS Page Setup and Print dialogs, use the **printerSettings** global property.\n\nThe **printerSettings** property is a binary string that completely describes the current settings. The property contains the name of the printer and the settings currently in use.\n\nYou should not attempt to modify the printerSettings but rather get and set it in its entirety. To access individual printer properties, use the global printing properties described below.\n\nWhen you set the **printerSettings** property to a saved value, LiveCode will choose the printer named in the property and set all of its settings to those contained within the property. If the printer cannot be found LiveCode will return the error \"unknown printer\" in the result. If the printer is found but the settings are not valid then LiveCode will choose the printer and reset it to default values.\n\n> **Note:** You must save a separate copy of the printerSettings property for each printer or OS you intend to use. The printerSettings property cannot be transferred between platforms. For example, a printerSettings property generated on a Windows computer cannot be used on Mac OS X  even for the same printer. If you want to alter settings across different platforms and printer types use the global printing properties described below. Use the printerSettings for convenience when you know you will be using the same printer and want to save all the settings, or where you are setting esoteric properties not listed in the global printing properties described below.\n\nTo save the current printer settings into a custom property stored on the current stack:\n\n```\nset the cSavedPrinterSettings of this stack to the printerSettings\nsave this stack\n```\n\nThen to restore these settings:\n\n```\nset the printerSettings to the cSavedPrinterSettings of this stack\n```\n\n## Paper Related Options\n\nThis section discusses how you get and set paper related options  the rectangle area of the paper, the paper size, the orientation and the scale to use to print onto the paper. These paper options apply to all types of printing, i.e. card, field and layout printing.\n\nUse the **printRectangle** to get the printable rectangle area within the paper (returned in device co-ordinates). This property takes into account any settings applied by the user in the Page Setup and Printer dialogs including the print orientation (e.g. landscape or portrait). The rectangle is represented left,top,right,bottom and is always relative to the top left of the page  thus the top left will always be 0,0. The printRectangle will always be within the **printPaperRectangle**  the rectangular area of the sheet of paper.\n\nThe printRectangle property is read only and cannot be set directly  to alter it you must set other options relating to the paper, for example the `printPaperOrientation`(discussed below).\n\nDo not confuse the `printMargins`and other card layout printing properties with paper properties such as the `printRectangle`. The `printMargins`only applies to printing cards using LiveCode's automatic card layout capabilities (discussed below). Thus the `printMargins`has no effect on `printRectangle`.\n\nUse the **printPaperOrientation** to get and set the orientation of your print out. This property may be set to one of the following values:\n\n*portrait*: rotated 0 degrees.\n\n*landscape*: rotated 90 degrees clockwise.\n\n*reverse portrait*: rotated 180 degrees clockwise.\n\n*reverse landscape*: 270 degrees clockwise.\n\n```\nset the printPaperOrientation to \"landscape\"\n```\n\nUse the **printPaperScale** property to apply a scale factor to your print out after all other settings have been taking into account.\n\nThe `printPaperScale` is applied after all other layout and scaling options. For example, if you have used the layout printing features to print a series of cards at 50% scale, then set the `printPaperScale`, this factor will be applied to the entire layout after the card layout scaling has been calculated.\n\nTo print a range between 1 and 100% set the `printPaperScale`to a number between 0 and 1. To print at 200% set the `printPaperScale`to 2.\n\n```\nset the printPaperScale to 0.5 -- 50%\n```\n\n## Job Related Options\n\nThis section discusses how to get and set job related options  the number of copies, duplex printing, collation, color, title and printable area.\n\n> **Important:** The available job options all depend on what the currently selected printer supports (use the `printerFeatures`property, described above, to retrieve a list of features supported by the current printer).\n\nUse the **printCopies** property to get and set the number of copies to print. The printCopies should be set to a value of 1 or more.\n\n```\nset the printCopies to 5 -- print 5 copies\n```\n\nUse the **printDuplex** property to tell the printer to print double sided. This property may be set to any of the following values:\n\n*none*: no double-sided printing\n\n*short edge*: double-sided printing with tumble (flip the non-facing page)\n\n*long edge*: double-sided printing without tumble.\n\n```\nset the printDuplex to \"short edge\"\n```\n\nUse the **printCollate** property to specify whether to interleave multiple copies of a print job. If a print job has three pages, P1, P2 and P3, with printCollate set to *true* and `printCopies`set to 2 the output order will be P1, P2, P3, P1, P2, P3. With printCollate set to *false* the output will be P1, P1, P2, P2, P3, P3.\n\n```\nset the printCollate to true\n```\n\nUse the **printColors** property to specify whether to print in color or not. If \"color\" is not among the lines of the `printerFeatures`then this property will have no effect and all print jobs will be printed in monochrome. This property may be set to either *true* or *false*.\n\nFor example, to check if color printing is supported on the current printer and use it if it is:\n\n```\nif \"color\" is among the lines of the printerFeatures then set the printColors to true\n```\n\nUse the **printTitle** property to specify the name of the next print job in the system printer queue. Setting this property to match the name of the user's document will ensure that the user is able to recognize it in the system printer queue utility. If the `printTitle`is empty at the start of a printing loop, the title of the defaultStack will be used.\n\n```\nset the printTitle to \"My Report 1\"\n```\n\nUse the **printRectangle** property to determine the printable region of the physical page as returned by the printer. This rectangle will always be contained within the `printPaperRectangle`. Thus you should use the printRectangle and not the `printPaperRectangle` when calculating a print layout. The `printPaperRectangle` is useful if you are generating a print preview and want to show the entire area of the paper including any margin areas that cannot be printed on. This property is read only and cannot be set directly.\n\n### Printer Font Metrics (Windows)\n\nWindows systems sometimes use different versions of the same font for displaying text on screen and printing. This can result in layouts and line breaks differing between the screen display and the printed output. To prevent this from happening, you can tell LiveCode to use the printer fonts for display on screen. To do this, set a stacks **formatForPrinting** property to true.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Do:**                                                                                                                                                                                                                                \n| |                                                                                                                                                                                                                                         \n Set the `formatForPrinting`stack property to true before loading a stack in memory. If the stack is already loaded, set this property to true then save and reload it. (Save then use *Close and Remove from Memory* in the File menu).  \n| |                                                                                                                                                                                                                                         \n Create a stack off screen (with `formatForPrinting`set to true) with your print layout template and copy text into it prior to printing.                                                                                                 \n| |                                                                                                                                                                                                                                         \n Set the `formatForPrinting`before doing any print layout related calculations on the stack.                                                                                                                                              \n| |                                                                                                                                                                                                                                         \n Set the `formatForPrinting`to true on any print preview stack being displayed to the user.                                                                                                                                               | **Don't:**                                                                                                                                                                                                      \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n| |                                                                                                                                                                                                                                          Allow the user to directly edit text in fields whose `formatForPrinting`is set to true. Attempting to do this may cause display anomalies. Set this property to false and reload the stack first.                 \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n| |                                                                                                                                                                                                                                          Generally use stacks with `formatForPrinting`set to true for display on screen, as this will show text that has been optimized for print display (instead of screen display), which is harder to read on screen.  \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n| |                                                                                                                                                                                                                                          Use this property on other platforms  Windows is the only platform that uses different fonts on screen vs. in a print out.                                                                                      \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n| |                                                                                                                                                                                                                                          Use the `windowBoundingRect` property to constrain display of a stack who's `formatForPrinting`has been set to true  this property will be ignored when the stack is opened or maximized.                          |\n\nFigure 60  Dos and don'ts of printer font metrics on Windows\n\n## Printing a Card\n\nOnce you have set your printer, paper and job options (above) you are now ready to use one of the print commands to start printing. At its simplest, the **print** card command allows you to print a card. Later we will discuss ways of printing more complex layouts, fields and text.\n\n```\nprint this card -- prints the current card\nprint card 12 -- prints card 12\n```\n\nFor more details on how to specify which cards to print, see the `print`command in the *LiveCode Dictionary*.\n\nTo print a scale between 1 and 100% set the **printScale** to a number between 0 and 1. To print at 200% set the `printScale`to 2.\n\nThe printScale applies to each card that you print. It is not related to the `printPaperScale`which is applied to the entire print job after all other scaling calculations have been applied. Thus you may set the `printPaperScale`to 0.5 to print at 50%, then print individual cards at different printScale values. With a `printPaperScale`of 0.5, a printScale of 2 would result in that card being printed at 100%.\n\nWhen printing a card, use the **printMargins** to specify the margins around the border of the card on the page.\n\n> **Note:** When calculating placement on the printed page, all calculations assume that there are 72 dots per inch  regardless of platform or printer device. LiveCode will automatically adjust the print out for resolution of the actual device. This makes it simple to calculate your printed layout.\n\n```\n-- a one-inch margin on each side\nset the printMargins is set to 72,72,72,72\n```\n\nprintMargins only applies when using print card directly. It does not have any effect on printing cards into a layout (described below).\n\nThe **printCardBorders** property specifies whether or not the bevel border around the edge of a card should appear in the print out.\n\n### Card Layout Options\n\nWhen using the basic print card form of the print command, there are two layout options that allow you to customize the positioning of cards on the printed page. If you require further flexibility, see the section on printing a layout, below.\n\nUse the **printRowsFirst** property to specify whether cards should be printed across and down or down then across.\n\nConsider a simple example of printing multiple cards  this example is useful for printing labels. In this example we have a stack that contains 8 cards, each one containing a mailing label. If you want to try out this example:\n\n- Create a stack and size it to be small  the size of a mailing label\n- Create a single field, and in the field Inspector turn off the *Shared Text* property\n- Group the field and in the group property *Inspector* turn on *Behave as Background*\n- Turn on *Select Grouped* on the Toolbar and select the field\n- Place the contents of the first mailing label into the *Contents* tab of the *Inspector*\n- Create 8 more cards, and in each select the field and place the contents of a different label\n\nThus we have a stack that looks like the figure below.\n\n![](images/image93.png)\n\nFigure 61  Print label stack example\n\nNow we will implement the printing commands. If this was a real application you would probably want to put these in a Print command in the File menu. In this instance you may execute the following in the multi-line message box (open the Message Box then press the second icon to get the multi-line pane).\n\n```\n-- allow the user to choose printer output options\nanswer printer\nprint 9 cards\n```\n\nPress enter to execute the commands.\n\nThe resulting print out will look like the figure below.\n\n![](images/image94.png)\n\nFigure 62  Printing 9 label-sized cards with default settings\n\nIf we modify the print commands to include an additional line to turn off the printRowsFirst:\n\n```\nanswer printer\nset the printRowsFirst to false\nprint 9 cards\n```\n\nThe resulting print out will look like the figure below.\n\n![](images/image95.png)\n\nFigure 63  Printing 9 label-sized cards with printRowsFirst set to false\n\nUse the **printGutters** property to specify the margin between each card. By default the printGutters are set to 36,36 or one half inch horizontally and vertically.\n\nIn the following example, we print the same label stack but reduce the space between each label to 1/10<sup>th</sup> of an inch. To make it easy to see the differente we also turn on printing of card borders using the printCardBorders property.\n\n```\nanswer printer\nset the printGutters to 7,7\nset the printCardBorders to true\n```\n\nprint 9 cards\n\nThe resulting print out will look like the figure below.\n\n![](images/image96.png)\n\nFigure 64  Printing 9 label-sized cards with borders and a narrow gutter between each\n\n## Printing Fields & Text\n\nTo print a field, use the **revPrintField** command. This command takes a single parameter, a reference to a field. This command only allows printing a single field. If you need to include a header and footer or text you have constructed programmatically, see the **revPrintText** command below.\n\n```\nrevPrintField the long id of field \"text document\"\n```\n\nrevPrintField is implemented as a script library located in the LiveCode IDE. The script library creates an invisible stack, sets the rectangle of that stack to the current paper size, sets the `formatForPrinting`to true, creates a field, then copies the contents of the field you specify into this invisible stack. It then prints the field one page at a time, scrolling the text after each page. Advanced users can locate this library script by going to the *Back Scripts* tab in the Message Box, turning on the checkbox for *Show LiveCode UI Back Scripts*, then editing the script of *button \"revPrintBack\"*. The *revPrintField* handler is near the top of the script.\n\nUse the **revShowPrintDialog** command to control whether the system printer and page setups dialogs should be shown by `revPrintField`or revPrintText.\n\n```\n-- show the system printer dialog, but not page setup\nrevShowPrintDialog true, false\nrevPrintField the long id of field \"text document\"\n```\n\nUse the **revPrintText** command to print plain or styled text together with an optional header and footer.\n\n```\nrevPrintText textToPrint [,headerText [,footerText [,fieldTemplate]]]\n```\n\nThe *textToPrint* is anything which evaluates to a string. If you want to printed styled text, pass HTML instead of plain text. (To convert a field containing styled text to a HTML use the **htmlText** property.)\n\nThe *headerText* and *footerText* contains the text to use as a header and footer. You may include an expression that is computed for each page. For more details on using expressions, see the *LiveCode Dictionary* entry for revPrintText.\n\nThe *fieldTemplate* parameter allows you to specify a field reference to use. Fonts in the print out will be inherited from this field.\n\n## Printing a Layout\n\nIf you need to print a more complex layout than allowed with the basic print card command or text printing commands (described above), you can use the **print card into rect** syntax to create any sort of layout you choose.\n\n```\nprint card from topLeft to rightBottom into pageRect\n```\n\nThe *topLeft* is the top left coordinate of the current card to start printing at.\n\nThe *rightBottom* is the bottom right coordinate of the current card to stop printing at.\n\nThe *pageRect* is therectangular area on the paper to print into.\n\nprintMargins only applies when using print card directly. It does not have any effect on printing cards into a layout. Use `theprintRectangle`to get the printable area when working with layout printing.\n\nFor example, lets say that we want to print the text field from the middle of the stack in figure 73 below. (You can load the stack shown in the picture by going to your LiveCode installation folder then opening Resources-\\> Examples-\\> SQLite Sampler.rev.) We want the output to scale to take up the entire width of the paper and half the height.\n\n![](images/image97.png)\n\nFigure 65  Stack with text field to print into a layout\n\n```\nprint this card from the topleft of field \"theText\" to the bottomRight of field \"theText\" into 0,0,item 3 of the printRectangle, round(item 4 of the printRectangle / 2)\n```\n\nThis results in the print out shown in figure 74 below.\n\n![](images/image98.png)\n\nFigure 66  Result of layout printing command\n\nYou can construct a complex layout taking components from multiple stacks by printing a sequence of rectangles onto the same page. For example, you may have a stack that contains a standard header and footer, another that contains a logo, and a layout that contains text. Use the **open printing** command to start a print job, then print each element into the appropriate rectangle on the paper. The use then **close printing** command to send the print job to the printer. The example in figure 75 below shows two stacks with printable regions that we want to combine onto a single sheet of paper.\n\n![](images/image99.png)\n\nFigure 67  Separate header and body stacks to print into a layout\n\nTo print these onto a single sheet:\n\n```\nanswer printer -- show the system print settings dialog\nopen printing -- start a print job\n-- work with the header stack\nset the defaultStack to \"header\"\n-- print the header field onto the top left of the paper\nprint this card from the topLeft of field \"header\" to the bottomRight of field \"header\" into the rect of field \"header\"\n-- save the bottom of the header\nput the bottom of field \"header\" into tHeaderBottom\nset the defaultStack to \"report editor\"\n-- print the table field below the header\nprint this card from the `topLeft`of field \"report table\" to the bottomRight of field \"report table\" into 0,tHeaderBottom,the`right of field \"report table\", the bottom of field \"report table\" + tHeaderBottom\n-- send `the`job to `the`printer\nclose`printing\n```\n\n![](images/image100.png)\n\nFigure 68  Result of layout printing command with multiple stacks\n\n### Printing a complex layout\n\nTo print a more complicated layout, create a stack and set its rectangle to the current `printRectangle`. Add rectangular areas for each component you will be printing. Then set *Geometry* properties (see the section on the *Geometry Manager*, above for more information) on each of these rectangles so they resize correctly when the stack is scaled. Set up your print routine so that you open this stack invisibly then resize it to the `printRectangle`. This will trigger the geometry routines and scale the rectangular areas correctly. Then run your sequence of print commands to print into each rectangle.\n\nIn figure 77 below, we have set the size of the stack to the `printRectangle` then added 4 rectangle graphics. We have named each graphic and turned on the *Show Name* property for each so you can see the name.\n\n![](images/image101.png)\n\nFigure 69  Stack template for printing a layout\n\nNext, we set Geometry properties for each of the rectangle graphics. The header graphic is set to scale relative to the right and bottom, with a minimum size limit of 100 pixels (see figure 75 below). The body graphic is set to link the top edge to the header graphic, the right and bottom to the stack (see figure x below). The footer 1 graphic is set to scale the right edge and position the bottom edge. And footer 2 is set to position both the right and bottom.\n\n![](images/image102.png)![](images/image103.png)\n\nFigure 70  Example geometry properties for print layout stack\n\nTo make the printing template stack take on the size of the paper, we can add the following handler to the stack script:\n\n```\non preOpenStack\n\tset the width of this stack to (item 3 of the printRectangle - item 1 of the printRectangle)\n\tset the height of this stack to (item 4 of the printRectangle - item 2 of the printRectangle)\nend preOpenStack\n```\n\nWe now have a working print template stack. All that remains is to write the script that prints into the rectangles:\n\n```\n-- prepare to load this stack off screen\nhide stack \"print layout\"\n\n-- this will trigger the stack to resize, which run the geometry routines, giving us the correct values for each rectangle\ngo stack \"print layout\"\n\n-- now we store these rectangle coordinates in variables\nput the rect of graphic \"header\" into tHeaderRect\nput the rect of graphic \"body\" into tBodyRect\nput the rect of graphic \"footer 1\" into tFooter1Rect\nput the rect of graphic \"footer 2\" into tFooter2Rect\n\n-- we can close the layout stack as its no longer needed\nclose stack \"print layout\"\n\n-- load the system printer dialog to allow the user to choose number of copies, etc.\nanswer printer\n\n-- start the print job\nopen printing\n\n-- set the stack we are working on to a stack containing the header\n-- you could use any stack or region within a card here\nset the defaultStack to stack \"header graphics\"\n\n-- print from the rectangle of our header group into the rectangle we stored earlier\n-- we could use a graphic or any rectangular area instead of a group\nprint this card from the topLeft of group \"header\" to the bottomRight of group \"header\" into tHeaderRect\n\nset the defaultStack to \"body contents\"\n\nprint this card from the topLeft `of`group \"body\" to the bottomRight `of`group \"body\" into tBodyRect\n\nset the defaultStack to \"footer1\"\n\nprint this card from the topLeft of group \"footer1\" to the bottomRight of group \"footer1\" into tFooter1Rect\n\nset the defaultStack to \"footer2\"\n\nprint this card from the topLeft of group \"footer2\" to the bottomRight of group \"footer2\"\n\n-- send the print job to the printer\nclose `printing`\n\n-- check to see if the user cancelled or there was an error\nif the result is cancel then\n\t-- insert any code you need here to handle cancellation\nelse if the result is not empty then\n\t-- bring up an error dialog\n\tanswer Printer Error\nelse\n\t-- insert any code you need here to handle success\nend if\n```\n\nFor more information on how to print multiple pages of a complex layout, see the section on *Printing Multiple Pages*, below. For information on printing scrolling text fields into an area within a layout, see the section on *Working with Scrolling Fields when Layout Printing*, below.\n\n## Printing Multiple Pages\n\n### Multiple pages using card printing\n\nTo print multiple pages when printing cards, simply specify which cards you want to print as part of the print command.\n\nprint {range}\n\nExamples:\n\n```\n-- prints the current card\nprint this card\n-- prints all cards in the current stack\nprint all cards\n-- prints the next 10 cards, starting with the current card\nprint 10 cards\n-- prints card 3 to 7 of the current stack\nprint card 3 to 7 print marked cards\n-- prints all cards where the mark property is true\nprint marked cards\n```\n\n### Multiple pages when using layout printing\n\nTo print multiple pages when printing layouts, use the **open printing** command to open a print job. Then print the layout for the first page (see above). Then use the **print break** command to insert a page break into the print job. Then lay out the second page and so on. Finally, use the **close printing** command to send the print job to the printer.\n\n### Working with Scrolling Fields when Layout Printing\n\nTo print a single scrolling text field, use the `revPrintText`command (see above for more information). If you want to incorporate the contents of a scrolling field within a layout, use the **pageHeights** property to scroll the field each time you print a page, then `print break`to move to the next page.\n\nThe pageHeights returns a list of values to indicate how far a scrolling field needs to be scrolled to avoid clipping a line of text on each page of your print out. (You should use this feature in conjunction with the formatForPrinting property, above.)\n\n```\n-- store a list of pageHeights\nput the pageHeights of field \"body text\" into tHeightsList\n-- scroll the field to the start\nset the scroll of field body text to 0\n-- start the print job\nopen printing\nrepeat for each line l in tHeightsList\n-- clip the field to the bottom of the last visible line\nset the height of field body text to l\n-- print the field rectangle\n-- you may want to add an output \"into\" rectangle\n\nprint this card from the topLeft of field \"body text\" to the bottomRight of field \"body text\"\n\n-- print a new page\nprint break\nend repeat\n-- send the job to the printer\nclose printing\n```\n\n> **Important:** Set the Lock Location (lockLoc) property of the field to true before setting the height in the loop above to avoid the field drifting each time you alter the height.\n\n> **Tip:** Turn off the scroll bar properties (hScrollbar and vScrollbar) of the field before printing and set the border width to 0 if you want to avoid printing a border or scroll bar.\n\nYou can incorporate scrolling fields into a template print layout stack (see the section *Printing a Complex Layout* above) to make it easier to manage printing a complex layout. Create a field in your template print stack instead of a graphic, turn off the scroll bar, set the border width to 0, the lock location to true and then the geometry properties as per the section above. At the start of each print job, copy the text font and size by using the `textFont`and textSize properties, then the contents of the text field you want to print using the `htmlText`property.\n\n### Working with Print Ranges\n\nUse the **printRanges** property to get a list of pages that the user has selected in the printer settings dialog. Use this property when printing to avoid printing pages the user has not selected. To use this property, open a system printer dialog, then store the `printRanges`in a variable. Then set the `printRanges`to \"all\", then send only the pages that were selected (stored in the variable) to the printer.\n\n> **Note:** If you ignore the printRanges property LiveCode will handle this setting automatically. Simply send every page to the printer as normal and LiveCode will ignore the pages the user has not selected in the print dialog. Handle this option manually only if you are printing an extremely complex layout and want to save processing time building the layout for every unselected page.\n\nUse the `printPageNumber`to get the number of the page currently being printed during your printing loop.\n\n## Printing a Browser Object\n\nTo print the contents of a browser object, use the **revBrowserPrint** command. For more information, see the **revBrowserPrint** command in the LiveCode Dictionary.\n\n# Deploying Your Application\n\nWith LiveCode, it is easy to deploy your application to anyone. With the revWeb plugin technology you can deploy to modern web browsers on Windows, Mac OS X and Linux. revWeb is quick, easy and free for users to install. Simply save your stack as a revlet to run in a browser. You can also deploy desktop revlets that run using the revWeb runtime.\n\nWith the standalone building capability in LiveCode you can create a native desktop application for each operating system you want to support. Users who do not have LiveCode can run these applications like any other application they download and install. Standalone applications can have their own identity as true applications, include a desktop icon, document associations and more.\n\n## Building a Standalone Application\n\nWhen you have finished your LiveCode application and what to distribute it you can build it into a standalone application. These applications do not require users to have LiveCode. All of LiveCode's feature set is available for use in a standalone application, with the exception that you cannot set scripts on objects.\n\nThe builder itself will let you build standalone applications for any platform it supports, from any platform it supports (for example you can build a Windows standalone on a Mac OS X machine). However, you may wish to check that your application looks and behaves correctly on each platform you intend to support. Please note it is inherently harder to debug an application that has been built as a standalone, so you should test your application as thoroughly as possible before building it.\n\n### Standalone Applications Settings\n\nThe Standalone Applications Setting dialog allows you to create settings for your standalone application. This dialog can be found in the File menu. The settings you enter are applied to the current front most editable stack and are saved with the stack. This means you only need to enter the settings once for each application you create. The same settings will apply if you do another build in the future.\n\n![](images/image104.png)\n\nFigure 71  Standalone Settings  General Tab\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Mode Selector**       | Choose between the different standalone application settings screens.                                                                                                                                                                                                                                               |\n| **Standalone Name**     | Set the name of your standalone application. This should be the name you want your finished application to have. Dont include a file extension (.exe on Windows or .app on Mac OS X) as the standalone builder can create standalones for multiple platforms and will add the appropriate extension automatically. |\n| **Inclusions Selector** | Choose the components you want to include in a standalone. You may either choose to search for required inclusions automatically, or manually select the components you want to include.                                                                                                                            |\n\n**Search for Inclusions**\n\nThis is the default option. When selected, LiveCode will search your application stack file (main stack and sub stacks) to attempt to determine what components your application uses. It will then include those items.\n\n**Select Inclusions for the Standalone Applications**\n\nSelect this option if you want to specify the components to include manually. You may wish to use this option if your application dynamically loads components that cannot be searched at this point automatically, or if you know exactly what components your application uses and wish to speed up the standalone building process by skipping the automatic search step.\n\nIt is important that you choose to include all the components that your application uses or it may fail. If you do not include your own custom error reporting or LiveCodes standalone error reporting dialog (discussed below) such failure may be silent  i.e. an operation in your standalone will simply cease working without displaying anything to the user.\n\n| &nbsp;| &nbsp;| &nbsp;|\n|----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Ask Dialog**       | This option is required if any of your scripts use the \"ask\" or \"ask password\" commands. The standalone builder will copy the stack \"ask dialog\" from the IDE into your standalone as a sub stack. The standalone builder makes a copy of your stack before adding resources to it as part of the build process, so your original stack is unaltered.                                                                                                                                                                                                                                           |\n| **Answer Dialog**    | This option is required if any of your scripts use the \"answer\" command. Note that this only applies to the dialog form of the command. The answer file / printer / color / effect / folder / page setup / printer and record forms of the command do *not* require this option. The standalone builder will copy the stack \"answer dialog\" into your standalone.                                                                                                                                                                                                                               |\n| **Cursors**          | This option is required if your application uses any of LiveCode's cursors. It is not required if your application only uses OS cursors. It copies the stack \"cursors\" into your standalone.                                                                                                                                                                                                                                                                                                                                                                                                    |\n| **Print Dialog**     | This option is required if your application uses LiveCode's built-in print or page setup dialogs (e.g. for use on Linux without GTK installed). It is not required if you only display the system printer and page setup dialogs. It copies the stack \"print dialog\" and \"page setup\" into your standalone.                                                                                                                                                                                                                                                                                     |\n| **Brushes**          | This option is required if your application uses any of LiveCode's brush cursors. It is not required if your application does not make use of the painting commands. It copies the stack \"brushes\" into your standalone.                                                                                                                                                                                                                                                                                                                                                                        |\n| **Script Libraries** | This option allows you to copy script libraries into your standalone.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n| |                        The list of available libraries is automatically updated to include any plug-in libraries or externals you may have installed into the LiveCode distribution. Thus the list you have may differ from what is documented here.                                                                                                                                                                                                                                                                                                                                                                    \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n| |                        When included in a standalone application, each script library is implemented as a hidden group and made available when the group receives its first `openBackground`message. During the first part of the application `startup` process before this message is sent, any commands that use a given library will not be available. This may affect attempts to use this a script library in `startup`, `preOpenStack`, openStack, or preOpenCard handers in the main stack. Once the application has finished starting up, the library is available and the script library can be used in any handler.  |\n| **Animation** \t\t  | This library is unsupported.                             \n| **Browser**   \t\t\t| Embedded browser and any `revBrowser`command.                              \n| **Database**        | Database access and any `revDatabase`command.                             \n|  **Font Support**   | `revFontLoad`and revFontUnload.                           \n|  **Geometry**       | Geometry properties or commands.                               \n|  **Internet**       | Internet access, including URL, ftp & POST                              \n|  **Printing**       | `revPrintField`, revShowPrintDialog and `revPrintText`                              \n|  **LiveCode Zip**   | All `revZip`commands (but not required for `compress`/de`compress`)                           \n|  **Speech**         | `revSpeak`and revSpeechVoices                              \n|  **SSL & Encryption** | Any SSL or encryption related commands                         \n|  **Table**           | Use of the table object                                \n| **Video Grabber**    | Any video capture commands                           \n| **XML**              | Any `revXML`commands                               \n|  **XMLRPC**          | Any `revXMLRPC`commands                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n| **Database Support** | This option is required if you use SQL databases. Ensure you choose to include drivers for any database you need to access.                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n\n| &nbsp;| &nbsp;| &nbsp;|\n|----------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Profiles Settings**                        | Choose between the Property Profile settings options. You only need to alter settings in this area if you have used Property Profiles (see the section on *Property Profiles* in Chapter 4, Builder a User Interface above)                        |\n| **Remove all profiles**                      | Removes all profiles and builds the standalone using the currently active profile on each object. Select this option if you don't need to change profile in the standalone and want to save disk space by removing extraneous profile information. |\n| **Set all objects to profile**               | Set all objects to a specific profile then remove the profile data from objects.                                                                                                                                                                   |\n| **Include profiles and the profile library** | Include the profile library and allow switching between profiles in the standalone application. You can choose whether to include specific profiles or all profiles.                                                                               |\n\n![](images/image105.png)\n\nFigure 72  Standalone Settings  Stacks Tab\n\n| &nbsp;| &nbsp;| &nbsp;|\n|------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Stack Files**                          | Use this section to add additional stack files to your application. Any stacks you add to this section will be added to the `stackFiles`property of the main stack of your standalone. This means that any scripts within your standalone application will be able to locate and reference these stacks by name. |\n| **Advanced Options**                     | Use this section to control exactly how multiple stack files are managed in your standalone.                                                                                                                                                                                                                    |\n| **Move substacks into individual files** | If you select this option, each of the sub stacks in the stack files you select will be moved into their own individual file, located in the data folder or within the application bundle of your standalone.                                                                                                   |\n| **Rename stackfiles generically**        | Renames each sub stack file using a number on disk (instead of using the name of the sub stack). Select this option if you do not want the names you have selected for stacks to be visible to the end user in the filing system.                                                                               |\n| **Create folder for stackfiles**         | Creates a folder and places the stack files into that folder, instead of storing them at the same level as the standalone executable. All references in the `stackFiles`property will refer to this folder using a relative path so the stacks can still be located by the standalone application.               |\n| **Individual stack options**             | Select a stack file on the left then an individual stack from within the file to set options on that stack.                                                                                                                                                                                                     |\n| **Set destroyStack to true**             | Set this option if you want the selected stack file to be removed from memory when it is closed. This option is useful if you are loading large stacks into memory and want them to be removed when they are closed.                                                                                            |\n| **Encrypt with password**                | Secures the scripts within the selected stack file with a password. This provides a basic level of encryption that prevents someone from casually reading the scripts in the stack by opening the file in a binary file viewer.                                                                                 |\n\n> **Note:** A stack file directly attached to a standalone application cannot have changes saved to it. This stack is bound directly to the executable file that runs. The OS locks an executable file while it is running. If you want to save changes in your standalone application, split your stack up until multiple files. A common technique is to create a \"splash screen\" stack that contains a welcome screen and then loads the stacks that make up the rest of your application. These stacks are referenced as `stackFiles`on this pane in the standalone settings screen. It is thus possible to automatically update these component stacks, or to save changes to them. You may also want to consider creating preference files in the appropriate location on your end user's system (see the `specialFolderPath`function and query/setRegistry functions for more information).\n\n![](images/image106.png)\n\nFigure 73  Standalone Settings  Copy Files\n\n| &nbsp;| &nbsp;| &nbsp;|\n|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Non-stack files in the application** | List other files to be included in the standalone. Use this feature to include help documents, read me files and other resources that you want to include with your standalone each time you build.                                                                    |\n| **Copy Referenced Files**              | Loops over all image and player objects in stacks and copies any files referenced in the `fileName`property of these objects into the standalone. Then automatically sets the `fileName`property to reference these files in the standalone using referenced file paths. |\n| **Destination folder**                 | Create a subfolder within your standalone to copy the image and movie files to.                                                                                                                                                                                        |\n\nFigure 74  Standalone Settings  Mac OS Classic\n\n![](images/image107.png)\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Build for Mac OS**              | Builds a standalone for the Mac OS Classic platform. Note that this build option uses the LiveCode 2.6.1 Classic engine. All of the settings on this pane relate only to the standalone built for Mac OS Classic. They do not affect the other platforms.    |\n| **Creator signature**             | Set the creator type for your application                                                                                                                                                                                                                    |\n| **Document type**                 | Set the document type for your application                                                                                                                                                                                                                   |\n| **Include resources from file**   | Copy resources from a specified resource file into the resource fork of your standalone                                                                                                                                                                      |\n| **Use dynamic memory allocation** | Use the dynamic memory allocator on Mac OS Classic                                                                                                                                                                                                           |\n| **Minimum / preferred size**      | Set the minimum and preferred size for your application. Ensure this is enough to load your application. If you have turned off dynamic memory allocated, ensure this is enough to load all the resources in your application and use the entire feature set |\n| **Version number**                | Set the version number, displayed in the Get Info window                                                                                                                                                                                                     |\n| **Long version string**           | Set the version information string, displayed in the Get Info window                                                                                                                                                                                         |\n| **Release**                       | Specify the release type                                                                                                                                                                                                                                     |\n| **Region**                        | Specify the region                                                                                                                                                                                                                                           |\n| **Non-release**                   | Specify the non-release version number                                                                                                                                                                                                                       |\n\n> **Important:** Because the build for Mac OS Classic option builds using the LiveCode 2.6.1 engine, you must make sure that your stack does not use any newer features that would cause the scripts not to compile. The standalone builder automatically saves the stack in legacy 2.6.1 format but does not check your scripts. You should check your stack with a version of the 2.6.1 IDE and use this facility to build for Classic on stacks that you know are compatible.\n\n![](images/image108.png)\n\nFigure 75  Standalone Settings  Mac OS X\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Mac OS X (Universal)**                                        | Build a standalone for Mac OS X in universal binary format. This standalone will run natively on both Intel and PowerPC machines.                                                                                                                                                                                                                                                                                             |\n| **Mac OS X (PowerPC Only)**                                     | Build a standalone that will run natively on Mac OS X PowerPC machines. This standalone will still run on Intel machines, but will load under Rosetta (emulation) so will run much slower. Choose this option if you want to keep the file size of your standalone down (e.g. to upload smaller PowerPC and Intel distributions for your users to choose from and download).                                                  |\n| **Mac OS X (Intel Only)**                                       | Build a standalone that will run natively on Mac OS X Intel machines. This standalone will not run at all under PowerPC.                                                                                                                                                                                                                                                                                                      |\n| **Application Icon**                                            | Choose an application icon to represent the application in the Finder. The icon should be in icns format.                                                                                                                                                                                                                                                                                                                     |\n| **Document Icon**                                               | Choose a document icon to represent your application's documents in the Finder. The icon should be in icns format.                                                                                                                                                                                                                                                                                                            |\n| **Icons for ask / answer dialogs**                              | Choose an icon to display whenever you use the ask or answer commands to display a dialog. On Mac OS X, the convention is that these dialogs should display your application icon. The icon should be stored in your stack as an image, or selected from LiveCode's built-in icons. If you have used a built-in icon, be sure to select the relevant inclusion on the General tab (if you are selecting inclusions manually). |\n| **PLIST  enter information and have LiveCode write the PLIST** | Have LiveCode fill out the PLIST for your application automatically. The PLIST is a settings file stored in XML format stored as part of every Mac OS X application. It contains information about the application, including its name, version number, copyright notice and document associations. Having LiveCode create this file for you is the recommended option. For more information about PLISTs see                 \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n| |                                                                   <http://developer.apple.com/documentation/>                                                                                                                                                                                                                                                                                                                                                                                    \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n| |                                                                   Darwin/Reference/ManPages/man5/plist.5.html                                                                                                                                                                                                                                                                                                                                                                                    |\n| **Choose a file to import into the application bundle**         | Choose to import a PLIST file instead of having LiveCode create one. Select this option if you have created your own highly customized PLIST that you want to use for your application in each build you create.                                                                                                                                                                                                              |\n| **Short version / long version**                                | The version information to be included with your standalone.                                                                                                                                                                                                                                                                                                                                                                  |\n| **Get info string**                                             | The visible text displayed in your application's Get Info window by the Finder.                                                                                                                                                                                                                                                                                                                                               |\n| **Copyright notice**                                            | The copyright notice for your application.                                                                                                                                                                                                                                                                                                                                                                                    |\n| **Bundle identifier**                                           | A unique identifier for your application used by Mac OS X to identify your application.                                                                                                                                                                                                                                                                                                                                       |\n\n![](images/image109.png)\n\nFigure 76  Standalone Settings  Windows\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Build for Windows**   | Build a standalone for the Microsoft Windows OS.                                                                                                                                                                                                                                 |\n| **Application icon**    | Choose an application icon to represent the application in Windows. The icon should be in .ico format.                                                                                                                                                                           |\n| **Document icon**       | Choose a document icon to represent your application's documents in Windows. The icon should be in .ico format.                                                                                                                                                                  |\n| **Version information** | The version information to be stored as part of your application and displayed in the Windows property inspector and dialogs.                                                                                                                                                    |\n| **Make U3 Compatible**  | Build your application for the U3 smart platform. For more information on U3 see <http://www.u3.com>. For more documentation on building U3 applications using LiveCode, see the Resources/Examples/U3 Documentation.pdf file included within your LiveCode distribution folder. |\n\n![](images/image110.png)\n\nFigure 77  Standalone Settings  Unix\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Build for Linux**   | Build a standalone for Linux                                                                                                                                                                                                                                 |\n| **Build for Solaris** | Build a standalone for Solaris                                                                                                                                                                                                                               |\n| **Include**           | Select built-in LiveCode dialogs to include. These dialogs are useful if your application may be run on a system that does not include these dialogs as part of the OS. You do not need to include these dialogs if you are running a recent version of GTK. |\n\n![](images/image111.png)\n\nFigure 78  Standalone Settings  Bug Reports\n\n| &nbsp;| &nbsp;| &nbsp;|\n|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Include Error Reporting Dialog**    | Include an error reporting stack in your standalone. You should select this option if you are testing your application and want details of any errors in your standalone, or if you have not included your own error reporting routines in your stacks.                                                                                                                                    |\n| **htmlText for dialog**               | The text to display to the user in the dialog that comes up when an error is encountered. This text should be in LiveCode-compatible HTML format. Create and format the text in a LiveCode field then copy the field's HTMLText property.                                                                                                                                                  |\n| **Dialog icon**                       | The icon to display in the error dialog. This should be stored as an image in your stack.                                                                                                                                                                                                                                                                                                  |\n| **Allow user to enter comments**      | Display a box for the user to give you more information. This information will be included in the report.                                                                                                                                                                                                                                                                                  |\n| **Allow user to save report to file** | Allow the user to save the report to a file. Select this option if you want users to save an error report and send it to you.                                                                                                                                                                                                                                                              |\n| **Allow user to email report**        | Allow the user to email the report. Select this option if you want the user to be able to send you or your technical support department details of the error. This option loads up the system default email client and populates the email with the contents of the error report and the user's comments. The To: field is sent to the email address specified in the email address field. |\n\n## Distributing On the Web\n\nTo distribute for the web, check the Web option in the Standalone Settings dialog. This will allow you to create a revlet, which can be viewed in in popular browsers using the free, lightweight revWeb plugin. The latest version of the plugin will always be available at <http://revweb.runrev.com/> and you can direct users there to download it. Note that building for the web is the only option in revMedia.\n\n![](images/image112.png)\n\nFigure 79  Standalone Settings  Web\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **UUID**                | A unique ID for your revlet. This is generated automatically and shouldnt be changed.                                                                                                                                                                                                                                                                                      |\n| **Security**            | Allows you to specify the security permissions that your revlet requires. The revWeb Plug-in will request these permissions from the user before your revlet is loaded onto the page. Note that if your stack requires permissions that have not been granted, those features will not work. Auto-detect attempts to detect the required settings from the scripts you use. \n| |                                                                                                                                                                                                                                                                                                                                                                                                        \n| |                           Network: Allows access to sockets and URLs outside the domain the revlet resides on.                                                                                                                                                                                                                                                                                         \n| |                                                                                                                                                                                                                                                                                                                                                                                                        \n| |                           Disk: Allows access to the users local disk. All file access commands require this permission.                                                                                                                                                                                                                                                                              \n| |                                                                                                                                                                                                                                                                                                                                                                                                        \n| |                           Registry (Read): Allows reading the registry on Windows using queryRegistry.                                                                                                                                                                                                                                                                                                 \n| |                                                                                                                                                                                                                                                                                                                                                                                                        \n| |                           Registry (Write): Allows writing to the registry on Windows using setRegistry.                                                                                                                                                                                                                                                                                               \n| |                                                                                                                                                                                                                                                                                                                                                                                                        \n| |                           Privacy: Allows access to the video camera, microphone and screen capture.                                                                                                                                                                                                                                                                                                   \n| |                                                                                                                                                                                                                                                                                                                                                                                                        \n| |                           Process / Shell: Allows access to the command line and the ability to launch and communicate with other processes.                                                                                                                                                                                                                                                           \n| |                                                                                                                                                                                                                                                                                                                                                                                                        \n| |                           Printing: Allows access to the printer and printer settings.                                                                                                                                                                                                                                                                                                                 |\n| **Platforms supported** | The platforms the revlet supports.                                                                                                                                                                                                                                                                                                                                          |\n| **Custom load icon**    | Allows you to specify your own custom logo for use on the loading screen.                                                                                                                                                                                                                                                                                                   |\n| **Background**          | Sets the top and bottom colors to create a gradient color for the loading screen. (Use the same colors for both to create a solid color.)                                                                                                                                                                                                                                   |\n\n# Error Handling & Debugging\n\nIn an ideal world everyone would write perfect code and there would never be any need to debug. However in reality, virtually every project is going to require some degree of debugging. The more complex the project the more like this is to be true. Fortunately LiveCode includes a full plethora of debugging tools and techniques that make it quick and easy to track down errors. The live run-edit cycle allows you to see the effect of corrections as soon as you make them. And, unlike working in a lower-level language, when you make a mistake you will receive a human-friendly error message pointing you to where the error occurred, instead of the application unexpectedly quitting.\n\nAs well as the set of built-in error reporting and debugging tools, LiveCode also allows you complete flexibility over error handling, allowing you to provide a customized experience to the end user of your application.\n\n## Common Techniques for Solving Problems\n\nIf you encounter a problem with your code, there are a number of methods available to help you track it down. In this section we detail some of the main techniques you may find useful.\n\n### The LiveCode Error Dialog\n\nOften the first thing that will alert you to a problem is an error dialog.\n\n![](images/image113.png)\n\nFigure 80  An Error Dialog\n\nThere are two possible types of error dialog. The first is the *Execution Error* dialog. This dialog is displayed when your script is running and encounters an error.\n\nIn the example above, the script was attempting to access field 100. This field does not exist. When LiveCode encounters a problem like this, execution will *halt* and the dialog above will be displayed.\n\nIf you know what the error is from looking at it, use the *Script* button to go directly to the script and edit it. The line that generated the error will be highlighted in the script window.\n\nAlternatively, if you need more information the *Debug* button will load the script in the debugger at the line the error occurred (see below for more information on using the Debugger). You can then load the Variable Watcher (see below) to see the state of all the variables at the point where execution was halted.\n\n> **Note:** The Debug button will only appear if Script Debug Mode is checked in the Development menu.\n\n**Errors During Compiling**\n\nA *Script Error* dialog is displayed when your script cannot be compiled because of a syntax error. This dialog is typically displayed when you attempt to compile a change to a script by pressing the Apply button in the Code Editor. Pressing the Script button will select the line that caused the error. Correct the error then press the Apply button to compile the script again.\n\n> **Caution:** If a compile error is generated then the entire script to which it applies will not be compiled, not just the line or handler that contains the error. If other scripts are attempting to call commands or functions in this script they will not be able to run until you correct the problem and compile the script again.\n\nBecause LiveCode compiles all the scripts within a stack when it loads them, a Script Error dialog can also be generated when you load a stack from disk for the first time  if you saved a stack that contained a script that could not compile.\n\n> **Important:** Do not confuse the *Execution Error* and *Script Error* dialogs. The *Execution Error* dialog occurs when a script is running and cannot continue due to an error. The error dialog will start with the words \"executing at [time]\". The *Script Error* dialog appears when you attempt to compile a script that contains a syntax error. The error dialog will start with the words \"compiling at [time]\". The *Script Error* dialog will never contain a *Debug* button because the script that generated the error is not running.\n\n> **Tip:** If you turn on the Variable Checking option in the Code Editor, LiveCode will require that you declare all variables and enclose all literal strings in quotes. It will report a script compile error if you attempt to use an unquoted literal or do not declare a variable. This can be useful in catching mistakes before you run a script. Note that if you turn this option on and attempt to compile an existing script that has not been written in this way, it will typically generate a large number of errors that need to be corrected before you can compile it.\n\n### Suppressing Errors and Messages\n\nIf your stack gets into an unstable state where it is generating a large number of errors, you may want to temporarily turn off sending messages to the stack or displaying error messages. This can enable you to edit the stack to make the appropriate changes.\n\nTo suppress messages, press the Messages button on the toolbar or choose Suppress Messages from the Development menu. Normal system event messages will stop being sent to the stack (for example clicking a button will no longer trigger a mouseUp handler, changing card will no longer trigger an openCard handler). You can still send custom messages directly to objects within the stack.\n\nTo suppress errors, press the Errors button on the toolbar or choose Suppress Errors from the Development menu. This will prevent any errors from triggering an error display window.\n\n> **Caution:** Be sure to turn messages and errors back on when you have finished editing. Otherwise your stack will not work, or any error that comes up during stack operation will cause execution to halt but will not display an error message.\n\nYou can execute a single navigation command in the message box with a similar effect as Suppress Messages by including the statement `lock messages;` before it. for example, to go to the next card `lock messages;` go next or to exit LiveCode (without displaying triggering any close messages or asking to save changes `lock messages;` quit\n\n### Outputting information as your script executes\n\nIf you want to know about the state of a particular variable or condition during execution, you can use the *Variable Watcher*, detailed below. However sometimes you may want to run a script without opening the debugger, outputting information along the way. You can use the **put** command to output information to the Message Box, a field or a text file, the **write** command to output to the Console, or the **answer** command to display a dialog.\n\n**Output to the Message Box**\n\nThe Message Box is a convenient way to output information while a script is running. It allows you to display the information you want within the IDE without having to create a field or stack to display the information. Using a put command without specifying a destination outputs to the Message Box:\n\n```\nput tVar\n```\n\nIn the example above, substitute tVar with the name of the variable in your script that you want to see the contents of. You can also output information only if a certain condition is met:\n\n```\nif tVar is true then put tData\n```\n\nWhenever you display something in the message box, a special global variable called **message** (often abbreviated to **msg**) is updated. This allows you to check the contents of the message box easily, as well as add or append information rather than replacing it.\n\n```\n-- puts tInformation and a return after the data\n-- already in the message box\nput tInformation & return after msg\n```\n\nFor more information, see the section on the *Message Box*, above.\n\n**Output to Standard Out (stdOut or the Console on Mac OS X)**\n\nThe stdOut is a useful place to log messages. Unlike the Message Box, it is easy to log a sequence of events which you can then scroll back to review later on. It also has the advantage of being external to LiveCode so using it does not interfere with your application window layering or focus in any way. The stdOut is only available on Linux, Unix or Mac OS X systems. On Mac OS X, it can be accessed by opening the Console application, located in the Utilities folder within Applications.\n\nThe syntax to write something to stdOut or the Console is:\n\n```\nwrite tMessage & return to stdout\n```\n\n> **Tip:** If you are writing a lot of data out to the console, it can be useful to append the time to each one to make it easier to debug. `write tMessage && the long time & return to stdOut`. If you need more granualarity than seconds, use the milliseconds instead of the long time.\n\nIf you are inserting debugging output statements into your code, consider making them conditional on a global variable. This allows you to turn on debugging by setting the variable without making changes to code. Even better it prevents forgotten debugging code in your application inadvertently filling the console with messages on an end user's system.\n\n```\nif gDebugging then write tMessage & return to stdOut\n```\n\n**Output to a field**\n\nYou can create a stack that contains fields used for debugging:\n\n```\nput tVar & return after field \"debugging info\" of stack \"my debug stack\"\n```\n\n> **Tip:** You may want to create a set of tools that makes it easy to debug a specific application you are working on. Create this stack then save it into your plug-ins folder so it is available from the Development menu in the IDE.\n\n**Output to a dialog**\n\nTo display a dialog with the contents of a statement, use the answer command. This method is suitable if you want to output something quickly, but is usually unsuitable for larger debugging tasks as it pauses execution to display a dialog each time\n\n```\nif tVar is true then answer tVar\n```\n\n**Output to a text file**\n\nIf you want to log information more permanently, you can use a text file. You may want to store the file path in a global variable so you can change it easily. See the section on using file URLs, below for more information.\n\n```\nput tVar & return after URL \"file:debug.txt\"\n```\n\n### Interrupting Execution\n\nIf you need to interrupt a script while it is running, press control-period (or command-period on Mac OS). Note that interrupting a script will only work if the global **allowInterrupts** property is set to true.\n\n> **Tip:** On Mac OS X systems, if your application has got into an unstable state and you are unable to interrupt it with command-period you may be able to interrupt it and regain control by sending it a signal. Open the Terminal utility and then use *top -o cpu* or *ps ax* to retrieve the process ID for LiveCode. Then run *kill -sighup [processID]* where [processID] is the ID of the LiveCode process.\n\n## The Debugger\n\nTypically when you want to track down a problem with your script, you will want to use the debugger. The debugger provides a simple interface that allows you to step through your script line by line as it executes. You can see the results of each statement as it happens. If you load the Variable Watcher from within the debugger, it will show you the contents of all of the variables used in a particular handler. These values will be updated as you step through. You can even edit these values while your script is running. This can be useful if you spot a problem in a given area or want to test a section of code with a different set of data as it runs.\n\nTo activate the debugger, first ensure that Script Debug Mode is turned on in the Development menu. Then open up the script you want to debug and click in the gray bar to the left of the line where you want to open the debugger. Alternatively you can write the command **breakPoint** into the script. Using the **breakPoint** command allows you to break conditionally  `if tVar is true then breakPoint`.\n\nNext run your script as normal. When LiveCode reaches a breakpoint it will pause execution and load up the debugger.\n\n> **Important:** To see the contents of variables while your script is running, wait for the debugger to open then choose *Variable Watcher* from the *Debug* menu. For more information on using the *Variable Watcher*, see below.\n\n![](images/image114.png)\n\nFigure 81  The Debugger\n\nFor a table describing each of the buttons in the debugger together with their keyboard shortcuts, see the section on The Debug Menu in chapter 3.\n\nPress the Step Into button to execute the current line and move to the next line. Step Over performs the same action, except that if the current line calls a function it will run that entire function without opening it in the debugger.\n\nOnce you have found the cause of the problem, press the Run button to exit the debugger and run the script at full speed. Alternatively press the Abort button to halt execution on the current line and edit the script.\n\n> **Tip:** To improve the performance when debugging a complex script, set a breakpoint further down in the script during the debugging process and press the Run button instead of pressing Step Over. The debugger is temporarily deactivated until the new breakpoint is reached, which means the script runs at full speed. When using Step Over, the debugger is still active even though it does not display a routine as it runs, which is slower.\n\n## The Variable Watcher\n\n![](images/image115.png)\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Context menu**            | Choose the execution context to display. This will show all the available contexts that are currently executing. For example, if you have a button that has called a function and you are currently paused within that function, the variables displayed will be for that function. But you can go back and look at the variables in the handler that called the function by choosing it from this menu. |\n| **Conditional breakpoints** | Attach a conditional breakpoint to a variable. In the example above, if you want a breakpoint to be triggered when tVar contains 2, click on the breakpoint area to the left of tVar and type tVar = 2 into the dialog. Press the Run button in the debugger. Execution will halt if tVar becomes equal to 2.                                                                                            |\n| **List of variables**       | This lists all the variables in the current execution context. The contents of each variable is listed in the area on the right. If the contents is truncated, click on a variable to have the full contents displayed in the edit area at the bottom. The display area is updated each time you step to the next line while debugging.                                                                  |\n| **Edit area**               | Display and the contents of the currently selected variable. To change the content, simply enter a new value.                                                                                                                                                                                                                                                                                            |\n| **Edit script**             | Go to the Code Editor or debugger window for the current execution context.                                                                                                                                                                                                                                                                                                                              |\n\n## Custom Error handling\n\nIf you are creating an application that is going to be distributed, you may want to include a method for catching and handling errors. LiveCode provides two such methods. The first is the **try**/**catch** control structure. This control structure can be inserted around any routine that you know may encounter problems when in use. For example, you may wish to include this around a routine that reads in a file from disk to handle the case where a corrupted file has been selected. The second method is to write a custom **errorDialog** routine. Unlike a **try**/**catch** control structure, an **errorDialog** handler is global to your application (or card or stack within an application) and does not provide a mechanism to allow a script that encounters an error to continue. Use this method to display a custom error dialog when an error occurs that you are unable to predict and report using try/catch.\n\n**Using try/catch**\n\nEnclose code that may be error prone within a **try** control structure. The following example shows a routine that opens and reads from a file enclosed in a try statement. If an execution error occurs in any of the statements after the start of the try control structure, the catch clause will be triggered with the details of the error. In the example below we declare a variable `someError`to contain details of the error.\n\n```\ntry\n\topen file tFile\n\tread from file tFile until eof\n\tclose file\ncatch someError\n\tanswer \"An error occurred reading a file\" && someError\nend try\n```\n\n> **Tip:** The data returned to the error routine is returned in the internal format that LiveCode uses to display execution errors. To look up the human friendly string associated with a particular error, look at the first item returned against the list of execution errors stored in the LiveCode IDE.\n`put line (item 1 of someError) of the cErrorsList of \\`\\\n `card 1 of stack \"revErrorDisplay\"`\nThis will only work in the IDE.\n\nIf you want to include statements that will be run regardless of whether there has been an error or not, include the statements as part of a **finally** clause.\n\nTo create readable error messages for cases where you anticipate there may be an error, use the **throw** keyword. For example, if we want to display an error message when the result for opening a file returns something:\n\n```\nopen file tFile\nif the result is not empty then throw the result\n```\n\nIn the example above, if the file cannot be opened and the result is set, the value of the result will be passed to the catch statement in the `someError`variable.\n\n**Writing a custom errorDialog routine**\n\nWhen an execution error occurs, an **errorDialog** message is sent. The IDE uses this message to display the execution error dialog. However you can write and include your own custom **errorDialog** routine. This is useful if you are planning to distribute your application. For example, you could create a stack that transmits the error information directly to your technical support department or displays a custom message on screen. A basic **errorDialog** routine is shown below:\n\n```\non errorDialog pError\nanswer \"There was an error\" && pError\nend errorDialog\n```\n\nThis routine will also be activated if you use the throw keyword to throw an error (outside of a **try**/**catch** control structure).\n\n## The Message Watcher\n\nThe Message Watcher lets you see what messages are sent during a particular operation. it can be useful if you want to create a log of the sequences of messages generated during a particular operation. It also logs how long each message takes to run. This makes it useful when you are looking for bottlenecks in your code. The Message Watcher is located in the Development menu.\n\n![](images/image116.png)\n\nFigure 82  The Message Watcher Window\n\n| &nbsp;| &nbsp;| &nbsp;|\n|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Message list area** | Lists messages as they happen. The format is *the name* of the message, *the time* the message was sent and the number of *milliseconds* since the last message. Click to select a message, double click to open it in the Code Editor.                                                                                                                                                                                                                                                                  \n| |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n| |                         In the example above we can see that the user was inactive for 4.7 seconds before moving the mouse over an object that triggered a *mouseEnter* message. 599 milliseconds later they clicked the mouse triggering a *mouseUp* message. The *mouseUp* handler called *calculateResult* 0 milliseconds later, then *formatData* was called 147 milliseconds later. Because there were no user-generated messages in the sequence, we know that the *calculateResult* handler took 147 milliseconds to run.  |\n| **Object field**      | Shows the object that the message was sent to. Click on a line in the Message List to update this field.                                                                                                                                                                                                                                                                                                                                                                                                 |\n| **Message type**      | Shows the type for the selected message  *command*, *function*, *getProp* or *setProp*                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| **Active**            | Check this box to activate the Message Watcher. Deactivate the Message Watcher when you have captured information about the sequence of events you are interested in and want to stop the logging of additional messages.                                                                                                                                                                                                                                                                                |\n| **Clear**             | Clears the message list field.                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| **Suppress**          | Allows you to set what messages you want displayed and which ones you want to suppress. Use this option to narrow down the messages that are logged so you can see information about the sequence you are interested in. See below for more information.                                                                                                                                                                                                                                                 |\n\n![](images/image117.png)\n\nFigure 83  Suppress Messages Option Screen\n\n| &nbsp;| &nbsp;| &nbsp;|\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **Action  Handled**     | Don't log any message that causes a handler to run when it is sent.                                                                                                                                                        |\n| **Action  Not Handled** | Don't log any message that does not cause a handler to run when it is sent. This is the default option and prevents the log from filling up with messages that do not cause any scripts to run.                            |\n| **IDE Messages**         | Do not log LiveCode IDE messages. The LiveCode IDE generates lots of messages as it is written in LiveCode. This is the default option but you may wish to display these messages if you are customizing the LiveCode IDE. |\n| **Handler Type**         | Do not log the selected type of handler. For example, to prevent displaying all function calls, check the function box.                                                                                                    |\n| **Message list**         | A list of messages not to log. By default *mouseMove* is listed as otherwise *mouseMove* messages may flood the display whenever you move the mouse.                                                                       |\n| **Add**                  | Add a message name to prevent it from being logged.                                                                                                                                                                        |\n| **Delete**               | Delete a message name to cause it to be logged in the future.                                                                                                                                                              |\n\n## Tracking Down Problems in Standalone Applications\n\nWe recommend that you debug your application as fully as possible in the IDE, so that you can use the Debugger and other tools. However occasionally you may need to track down a problem that only occurs in a standalone application. If this happens, use the techniques described above for writing information out to the stdOut or a text file. You can also include an error display dialog using the *Bug Reports* tab within the Standalone Settings screen. Be sure to check either the *Allow user to save report to file* or *Allow user to email report* buttons so that you can view the error generated. For more information, see the chapter on *Distributing your Application*.\n\n# Transferring Information with Files, the Internet and Sockets\n\nReading and writing data to files or transferring data over the Internet are important functions in most applications. LiveCode provides a rich feature set for performing these operations.\n\nAccessing data from a file typically takes just a single line of code. LiveCode's file path syntax uses the same format on each platform so you typically don't have to rewrite your file handling routines to deploy cross platform. A set of functions provides for copying, deleting or renaming files, as well as accessing appropriate system and user folders.\n\nLiveCode includes functions for downloading and uploading data to the Internet. Simple downloads and uploads can be performed with just a single line of code. Support for the http, ftp and post protocols is included. Syntax is included that allows downloading in both the foreground and background. Additional library commands allow you to construct multipart form data, send ftp commands and more.\n\nLiveCode includes built-in support for https, SSL & encryption.\n\nIf the built-in protocol support doesn't do what you need, LiveCode also allows you to implement your own Internet protocols using its straightforward socket support. A very basic client server application can be written in a few lines of code.\n\n## File Name Specifications and File Paths\n\nA file path is a way of describing the location of a file or folder so that it can be found by a handler. File paths are used throughout LiveCode: when you read to and write from text files, when you reference an external QuickTime file to display in a player, and in many other situations. If your application refers to external files in any way, an understanding of file path is essential.\n\nThis topic discusses the syntax for creating and reading a file reference, and how to relate file paths to the location of your application so that they'll be accessible when your application is installed on another system with a different folder structure.\n\n### What is a File Path?\n\nA file path is a description of the exact location of a file or folder. The file path is created by starting at the top of the computer's file system, naming the disk or volume that the file is on, then naming every folder that encloses the file, in descending order, until the file is reached.\n\n**Locating a file**\n\nFor example, suppose you want to describe the location of a file called \"My File\", which is located inside a folder called \"My Folder\". That folder is in turn located inside a folder called \"Top Folder\", which is on a drive called \"Hard Disk\". You need all this information to completely describe where the file is:\n- Hard Disk\n- Top Folder\n- My Folder\n- My File\n\nIf someone tells you which disk the file is on, then which folder to open, and so on, you can find the file by opening each successive icon on your computer's desktop. By starting with the disk, then opening each enclosing folder in succession until you arrive at the file, you can find exactly the file that's being described.\n\n**The structure of a file path**\n\nA file path specifies each level of the hierarchy that encloses the file. LiveCode presents the information in a file path that might look like this:\n\n```\n/Hard Disk/Top Folder/My Folder/My File\n```\n\nYou can see that to write a file path, you start by naming the disk the file is on, then add each enclosing folder in order until you arrive at the file.\n\nTo see the path to a file, enter the following in the message box:\n```\nanswer file \"Choose a file:\"; put it\n```\n\nThis displays the file path for the file you choose.\n\n> **Important:** Each platform has its own way for programmers to specify file paths. The file path shown above is in the usual style for file paths on Unix systems. For cross-platform compatibility, LiveCode uses this same forward slash / character in its file path regardless of the current platform. This way, you can generally specify file and work with paths in your scripts without having to convert them when you switch platforms.\n\n**File paths on Windows systems**\n\nOn Windows systems, disks are named with a drive letter followed by a colon character (:). A typical LiveCode file path on a Windows system looks like this:\n\n```\nC:/folder/file.txt\n```\n\n**File paths on OS X systems**\n\nOn OS X systems, the startup disk, rather than the desktop, is used as the top level of the folder structure. This means that the startup disk's name does not appear in file paths. Instead, the first part of the file path is the top-level folder that the file is in.\n\nIf the disk \"Hard Disk\" is the startup disk, a typical path on OS X systems might look like this:\n\n```\n/Top Folder/My Folder/My File\n```\n\nNotice that the disk name isn't part of this path.\n\n> **Note:** If you need to find out the startup disk's name, check the first disk name returned by the **volumes** function.\n\nFor files on a disk that isn't the startup disk, the file path starts with \"/Volumes\" instead of \"/\". A typical file path to a file that's on a non-startup disk on an OS X system looks like this:\n\n```\n/Volumes/Swap Disk/Folder/file.txt\n```\n\n**Folder paths**\n\nYou construct the path of a folder the same way as the path to a file. A folder path always ends with a slash character (/). This final slash indicates that the path is to a folder rather than a file.\n\nFor example, this pathname describes a folder called \"Project\" inside a folder called \"Forbin\" on a disk named \"Doomsday\":\n\n/Doomsday/Forbin/Project/\n\nIf \"Project\" is a file, its pathname looks like this, without the final slash:\n\n/Doomsday/Forbin/Project\n\n**File paths for OS X bundles**\n\nA bundle is a special type of folder, used on OS X, that is presented to the user as a single file but that is maintained internally by the operating system as a folder. Many OS X applications  including LiveCode and the applications it creates  are stored and distributed as bundles that contain several files. When the user double-clicks the bundle the application starts up instead of a folder window opening to show the bundle's contents.\n\nYou can take advantage of the bundle concept to include any needed support files with your application. If you place the files in the application's bundle, users ordinarily never see them, and the entire application--support files and all--behaves as a single icon.\n\n> **Tip:** To see the contents of a bundle, right-click (or control click) the bundle and choose \"Show Package Contents\" from the contextual menu.\n\nMost of the time, the distinction between bundles and files doesn't matter. However we recommend that you treat them as files when working from the perspective of a user but otherwise refer to them as folders when coding. This will help to keep your code readable. Thus if you are selecting a bundle in a file dialog use the answer file form. When moving or renaming a bundle, refer to them as a folder.\n\n**Moving, renaming, or deleting a bundle**\n\nWhen using the **rename** command, to rename a bundle, use the rename folder form of the command:\n\n```\nrename folder \"/Volumes/Disk/Applications/MyApp/\" to \"/Volumes/Disk/Applications/OtherApp/\"\n```\n\nSimilarly, when dealing with a bundle, use the **delete folder** command instead of **delete file**, and the **revCopyFolder** command instead of **revCopyFile**.\n\n**Referring to files inside a bundle**\n\nWhen referring to a file that's inside a bundle, you can treat the bundle just as if it were a folder. For example, if you have placed a file called \"My Support.txt\" inside your application's bundle, the absolute path to the file might look like this:\n\n```\n/Volumes/Disk/Applications/MyApp/My Support.txt\n```\n\n**The / character in a file or folder name**\n\nThe slash (/) is not a legal character in Unix or Windows file or folder names, but it is legal for Mac OS file or folder names to contain a slash. Since a slash in a file or folder name would cause ambiguity  is the slash part of a name, or does it separate one level of the hierarchy from the next?  LiveCode substitutes a colon (:) for any slashes in folder or file names on Mac OS systems.\n\nFor example, if a file on a Mac OS system is named \"Notes from 12/21/93\", you refer to it in a script as \"Notes from 12:21:93\". Since the colon is not a legal character in Mac OS folder or file names, this removes the ambiguity.\n\n### Absolute and Relative File Paths\n\nWhen describing how to get to a file, you have two options. You can start from the top level, the name of the disk, and name each of the enclosing folders until you get to the file. This is called an absolute path, because it's independent of where you start from. Or you can start from the current folder and describe how to get to the file from there. This is called a relative path, because it depends on where you start.\n\nAll the file paths shown so far in this topic are absolute paths.\n\n**Absolute file paths**\n\nAbsolute file paths do not depend on which folder your stack file is in or on where the current folder is. An absolute path to a particular folder or file is always written the same way.\n\nFor example, suppose your application is in a folder called \"Application Folder\", and you want to specify a file called \"Westwind\" which is in a folder called \"Stories\" inside \"Application Folder\".\n- Hard Disk\n- Top Folder\n- My Folder\n- My File\n- Application Folder\n- My Application\n- Stories\n- Westwind\n\nThe absolute file path of your application looks like this:\n\n/Hard Disk/Application Folder/My Application\n\nand the absolute path of the \"Westwind\" file looks like this:\n\n```\n/Hard Disk/Application Folder/Stories/Westwind\n```\n\n> **Note:** On Mac OS, OS X, and Unix systems, absolute file paths always start with a slash character. On Windows systems, absolute file paths always start with a drive letter followed by a colon (:).\n\n**Relative file paths **\n\nNow suppose you want to tell someone how to get to the \"Westwind\" file, starting from the folder containing the application.\n\nSince the application is in \"Application Folder\", we don't need to include the steps to get to \"Application Folder\". Instead, we can describe the location of the \"Westwind\" file with this relative pathname:\n\nStories/Westwind\n\nThis relative pathname starts at \"Application Folder\"--the folder that holds the application--and describes how to get to the \"Westwind\" file from there: you open the folder \"Stories\", then find \"Westwind\" inside it.\n\nA relative file path starts at a particular folder, rather than at the top of the file system like an absolute file path. The relative file path builds a file path from the starting folder to the file or folder whose location is being specified.\n\n**Finding the current folder**\n\nBy default, the current folder is set to the folder containing the application (either the LiveCode development environment or your application, depending on whether your application is a standalone). So in the example above, the current folder is \"Application Folder\", because that's where the running application is located.\n\n> **Note:** To change the current folder, set the **defaultFolder** property.\n\n**Going up to the parent folder**\n\nThe relative path \"..\" indicates the current folder's parent folder. If the current folder is \"Stories\", the relative path\n\n..\n\nmeans the same thing as the absolute path\n\n/Hard Disk/Application Folder/\n\n**Going up multiple levels**\n\nTo go up more than one level, use more than one \"../\". To go up two levels, use \"../../\"; to go up three levels, use \"../../../\", and so forth.\n\nFor example, suppose the current folder is \"Stories\", and its absolute path looks like this:\n\n```\n/Hard Disk/Application Folder/Stories/\n```\n\nTo get to \"My Application\" in \"Application Folder\", you go up one level to \"Application Folder\", then down one level to \"My Application\". The relative path looks like this:\n\n```\n../My Application\n```\n\nTo get to \"Top Folder\" on \"Hard Disk\", you go up two levels--to \"Application Folder\", then to \"Hard Disk\"--and then down one level to \"Top Folder\". The relative path looks like this:\n\n```\n../../Top Folder/\n```\n\n**Starting at the home directory**\n\nOn OS X and Unix systems, the \"~\" character designates a user's home directory.\n\nA path that starts with \"~/\" is a relative path starting with the current user's home directory. A path that starts with \"~\", followed by the user ID of a user on that system, is a relative path starting with that user's home directory.\n\n### When to use relative and absolute file paths\n\nAbsolute file paths and relative file paths are interchangeable. Which one to use depends on a couple of factors.\n\nAbsolute file paths are easy to understand and they don't change depending on the current folder. This can be an advantage if you are changing the defaultFolder regularly.\n\nHowever absolute file paths always include the full name of the hard disk and folders leading up to the current working folder. Therefore, if you plan to distribute your application you will want to work with relative paths, so that media shipped in subfolders with your application is still easy to locate.\n\n> **Tip:** By default, when linking to an image or resource using the Inspector, LiveCode inserts an absolute file path. If you plan to distribute your application, locate your media in a subfolder next to the stack you are working on and convert these file paths to relative file paths by deleting the directories up to the one you are working in. This will mean you don't need to make any changes when it comes time to distribute your application.\n\nIt's OK to use absolute paths to specify files or folders that the user selects after installation. For example, if you ask the user to select a file (using the **answer file** command) and read data from the file, there's no need to convert the absolute path that the **answer file** command provides to a relative path. Because you're using the path right after you get it from the **answer** command, you know that the disk name and folder structure aren't going to change between getting the path and using it.\n\n## Special Folders\n\nModern operating systems each have a set of special-purpose folders designated for a variety of purposes. If you are writing an application it is recommended that you make use of these folders where appropriate so that you provide the best possible user experience. For example, the contents of the desktop reside in a special folder; there is a folder set aside for fonts; there is a folder for application preferences; and so on.\n\nThese special folders don't always have the same name and location, so you can't rely on a stored file path to locate them. For example, if your application is installed onto an OS localized into a different language, the names of the file path will be different, on some Windows special folders are named or placed differently depending on what version of Windows is running, etc.\n\nTo find out the name and location of a special folder, regardless of any of these factors, you use the **specialFolderPath** function. The function supports a number of forms for each operating system, describing the special folders for each one. Some of the forms are the same cross-platform. The following example will get the location of the Desktop folder on Windows, Mac OS X or Linux:\n\n```\nput specialFolderPath(\"Desktop\") into myPath\n```\n\nTo get the path to the Start menu's folder on a Windows system:\n\n```\nput specialFolderPath(\"Start\") into myPath\n```\n\nFor a complete list of possible folders see the, **specialFolderPath** in the *LiveCode Dictionary*.<span id=\"_Toc1176438\" class=\"anchor\"></span>\n\n## File Types, Application Signatures & File Ownership\n\nWhen you double-click a document file, it automatically opens in the application it's associated with. Each operating system has a different method for associating files with an application. In order to create files that belong to your standalone application, you need to set up the association appropriately for each platform you distribute on.\n\nThis topic describes how to correctly associate your application with the files it creates.\n\n### Windows File Extensions and Ownership\n\nWhen a file is saved on a Windows system, a three-character extension is usually added to the file's name. The extension specifies the format of the file.\n\nTo determine which application to launch when the user double-clicks a file, Windows checks the Windows registry to find out what application has registered itself as owning the file's extension. Each application can add keys to the registry to identify certain file extensions as belonging to it.\n\n**Applications that don't own files**\n\nIf your application does not create files that you want the application to own, you don't need to make any modifications to the registry or specify any extensions.\n\n**Applications that own their own files**\n\nIf your application creates files with its own custom extension, when you install the application, you should make changes to the Windows registry to identify the extension as belonging to your application.\n\nPopular Windows installer programs will make these registry changes automatically for you. You can also perform these registry changes using the **setRegistry** function.\n\n**Installing custom icons**\n\nEach Windows file can display its own icon. You can have separate icons for your application and for files it owns. Icon files must be stored in .ico format.\n\n**Custom application icons**\n\nIf you want to include a custom icon for your application, use the \"Application Icon\" option on the Windows screen of the Standalone Application Settings window to specify the icon file. When you build the application, the icon will be included in the application. For more information, see the chapter on *Deploying Your Application*.\n\n**Custom file icons**\n\nTo include a custom icon for your documents, use the \"Document Icon\" option on the Windows screen of the Standalone Application Settings window to specify the icon file. When you build the application, the icon will be included in the application.\n\n> **Important:** For the correct icon to appear on files your application creates, the file's extension must be registered in the Windows registry.\n\n**File extensions**\n\nYou can add an extension to the name of any Windows file. The extension may contain letters A-Z, digits 0-9, ' (single quote), !, @, \\#, $, %, ^, &, (, ), -, \\_, {, }, \\`, or ~.\n\nThe Windows registry associates applications with the extension for the files they own.\n\n### OS X File Types and Creators\n\nOn OS X each file has a file extension which determines which application owns it. However OS X systems can also use the unique four-character creator signature and a four-character file type used on Mac OS Classic (see below for more information).\n\nOS X applications store file association information in a property list file, or plist. Each application's plist is stored as part of its application bundle.\n\n**Applications that don't own files**\n\nTo assign your unique creator signature when building an application, enter the signature on the OS X screen of the Standalone Application Settings window. LiveCode automatically includes the creator signature in the application's plist.\n\n**Applications that own their own files**\n\nIf your application creates files with your application's creator signature, you should include in your application's plist an entry for each file type you use. Once you have built your standalone application, follow these steps to open the plist file:\n\n**1.** Right click on your application bundle, navigate to the contents folder and open the \"Info.plist\" file. If you have installed Apple's developer tools, you have an application called \"Property List Editor\", which you can use to make changes to the plist file. Otherwise, you can edit the file in a text editor.\n\n**2.** Locate the information for the document type. In Property List Editor, expand the \"Root\" node, then expand the \"CFBundleDocumentTypes\" node, then expand the \"0\" node. In a text editor, locate \"CFBundleDocumentTypes\". Below it, note the tags \"\\<array\\>\" and \"\\<dict\\>\". The information for the first document type is between \"\\<dict\\>\" and \"\\</dict\\>\".\n\n**3**. Enter the file description, which is a short phrase describing what kind of file this is. In Property List Editor, change the value of \"CFBundleTypeName\" to the description you want to use. In a text editor, locate \"CFBundleTypeName\" in the document information. Below it is the file description, enclosed between \"\\<string\\>\" and \"\\</string\\>\":\n\n\\<string\\>LiveCode Stack\\</string\\>\n\nChange the description to the one you want to use.\n\nDo not change the tags (enclosed in \"\\<\" and \"\\>\"). Only change what's between them.\n\n**4.** Enter the `file`extension. In Property List Editor, expand \"CFBundleTypeExtensions\" and enter the `file`extension in the \"0\" node. In a text editor, locate \"CFBundleTypeExtensions\" in the document information. Below it is the extension, enclosed in \"\\<array\\>\" and \"\\<string\\>\" tags. Change the extension to the one you want to use.\n\n**5.** Enter the four-character file type. In Property List Editor, expand \"CFBundleTypeOSTypes\" and enter the file type in the \"0\" node. In a text editor, locate \"CFBundleTypeOSTypes\" in the document information. Below it is the file type, enclosed in \"\\<array\\>\" and \"\\<string\\>\" tags. Change the file type to the one you want to use.\n\nIf the format for this type of file is standard (such as plain text), use a standard type (such as \"TEXT\"). If the format belongs to your application, use a custom file type of your choice.\n\n> **Important:** Apple reserves all file types with no uppercase letters. If you use a custom file type for your application, make sure it contains at least one uppercase letter.\n\nIf you want to assign more file types to your application, copy the portion of the plist file inside the \"CFBundleTypes\" array between \"\\<dict\\>\" and \"\\</dict\\>\", including these tags. The \"CFBundleTypes\" node should now contain two \"\\<dict\\>\" nodes and all their contents. Repeat the steps above for each different file type your application can create.\n\n**Creating Files**\n\nWhen your application creates files, set the **fileType** property to the desired creator signature and file type for the new file. (For stack files created with the **save** command, use the **stackFileType** property instead.) When creating files, the application uses the current value of the **fileType** or **stackFileType** property to determine what creator and file type the new file should have.\n\nIt's important to understand that a file's creator signature determines which application is launched automatically when you double-click the file, but doesn't prevent other applications from being able to open that file. For example, if your application creates files of type \"TEXT\", any text editor can open the files. If your application creates stack files, and uses the file type \"RSTK\", then LiveCode will be able to open the stack files, as well as your application.\n\n**File extensions**\n\nYou can add an extension to the name of any OS X file. When the user double-clicks a file with no creator signature, the operating system uses the extension to determine which application to use to open the file.\n\nAn application bundle's name should end with the extension \".app\".\n\n> **Note:** Apple's recommendations for determining file type and creator on OS X systems are currently in flux. The recommended method for the present is to set a file type and creator signature, and also attach an extension to the end of each file's name when it is created. Valid extensions on OS X systems are up to twelve characters in length, and may include the letters a-z, the digits 0-9, $, %, \\_, or ~. For up-to-date information on Apple's recommendations for OS X, see Apple's developer documentation at \\<*http://www.apple.com/developer/*\\>.\n\n### Mac OS Classic File Types and Creators\n\nWhen a file is saved on a Mac OS system, a four-character creator signature is saved with it. The creator signature specifies which application owns the file. Every Mac OS and OS X application should have a unique creator signature. (Apple maintains a registry of creator signatures on its web site at \\<*http://developer.apple.com/dev/cftype/*\\>.)\n\nMac OS files have a separate file type, also four characters long, which specifies the format of the file. The file type is also used to determine which applications (other than the owner) can work with the file. The file type of all applications is \"APPL\".\n\n**Applications that don't own files**\n\nTo assign your unique creator signature when building an application, enter the signature on the Mac OS screen of the Standalone Application Settings window. LiveCode automatically includes the resources needed for Mac OS to recognize the creator signature.\n\n**Applications that own their own files**\n\nIf your application creates files with your application's creator signature, you should include in your application a set of resources for each file type you use. Once you have saved your standalone application, open the application file in ResEdit and follow these steps:\n\n**1.** Open the BNDL resource window, then open the BNDL 128 resource. The BNDL 128 resource contains a single entry (\"APPL\").\n\n**2.** Choose \"Create New File Type\" from the Resources menu. A new entry appears below the \"APPL\" entry.\n\n**3.** In the Type field, enter the four-character file type. If the format for this type of file is standard (such as plain text), use a standard type (such as \"TEXT\"). If the format belongs to your application, use a custom file type of your choice.\n\nRepeat steps 2-3 for each different file type your application can create.\n\nWhen your application creates files, set the **fileType** property to the desired creator signature and file type for the new file. For stack files created with the save command, use the **stackFileType** property instead. When creating files, the application uses the current value of the **fileType** or **stackFileType** property to determine what creator and file type the new file should have.\n\n**Installing custom icons**\n\nEach Mac OS `file`may display any of six different icons, depending on context and on the number of colors the screen can display: large (32x32 pixel) icons and small (16x16 pixel) icons, each in black-and-white, 16 colors, and 256 colors.\n\nMac OS provides default icons that are used for applications and documents that don't have their own. If you want your application or the documents it owns to display a custom icon, you must create the icons and then attach them to the application.\n\n**Custom application icons**\n\nIf you want to include a custom icon for your application, use ResEdit or a similar tool to create a set of icon resources. There are six standard icon resource types: ICN\\# (black-and-white), icl4 (four-bit color), icl8 (8-bit color), ics\\# (black-and-white small), ics4 (4-bit small), and ics8 (8-bit small). Each of these application icons should have the resource ID 128.\n\nSave the icons in a single file, and use the \"Include resources from file\" option on the Mac OS screen of the Standalone Application Settings window to specify the file. When you build the application, the icons will be included in the application's file.\n\n### Unix File Extensions\n\nUnix systems do not have an overall required method for specifying a file's type, but most files on a Unix system are created with extensions in the file name, similar to the extensions used on Windows systems. These extensions may be of any length and may include any characters (other than /).\n\n## <span id=\"_Toc1176439\" class=\"anchor\"><span id=\"_Toc150933321\" class=\"anchor\"></span></span>Working with URLs\n\nA URL is a container for a file (or other resource), which may either be on the same system the application is running on, or on another system that's accessible via the Internet.\n\nThis topic discusses the various URL schemes that LiveCode implements, how to create and manipulate files using URLs, and how to transfer data between your system and an FTP or HTTP server.\n\nTo fully understand this topic, you should know how to create objects and write short scripts, and understand how to use variables to hold data. You should also have a basic understanding of how the Internet works.\n\n### An Overview of URLs\n\nIn the LiveCode language, a URL is a container for a `file`or other document, such as the output of a CGI on a web server. The data in a URL may be on the same system the application is running on, or may be on another system.\n\nURLs in LiveCode are written like the URLs you see in a browser. You use the **URL** keyword to designate a URL, enclosing the URL's name in double quotes:\n\n```\nput field \"Info\" into URL \"file:myfile.txt\"\nget URL \"http://www.example.org/stuff/nonsense.html\"\nput URL \"ftp://ftp.example.net/myfile\" into field \"Data\"\n```\n\n### URL Schemes\n\nA URL scheme is a type of URL. LiveCode supports five URL schemes with the **URL** keyword: **http**, **ftp**, **file**, **binfile**, and (for backwards compatibility on Mac OS Classic and OS X) **resfile**.\n\nThe **http** and **ftp** schemes designate documents or directories that are located on another system that's accessible via the Internet. The **file**, **binfile**, and **resfile** schemes designate local files.\n\n### The http scheme\n\nAn **http** URL designates a document from a web server:\n\n```\nput URL \"http://www.example.org/home.htm\" into field \"Page\"\n```\n\nWhen you use an `http`URL in an expression, LiveCode downloads the URL from the server and substitutes the downloaded data for the URL.\n\nWhen you put something into an `http`URL, LiveCode uploads the data to the web server:\n\n```\nput field \"Info\" into URL \"http://www.example.net/info.htm\"\n```\n\n> **Note:** > **Note:** Because most web servers do not allow `http`uploads, putting something into an `http`URL usually will not be successful. Check with the server's administrator to find out whether you can use the `http`protocol to upload files.\n\nFor more details about `http`URLs, see the entry for the `http`keyword in the LiveCode Dictionary.\n\n### The ftp scheme\n\nAn **ftp** URL designates a file or directory on an FTP server:\n\n```\nget URL \"ftp://user:passwd@ftp.example.net/picture.jpg\"\n```\n\nWhen you use an `ftp`URL in an expression, LiveCode downloads the URL from the server and substitutes the downloaded data for the URL.\nWhen you put something into an ftp URL, LiveCode uploads the data to the ftp server:\n\n```\nput image 10 into URL \"ftp://user:passwd@ftp.example.net/picture.jpg\"\n```\n\nFTP servers require a user name and password, which you can specify in the URL. If you don't specify a user name and password, LiveCode adds the \"anonymous\" user name and a dummy password automatically, in accordance with the convention for public FTP servers.\n\n> **Note:** Uploading to an FTP server usually requires a registered user name and password.\n\nFor more details about `ftp`URLs, see the entry for the `ftp`keyword in the LiveCode Dictionary.\n\n**Directories on an FTP server**\n\nA URL that ends with a slash (/) designates a directory (rather than a file). An `ftp`URL to a directory evaluates to a listing of the directory's contents.\n\n### The file scheme\n\nA **file** URL designates a file on your system:\n\n```\nput field \"Stuff\" into URL \"file:/Disk/Folder/testfile\"\n```\n\nWhen you use a `file`URL in an expression, LiveCode gets the contents of the `file`you designate and substitutes it for the URL. The following example puts the contents of a `file`into a variable:\n\n```\nput URL \"file:myfile.txt\" into myVariable\n```\n\nWhen you put data into a `file`URL, LiveCode puts the data into the file:\n\n```\nput myVariable into URL \"file:/Volumes/Backup/data\"\n```\n\n> **Note:** As with local variables, if the file doesn't exist, putting data into it creates the file.\n\nTo create a URL from a file path that LiveCode provides, use the **&** operator:\n\n```\nanswer file \"Please choose a file to get:\"\nget URL (\"file:\" & it)\n```\n\n**File path syntax and the file scheme:**\n\nThe `file`URL scheme uses the same `file`path syntax used elsewhere in LiveCode statements. You can use both absolute paths and relative paths in a `file`URL.\n\n**Conversion of end-of-line markers**\n\nDifferent operating systems use different characters to mark the end of a line. Mac OS X uses a return character (ASCII 13), Unix systems use a linefeed character (ASCII 10), and Windows systems use a return followed by a linefeed. To avoid problems when transporting a stack between platforms, LiveCode always uses linefeeds internally when you use a `file`URL as a container. LiveCode translates as needed between the your system's end-of-line marker and LiveCode's linefeed character. To avoid this translation, use the bin`file`scheme (see below).\n\n### The binfile scheme\n\nA **binfile** URL designates a file on your system that contains binary data:\n\n```\nput URL \"binfile:beachball.gif\" into image \"Beachball\"\n```\n\nWhen you use a **binfile** URL in an expression, LiveCode gets the contents of the file you designate and substitutes it for the URL. The following example puts the contents of a file into a variable:\n\n```\nput URL \"binfile:picture.png\" into pictVar\n```\n\nWhen you put data into a **binfile** URL, LiveCode puts the data into the file:\n\n```\nput pictVar into URL \"binfile:/Volumes/Backup/pict.png\"\nput image 1 into \"binfile:/image.png\"\n```\n\nAs with local variables, if the file doesn't exist, putting data into it creates the file.\n\nThe **binfile** scheme works like the file scheme, except that LiveCode does not attempt to convert end-of-line markers. This is because return and linefeed characters can be present in a binary file but not be intended to mark the end of the line. Changing these characters can corrupt a binary file, so the **binfile** scheme leaves them alone.\n\n### The resfile scheme\n\nOn Mac OS Classic (and sometimes on OS X systems), files can consist of either a data fork or a resource fork or both.\n\n> **Important:** While LiveCode supports reading and writing resource fork files on Mac OS X and Mac OS Classic, this feature is only intended to help you access and work with legacy files. We do not generally recommend the use of resource forks when designing any new application.\n\nThe resource fork contains defined resources such as icons, menu definitions, dialog boxes, fonts, and so forth. A **resfile** URL designates the resource fork of a Mac OS or OS X file:\n\n```\nput myBinaryData into URL \"resfile:/Disk/Resources\"\n```\n\nWhen you use a **resfile** URL in an expression, LiveCode gets the resource fork of the file you designate and substitutes it for the URL.\n\nWhen you put data into a **resfile** URL, LiveCode puts the data into the file's resource fork.\n\n> **Note:** A **resfile** URL specifies the entire resource fork, not just one resource. To work with individual resources, use the **getResource**, **setResource**, **deleteResource** and **copyResource** functions.\n\nThe most common use for this URL scheme is to copy an entire resource fork from one file to another. To modify the data from a **resfile** URL, you need to understand the details of Apple's resource fork format.\n\n**Creating a resource fork**\n\nUnlike the **file** and **binfile** URL schemes, the **resfile** keyword cannot be used to create a file. If the file doesn't yet exist, you cannot use the **resfile** keyword to create it. To create a new resource file, first use a **file** URL to create the file with an empty data fork, then write the needed data to its resource fork:\n\n```\nput empty into URL \"file:myFile\" -- creates an empty file\nput myStoredResources into URL \"resfile:myFile\"\n```\n\n### Manipulating URL contents\n\nYou use a URL like any other container. You can get the content of a URL or use its content in any expression. You can also put any data into a URL.\n\n**http**, **ftp**, **binfile**, and **resfile** URLs can hold binary data.\n\n**http**, **ftp**, and **file** URLs can hold text.\n\n**The URL keyword**\n\nTo specify a URL container, you use the **URL** keyword before the URL, which can use any of the five schemes described above:\n\n```\nif URL \"http://www.example.net/index.html\" is not empty...\nget URL \"binfile:/Applications/Hover.app/data\"\nput 1+1 into URL \"file:output.txt\"\n```\n\nThe `URL`keyword tells LiveCode that you are using the `URL`as a container.\n\nSome properties (such as the **filename** of a player or image) let you specify a URL as the property's value. Be careful not to include the **URL** keyword when specifying such properties, because using the URLkeyword indicates that you're treating the URL as a container. If you use the URL keyword when specifying such a property, the property is set to the contents of the URL, not the URL itself, and this is usually not what's wanted.\n\n**Using the content of a URL**\n\nAs with other containers, you use the content of a URL by using a reference to the URL in an expression. LiveCode substitutes the URL's content for the reference.\n\nIf the URL scheme refers to a local file (**file**, **binfile**, or **resfile** URLs), LiveCode reads the content of the file and substitutes it for the URL reference in the expression:\n\n```\nanswer URL \"file:../My File\" -- displays the file's content\nput URL \"binfile:flowers.jpg\" into myVariable\nput URL \"resfile:Icons\" into URL \"resfile:New Icons\"\n```\n\nIf the URL scheme refers to a document on another system (**http** or **ftp** URLs), LiveCode downloads the URL automatically, substituting the downloaded data for the URL reference:\n\n```\nanswer URL \"http://www.example.net/files/greeting.txt\"\n```\n\n> **Note:** If the server sends back an error message--for example, if the file you specify in an **http** URL doesn't exist--then the error message replaces the URL reference in the expression.\n\n> **Important:** When you use an **ftp** or **http** URL in an expression, the handler pauses until LiveCode is finished downloading the URL. If you do not want to block LiveCode when accessing these resources, use the **load URL** form of the command (see below).\n\n**Putting data into a URL**\n\nAs with other containers, you can put data into a URL. The result of doing so depends on whether the URL scheme specifies a file on your system (**file**, **binfile**, or **resfile**) or on another system (**http** or **ftp**).\n\nIf the URL scheme refers to a local file (**file**, **binfile**, or **resfile** URLs), LiveCode puts the data into the specified file:\n\n```\nput field \"My Text\" into URL \"file:storedtext.txt\"\nput image 1 into URL \"binfile:picture.png\"\n```\n\nIf the URL scheme refers to a document on the Internet (**http** or **ftp** URLs), LiveCode uploads the data to the URL:\n\n```\nput myVar into URL \"ftp://me:pass@ftp.example.net/file.dat\"\n```\n\nBecause most web servers do not allow HTTP uploads, this usually will not be successful with the **http** scheme.\n\n**Chunk expressions and URLs**\n\nLike other containers, URLs can be used with chunk expressions to specify a portion of what's in a URL--a line, an item, a word, or a character. In this way, any chunk of a URL is like a container itself. For more information about Chunk Expressions, see the chapter on *Processing Text and Data*.\n\nYou can use any chunk of a URL in an expression, in the same way you use a whole URL:\n\n```\nget line 2 of URL \"http://www.example.net/index.html\"\nput word 8 of URL \"file:/Disk/Folder/myfile\" into field 4\nif char 1 of URL \"ftp://ftp.example.org/test.jpg\" is \"0\"...\n```\n\nYou can also specify ranges, and even one chunk inside another:\n\n```\nput char 1 to 30 of URL \"binfile:/marks.dat\" into myVar\nanswer line 1 to 3 of URL \"http://www.example.com/file\"\n```\n\n**Putting data into a chunk**\n\nIf the URL is local (that is, if it is a **file**, **binfile**, or **resfile** URL), you can put a value into a chunk of the URL:\n\n```\nput it into char 7 of URL \"binfile:/picture.gif\"\nput return after word 25 of URL \"file:../datafile\"\nput field 3 into line 20 of URL \"file:myfile.txt\"\n```\n\nYou can also put a value into a chunk of an **ftp** or **http** URL. Because it's impossible to upload part of a file, LiveCode downloads the file, makes the change, then uploads the file back to the server.\n\n> **Tip:** This method is inefficient if you need to make several changes. In this case, it's faster to first put the URL in a variable, replace the chunk you want to change, then put the variable into the URL:\n\n```\nput URL \"ftp://me:secret@ftp.example.net/file.txt\" into myVar\nput field \"New Info\" after line 7 of myVar\nput field \"More\" into word 22 of line 3 of myVar\n```\n\n```\nput myVar into URL \"ftp://me:secret@ftp.example.net/file.txt\"\n```\n\nThis ensures that the file only needs to be downloaded once and re-uploaded once, no matter how many changes you need to make.\n\n### **URLs and memory**\n\nURLs, unlike other containers, are only read into memory when you use the URL in a statement. Other containers  like variables, fields, buttons, and images  are normally kept in memory, so accessing them doesn't increase memory usage.\n\nThis means that in order to read a URL or place a value in a chunk of a URL, LiveCode reads the entire file into memory. Because of this, you should be cautious when using a URL to refer to any very large file.\n\nEven when referring to a single chunk in a URL, LiveCode must place the entire URL in memory. An expression such as `line 347882 of URL \"file:bigfile.txt\"` may be evaluated very slowly or even not work at all, if insufficient memory is available. If you refer to a chunk of an `ftp`or http URL, LiveCode must download the entire file to find the chunk you specify.\n\nIf you need to read and write large quantities of data to a file, or seek through the contents of a large file without loading the entire contents into memory, use the **open file**, **read from file**, **seek** and **close file** commands instead of the URL commands. For more information on these commands see the *LiveCode Dictionary*.\n\n### **Deleting URLs**\n\nYou remove a URL with the **delete URL** command.\n\nTo delete a local file, you use a **file** or **binfile** URL:\n\n```\ndelete URL \"file:C:/My Programs/test.exe\"\ndelete URL \"binfile:../mytext.txt\"\n```\n\nIt doesn't matter whether the file contains binary data or text; for deletion, these URL schemes are equivalent.\n\n> **Tip:** You can also use the **delete file** command to remove a file.\n\nTo delete the resource fork of a file, you use a **resfile** URL. The following example removes the resource fork along with all resources, but leaves the file in place:\n\n```\ndelete URL \"resfile:/Volumes/Backup/proj.rev\"\n```\n\n> **Tip:** To delete a single resource instead of the entire resource fork, use the **deleteResource** function.\n\nTo remove a file or directory from an FTP server, you use an **ftp** URL:\n\n```\ndelete URL \"ftp://root:secret@ftp.example.org/deleteme.txt\"\ndelete URL \"ftp://me:mine@ftp.example.net/trash/\"\n```\n\nAs with creating files, you can use an **http** URL to delete a file, but most HTTP servers are not configured to allow this.\n\n## Uploading and Downloading Files\n\nThe simplest way to transfer data to an FTP or HTTP server is to use the **put** command to upload, or use the URL in an expression to download.\n\nThe Internet library includes additional commands to upload and download files to and from an FTP server. These commands offer more versatile options for monitoring and controlling the progress of the file transfer.\n\n**Uploading using the put command**\n\nAs mentioned above, putting something into an **ftp** or **http** URL uploads the data to the server:\n\n```\nput myVariable into URL \"ftp://user:pass@ftp.example.org/newfile.txt\"\n```\n\nIf you use the **put** command with a **file** or **binfile** URL as the source, the file is uploaded:\n\n```\nput URL \"file:newfile.txt\" into URL \"ftp://user:pass@ftp.example.org/newfile.txt\"\n```\n\nWhen you upload data in this way, the operation is blocking: that is, the handler pauses until the upload is finished. (See below for details on how to create a file transfer that is not blocking.) If there is an error, the error is placed in the **result** function:\n\n```\nput field \"Data\" into URL myFTPDestination\nif the result is not empty then beep 2\n```\n\n> **Important:** Uploading or downloading a URL does not prevent other messages from being sent during the file transfer: the current handler is blocked, but other handlers are not. For example, the user might click a button that uploads or downloads another URL while the first URL is still being uploaded. In this case, the second file transfer is not performed and the **result** is set to \"Error Previous request has not completed.\" To avoid this problem, you can set a flag while a URL is being uploaded, and check that flag when trying to upload or download URLs to make sure that there is not already a file transfer in progress.\n\n**Downloading using a URL**\n\nReferring to an **ftp** or **http** URL in an expression downloads the document.\n\n```\nput URL \"ftp://ftp.example.net/myfile.jpg\" into image 1\nget URL \"http://www.example.com/newstuff/newfile.html\"\n```\n\nIf you use the **put** command with a **file** or **binfile** URL as the destination, the document is downloaded to the file:\n\n```\nput URL \"ftp://ftp.example.net/myfile.jpg\" into URL \"binfile:/Disk/Folder/myfile.jpg\"\n```\n\n### Non-blocking transfers\n\nWhen you transfer a file using URL containers, the file transfer stops the current handler until the transfer is done. This kind of operation is called a blocking operation, since it blocks the current handler as long as it's going on.\n\nIf you want to transfer data using *http* without blocking, use the **load** command. if you want to transfer large files using *ftp*, use the **libURLftpUpload**, **libURLftpUploadFile**, or **libURLDownloadToFile** commands.\n\nNon-blocking file transfers have several advantages:\n\nSince contacting a server may take some time due to network lag, the pause involved in a blocking operation may be long enough to be noticeable to the user.\n\nIf a blocking operation involving a URL is going on, no other blocking operation can start until the previous one is finished. If a non-blocking file transfer is going on, however, you can start other non-blocking file transfers. This means that if you use the library commands, the user can begin multiple file transfers without errors.\n\nDuring a non-blocking file transfer, you can check and display the status of the transfer. This lets you display the transfer's progress and allow the user to cancel the file transfer.\n\n**Using the load command**\n\nThe **load** command downloads the specified document in the background and places it in a cache. Once a document has been cached, it can be accessed nearly instantaneously when you use its URL, because LiveCode uses the cached copy in memory instead of downloading the URL again.\n\nTo use a file that has been downloaded by the load command, refer to it using the URL keyword as usual. When you request the original URL, LiveCode uses the cached file automatically.\n\nFor best performance, use the `load`command at a time when response speed isn't critical (such as when your application is starting up), and only use it for documents that must be displayed quickly, such as images from the web that will be shown when you go to the next card.\n\n**Checking status when using the load command**\n\nWhile a file is being transferred using the load commands, you can check the status of the transfer using the **URLStatus** function. This function returns the current status of a URL that's being downloaded or uploaded:\n\n```\nput the URLStatus of \"ftp://ftp.example.com/myfile.txt\" into field \"Current Status\"\n```\nThe **URLStatus** function returns one of the following values:\n\n*queued* - on hold until a previous request to the same site is completed\n\n*contacted* - the site has been contacted but no data has been sent or received yet\n\n*requested* - the URL has been requested\n\n*loading* *bytesTotal*, *bytesReceived* - the URL data is being received\n\n*uploading* *bytesTotal, bytesReceived* - the file is being uploaded to the URL\n\n*cached* - the URL is in the cache and the download is complete\n\n*uploaded* - the application has finished uploading the file to the URL\n\n*error* - an error occurred and the URL was not transferred\n\n*timeout* - the application timed out when attempting to transfer the URL\n\nTo monitor the progress of a file transfer or display a progress bar, you check the **URLStatus** function repeatedly during the transfer. The easiest way to do this is with timer based messaging  see the section of the same name in the chapter *Coding in LiveCode*, for more information.\n\n**Canceling a file transfer & emptying the cache**\n\nTo cancel a transfer initiated with the load command and empty the cache, use the **unload** command.\n\nunload URL \"http://example.org/new\\_beta\"\n\n**Uploading and downloading large files using FTP**\n\nThe Internet library provides a number of commands for transferring larger files via FTP without blocking.\n\n**libURLftpUpload** uploads data to an FTP server\n\n**libURLftpUploadFile** uploads a file to an FTP server\n\n**libURLDownloadToFile** downloads a file from an FTP server to a local file\n\nThe basic effect of these commands is the same as the effect of using URLs: that is, the data is transferred to or from the server. However, there are several differences in how the actual file transfer is handled. Because of these differences, the library commands are more suitable for uploads and downloads, particularly if the file being transferred is large.\n\nThe following sets of statements each show one of the Internet library commands, with the equivalent use of a URL:\n\n```\nlibURLftpUpload myVar,\"ftp://me:pass@example.net/file.txt\"\nput myVar into URL \"ftp://me:pass@example.net/file.txt\"\n```\n\n```\nlibURLftpUploadFile \"test.data\",\"ftp://ftp.example.org/test\"\n```\n\n```\nput URL \"binfile:test.data\" into URL \"ftp://ftp.example.org/test\n```\n\n```\nlibURLDownloadToFile \"ftp://example.org/new\\_beta\",\"/HD/File\"\nput URL \"ftp://example.org/new\\_beta\" into URL \"binfile:/HD/File\"\n```\n\n**Using callback messages**\n\nWhen you start a file transfer using the **libURLftpUpload**, **libURLftpUploadFile**, or **libURLDownloadToFile** command, you can optionally specify a callback message, which is usually a custom message that you write a handler for. This message is sent whenever the file transfer's **URLStatus** changes, so you can handle the callback message to handle errors or to display the file transfer's status to the user.\n\nThe following simple example demonstrates how to display a status message to the user. The following handlers might be found in a button's script:\n\n```\non mouseUp\n\tlibURLDownloadToFile \"ftp://example.org/new_beta\",\"/HD/Latest Beta\",\"showStatus\"\nend mouseUp\n\non showStatus theURL\n\tput the URLStatus of theURL into field \"Status\"\nend showStatus\n```\n\nWhen you click the button, the **mouseUp** handler is executed. The **libURLDownloadToFile** command begins the file transfer, and its last parameter specifies that a *showStatus* message will be sent to the button whenever the **URLStatus** changes.\n\nAs the **URLStatus** changes periodically throughout the download process, the button's *showStatus* handler is executed repeatedly. Each time a *showStatus* message is sent, the handler places the new status in a field. The user can check this field at any time during the file transfer to see whether the download has started, how much of the file has been transferred, and whether there has been an error.\n\nIf a file transfer was started using the **libURLftpUpload**, **libURLftpUploadFile**, or **libURLDownloadToFile** command, you can cancel the transfer using the **unload** command.\n\n**Uploading, downloading, and memory**\n\nWhen you use a URL as a container, LiveCode places the entire URL in memory. For example, if you download a file from an FTP server using the **put** command, LiveCode downloads the whole contents of the file into memory before putting it into the destination container. If the file is too large to fit into available memory, a file transfer using this method will fail (and may cause other unexpected results).\n\nThe library commands **libURLftpUpload**, **libURLftpUploadFile**, and **libURLDownloadToFile**, however, do not require the entire file to be loaded into memory. Instead, they transfer the file one piece at a time. If a file is (or might be) too large to comfortably fit into available memory, you should always use the library commands to transfer it.\n\n### Using a stack on a server\n\nOrdinarily, you use stack files that are located on a local disk. You can also open and use a stack that is located on an FTP or HTTP server. Using this capability, you can update an application by downloading new stacks, make new functionality available via `the`Internet, and even keep most of your application on a server instead of storing it locally.\n\nGoing to a stack on a server:\n\nAs with local stack files, you use the **go** command to open a stack that's stored on a server:\n\n```\ngo stack URL \"http://www.example.org/myapp/main.rev\"\ngo stack URL \"ftp://user:pass@example.net/secret.rev\"\n```\n\n> **Note:** For such a statement to work, the stack file must have been uploaded as binary data, uncompressed, and not use encodings such as BinHex.\n\n> **Tip:** If you need to download a large stack, use the **load** command to complete the download before using the **go** command to display the stack. This allows you to display a progress bar during the download.\n\nLiveCode automatically downloads the stack file. The main stack of the stack file then opens in a window, just as though you had used the **go** command to open a local stack file.\n\nYou can go directly to a specific card in the stack:\n\n```\ngo card \"My Card\" of stack URL \"http://www.example.org/myapp/main.rev\"\n```\n\nTo open a substack instead, use the substack's name:\n\n```\ngo stack \"My Substack\" of URL \"http://www.example.org/myapp/main.rev\"\n```\n\n**Using a compressed stack**\n\nYou cannot directly open a stack that's compressed. However, since the stack URL is a container, you can use the URL as the parameter for the **decompress** function. The function takes the stack file data and decompresses it, producing the data of the original stack file. You can open the output of the function directly as a stack.\n\nThe following statement opens a compressed stack file on a server:\n\n```\ngo decompress(stack URL \"http://www.example.net/comp.gz\")\n```\n\nThe statement automatically downloads the file \"comp.gz\", uncompresses it, and opens the main stack of the file.\n\n**Saving stacks from a server**\n\nWhen a stack is downloaded using the **go** command, it's loaded into memory, but not saved on a local disk. Such a stack behaves like a new (unsaved) stack until you use the **save** command to save it as a stack file.\n\n> **Note:** Saving a stack that has been downloaded with the **go** command does not re-upload it to its server. To upload a changed stack, you must save it to a local file, then use one of the methods described in this topic to upload the file to the server.\n\n## Other Internet Commands\n\nThe Internet library has a number of additional commands for working with web forms, ftp commands, custom settings and troubleshooting. These commands are documented in more detail the LiveCode Dictionary.\n\n**Launching the User's Browser with a URL**\n\nTo launch the default browser with a URL, use the **launch URL** command.\n\n```\nlaunch URL \"http://www.runrev.com/\"\n```\n\n> **Note:** To render web pages within LiveCode, instead of launching an external browser, use the revBrowser. See the section on revBrowser for more information.\n\n### Working with Web Forms\n\nTo post data to a web form, use the **post** command. To encode data to make it suitable for posting, use the **libUrlFormData** function. To create multi-part form data (as described in RFC 1867) use the **libUrlMultipartFormData** function. To add data to a multipart form one part at a time, use the **libUrlMultipartFormAddPart** function. This can be useful if you need to specify the mime type or transfer encoding for each part.\n\n### Working with FTP\n\nFor details on basic uploading and downloading using FTP, see the section above.\n\nThe following commands provide additional capabilities when working with the ftp protocol:\n\n**libURLSetFTPStopTime** - Sets the timeout value for FTP transfers.\n\n**libURLSetFTPMode** - Switches between active and passive mode for FTP transfers.\n\n**libURLSetFTPListCommand** - Switches between sending LIST or NLST formats when listing the contents of an FTP directory.\n\n**libURLftpCommand**  sends an ftp command to an ftp server.\n\n**libURLftpUpload**  uploads data. See the section above for more details.\n\n**libURLftpUploadFile**  uploads a file, without loading the entire file into memory. See the section above for more details.\n\n**libURLDownloadToFile**  downloads data to a file, without loading the entire data into memory. See the section above for more details.\n\n### HTTP methods and http URLs\n\nThe basic operations used by the HTTP protocol are called methods. For **http** URLs, the following HTTP methods are used under the following circumstances:\n\n\\* GET: when an **http** URL in an expression is evaluated\n\n\\* PUT: when you put a value into an **http** URL\n\n\\* POST: when you use the **post** command\n\n\\* DELETE: when you use the **delete URL** command with an **http** URL\n\n> **Note:** Many HTTP servers do not implement the PUT and DELETE methods, which means that you can't put values into an **http** URL or delete an **http** URL on such servers. It's common to use the FTP protocol instead to upload and delete files; check with your server's administrator to find out what methods are supported.\n\n**HTTP headers**\n\nWhen LiveCode issues a GET or POST request, it constructs a minimal set of HTTP headers. For example, when issued on a Mac OS system, the statement:\n\n```\nput URL \"http://www.example.org/myfile\" into myVariable\n```\n\nresults in sending a GET request to the server:\n\nGET /myfile HTTP/1.1\nHost: 127.0.0.0\nUser-Agent: LiveCode (MacOS)\n\nYou can add headers, or replace the Host or User-Agent header, by setting the **HTTPHeaders** property before using the URL:\n\n```\nset the HTTPHeaders to \"User-Agent: MyApp\" & return & \"Connection: close\"\nput URL \"http://www.example.org/myfile\" into myVariable\n```\n\nNow the request sent to the server looks like this:\n\nGET /myfile HTTP/1.1\nHost: 127.0.0.0\nUser-Agent: MyApp\nConnection: close\n\nThe **ftp** URL scheme can be used to create a new file to an FTP server. As with the **file** and **binfile** schemes, putting something into the URL creates the file:\n\n```\nput dataToUpload into URL \"ftp://jane:pass@ftp.example.com/newfile.dat\"\n```\n\n> **Tip:** You can create an FTP directory by uploading a file to the new (nonexistent) directory. The directory is automatically created. You can then delete the file, if you wish, leaving a new, empty directory on the server:\n\n```\n-- Create an empty file in the nonexistent directory:\nput empty into URL \"ftp://jane:pass@example.com/newdir/dummy\"\n-- Delete unwanted empty file to leave new directory:\ndelete URL \"ftp://jane:pass@example.com/newdir/dummy\"\n```\n\n### Additional Transmission Settings\n\nThe following commands provide additional customization options for the Internet library:\n\n**libUrlSetExpect100**  Allows you to set a limit to the size of data being posted before requesting a continue response from the server.\n\n**libURLSetCustomHTTPHeaders** - Sets `the header`s to be sent with each request to an HTTP server. See also the section on HTTPHeaders above.\n\n**libURLFollowHttpRedirects**  Specify that GET requests should follow HTTP redirects and GET the page redirected to.\n\n**libUrlSetAuthCallback** - Sets a callback for handling authentication with http servers and proxies.\n\n### Troubleshooting\n\nThe following commands and functions can be useful when debugging an application that uses the Internet library.\n\n**resetAll** - Closes all open sockets and halts all pending Internet operations.\n\n> **Caution:** The **resetAll** command closes all open sockets, which includes any other sockets opened by your application and any sockets in use for other uploads and downloads. Because of this, you should avoid routine use of the **resetAll** command. Consider using it only during development, to clear up connection problems during debugging.\n\n**libURLErrorData** - Returns any error that was caused during a download that was started with the load command.\n\n**libURLVersion**  Returns the version of the Internet library.\n\n**libURLSetLogField**  Specifies a field for logging information about uploads and downloads on screen.\n\n**libURLLastRHHeaders** - Returns the headers sent by the remote host in the most recent HTTP transaction.\n\n**libURLLastHTTPHeaders** - Returns the value of the httpHeadersproperty used for the previous HTTP request.\n\n## revBrowser  Rendering a Web Page within a Stack\n\nUse the revBrowser commands to render a web page within a stack. RevBrowser uses WebKit (Safari) on Mac OS X and Internet Explorer on Windows. Currently RevBrowser is not supported under Linux.\n\nTo create a browser object in a stack, use the **revBrowserOpen** function. This function takes the **windowID** for the stack you want to open the browser in and a URL. Please note that the `windowID`is not the same as the stack's ID property.\n\n```\nput the windowid of this stack into tWinID\nput revBrowserOpen(tWinID,\"http://www.google.com\")  into sBrowserId\n```\n\nTo set properties on the browser, use the **revBrowserSet** command. The following commands makes the border visible then sets the rectangle to be the same as an image named \"browserimage\":\n\n```\nrevBrowserSet sBrowserId, \"showborder\",\"true\"\nrevBrowserSet sBrowserId, \"rect\",rect of img \"browserimage\"\n```\n\nTo close a browser when you finished with it, use the **revBrowserClose** command. This command takes the `windowID`for the stack containing the browser:\n\n**revBrowserClose sBrowserId**\n\nRevBrowser supports a number of settings and messages. You can intercept a message whenever the user navigates to a link, prevent navigation, intercept clicks in the browser, requests to download files or to open a new window.\n\nTo try out all these options in an interactive format, download the *Internet workshop* from:\n\n[http://www.runrev.com/developers/exploring-LiveCode/the-internet/](http://www.runrev.com/developers/exploring-revolution/the-internet/)\n\nClick on the *Render a Web Page* example, press *Run* and then explore the *revBrowser Demo Stack*.\n\nFor a complete list of commands that operate on RevBrowser, press the *Show Docs* button in the *revBrowser Demo Stack*, or open the *LiveCode Dictionary* and type \"*browser*\" into the filter box.\n\n## SSL and Encryption\n\nLiveCode includes support for using Secure Sockets Layer and the https protocol. It also includes an industrial strength encryption library you can use to encrypt files or data transmissions.\n\n### Encrypting and Decrypting Data\n\nTo encrypt data, use the **encrypt** command. The **encrypt** command supports a wide variety of industry standard methods of encryption. The list of installed methods can be retrieved by using the **cipherNames** function. To decrypt data, use the **decrypt** command. For more information on these features, see the *LiveCode Dictionary*.\n\n> **Tip:** If you are using the encryption library on a Windows system, it is possible that another application will have installed DLLs that use the same name as the ones included with LiveCode to support encryption. You can force your application to load LiveCode's SSL DLLs by setting the $PATH environment variable before loading the library.\n\n```\nput $PATH into tOldPath\nput \\<path to SSL DLLs\\> into $PATH\nget the cipherNames -- Force loading of the SSL DLLs\nput tOldPath into $PATH\n```\n\n### Connecting using HTTPS\n\nYou may connect and download data from a URL using **https** in the same way that you access an http URL.\n\n```\nput URL \"https://www.example.com/store.php\"\n```\n\nIf there is an error, it will be placed into `the result`. If you need to include a user name and password you can do so in the following form:\n\n```\nhttps://user:password@www.example.com/\n```\n\n### Implementing your own secure protocols\n\nTo implement your own secure protocol, use the **open secure socket** variant of the **open socket** command. You can specify whether or not to include certification, a certificate and a key. For more information on the **open socket** command, see the *LiveCode Dictionary*.\n\n## Writing your own protocol with sockets\n\nIf you need to implement your own protocol, you can do so using LiveCode's socket support. To understand this chapter it is assumed you understand the basics of how the Internet works, including the concepts of sockets, IP addresses and ports. More information on these concepts can be found in Wikipedia.\n\n> **Tip:** The standard protocols that LiveCode support such as http and ftp, discussed earlier in this chapter, have all been implemented as a scripted library with LiveCode's socket support. You can examine this library by running `edit script of button \"revlibURL\" of stack \"revLibrary\"`in the Message Box. Beware, this library is not for the feint of heart. If you change anything, LiveCode's Internet commands may cease to operate.\n\n**Opening a connection**\n\nTo open a connection use the **open socket** command. The following command opens a connection to the IP address specified in the `tIPAddress`variable and the port specified in the `tPort`variable. It specifies that LiveCode should send the message \"`chatConnected`\" when a connection has been established.\n\n```\nopen socket (tIPAddress & \":\" & tPort) with message \"chatConnected\"\n```\n\nTo open a secure socket, use the **open secure socket** variant of the command. To open a UDP datagram socket, use the **open datagram socket** variant of the command. For more information on these variants, see the *LiveCode Dictionary*.\n\n**Looking up a host name or IP address**\n\nYou may look up an IP address from a host name with the **hostNameToAddress** function. For example, to get the IP address for the runrev.com server:\n\n```\nput hostNameToAddress(\"www.runrev.com\") into tIPAddress\n```\n\nTo get the host name of the local machine, use the **hostName** function. To look up the name from an IP address, use the **hostAddressToName** function.\n\n**Reading and writing data**\n\nOnce LiveCode opens a connection, it will send a `chatConnected`message. To receive data, use the **read from socket** command. The following message reads data from the socket and sends a `chatReceived`message when reading is completed.\n\n```\non chatConnected pSocket\n\tread from socket pSocket with message chatReceived\nend chatConnected\n```\n\nOnce reading from the socket is completed the `chatReceived`message can be used to process or display the data. It can then specify that it should continue to read from the socket until more data is received, sending another `chatReceived` message when done.\n\n```\non chatReceived pSocket, pData\n\tput pData after field \"chat output\"\n\tread from socket pSocket with message \"chatReceived\"\nend chatReceived\n```\n\nTo write data to the socket, use the **write** command:\n\n```\nwrite field \"chat text\" to socket tSocket\n```\n\n**Disconnecting**\n\nTo disconnect, use the **close socket** command. You should store a variable with details of any open sockets and close them when you have finished using them or when your stack closes.\n\n```\nclose socket (tIDAddress & \":\" & tPort)\n```\n\n**Listening for and accepting incoming connections**\n\nTo accept incoming connections on a given port, use the **accept connections** command. The following example tells LiveCode to listen for connections on port 1987 and send the message `chatConnected`if a connection is established. You can then start to read data from the socket in the `chatConnected`handler.\n\n```\naccept connections on port 1987 with message chatConnected\n```\n\n**Handling errors**\n\nIf there is an error, LiveCode will send a **socketError** message with the address of the socket and the error message. If a socket is closed a **socketClosed** message will be sent. If a socket times out waiting for data a **socketTimeout** message will be sent. To get a list of sockets that are open, use the **openSockets** function. You can set the default timeout interval by setting the **socketTimeOutInterval** property. For more details on all of these features, see the *LiveCode Dictionary*.\n\n> **Tip:** You can see a complete implementation of a basic client server \"chat\" application by navigating to Documentation -\\> Getting Started -\\> Sample Projects -\\> Internet Chat  creating a custom protocol using sockets -\\> Launch. Most of the scripts for the \"server\" stack are in the \"start server\" button. Most of the scripts for the client are in the stack script for the \"chat client\" stack.\n\n# Extending the Built-in Capabilities\n\nThis chapter covers how to extend the built-in capabilities of LiveCode. This topic is useful for anyone who wants to extend the feature set of LiveCode. It is also useful if you are planning to use LiveCode as a front-end to any existing application or set of processes.\n\nThere are many ways to extend LiveCode. This topic explains how to run shell commands, start other applications, read and write to processes, execute AppleScript, VBScript, send and respond to AppleEvents and communicate between multiple LiveCode-based processes. It also tells you where to get information to create external commands and functions (code written in lower level languages). We also detail how to extend the LiveCode IDE: how to create a plug-in or edit the IDE itself.\n\n## Communicating with other process and applications\n\n### Reading and writing to the command shell\n\nUse the **shell** function to run shell commands and return the result. The following example displays a directory listing on Mac OS X:\n\n```\nanswer shell(\"ls\")\n```\n\nAnd this example stores a directory listing in a variable on Windows:\n\n```\nput shell(\"dir\") into tDirectory\n```\n\nOn Windows systems you can prevent a terminal window from being displayed by setting the **hideConsoleWindows** global property to true.\n\nYou can choose a different shell program by setting the **shellPath** global property. By default this is set to \"/bin/sh\" on Mac OS X and Linux and \"command.com\" on Windows.\n\n> **Tip:** The shell function blocks LiveCode until it is completed. If you want to run a shell command in the background, write the shell script to a text file then execute it with the `launch`command.\n\n### Launching other applications\n\nUse the **launch** command to launch other applications, documents or URLs. To launch an application, supply the full path to the application. The following example opens a text document with TextEdit on OS X:\n\n```\nlaunch \"/Users/someuser/Desktop/text document.rtf\" with \"/Applications/TextEdit.app\"\n```\n\n> **Tip:** To get the path to an application, use the `answer file` command to select the application then copy it into your script. Run this in the message box: `answer file \"Select an application\"; put it`\n\nTo open a document with the application it is associated with use the **launch document** command.\n\n```\nlaunch document \"C:/My document.pdf\"\n```\n\nTo open a URL in the default web browser, use the **launch URL** command.\n\nlaunch URL \"<http://www.runrev.com/>\"\n\nFor more information on launching URLs see chapter 12. For details on how to render web pages within LiveCode, see the section on *revBrowser*.\n\n### Closing another application\n\nUse the **kill process** command to send a signal to another application, to close it or to force it to exit. For more details, see the LiveCode Dictionary.\n\n### Communicating with other processes\n\nUse the **open process** command to open an application or process you want to read and write data from. You can then read from the process with the **read from process** command and write to it with the **write to process** command. To close a process you have opened, use the **close process** command. The **openProcesses** returns a list of processes you have opened and the **openProcessIDs** returns the process IDs of each one. For more details see the *LiveCode Dictionary*.\n\n### Using AppleScript and VBScript (Open Scripting Architecture or Windows Scripting Host)\n\nTo execute commands using AppleScript on Mac OS or VBScript on Windows, use the **do as** command. **do as** also allows you to use any other *Open Scripting Architecture* languages on Mac OS or languages installed into the *Windows Scripting Host* on Windows. To retrieve a list of the available installed languages, use the **alternateLanguages**.\n\nFor example, to execute an AppleScript that brings the Finder on OS X to the front, enter the following into a field:\n\n*tell application \"Finder\"*\n*activate*\n*end tell*\n\nThen run:\n\n```\ndo field 1 as \"appleScript\"\n```\n\nTo retrieve a result from commands executed using `do as`, use `the result` function. Any error message will also be returned in `the result`. The following example displays `the result` of an addition performed using VBScript:\n\n```\ndo \"result = 1 + 1\" as \"vbscript\"\nanswer the result\n```\n\nFor more information on the do as command, see the LiveCode Dictionary.\n\n### AppleEvents\n\nTo send an AppleEvent, use the **send to program** command.\n\nIf LiveCode receives an AppleEvent it will send an **appleEvent** message to the current card. Intercept this message to perform actions such as handling a request to quit your application or opening a document. The following example shows how you could handle a request to quit:\n\n```\non appleEvent pClass, pID, pSender\n\tif pClass & pID is \"aevtquit\" then\n\t-- call a function that prompts the user to save changes\n\tput checkSaveChanges() into tOkToQuit\n\t-- returns false if the user presses \"cancel\"\n\tif tOkToQuit is true then quit\n\telse exit appleEvent\n\tend if\nend appleEvent\n```\n\nTo retrive additional information passed with the appleEvent use the **request appleEvent data** command. The following example shows how you could handle a request to open a stack:\n\n```\non appleEvent pClass, pID, pSender\n\t--appleEvent sent when stack is opened from the finder\n\tif pClass & pID is \" aevtodoc \" then\n\t\t-- get the file path(s)\n\t\trequest AppleEvent data\n\t\tput it into tFilesList\n\t\trepeat for each line l in tFilesList\n\t\t\tgo stack l\n\t\tend repeat\n\tend if\nend appleEvent\n```\n\nFor more details see the *LiveCode Dictionary*.\n\n### Using Local sockets\n\nIf you want to communicate between local applications a common technique that can be used without code changes on all the platforms LiveCode supports, is to open a local socket and communicate using that. You should choose a port number that is not used by a standard protocol  typically a high number.\n\nThis technique is commonly used when you want to create multiple programs that run independently but communicate with each other. It is a viable technique for running background tasks and provides a straightforward way to create an application that behaves as if threaded  i.e. with benefits of multiple threads. You can design your application such that additional instances can be launched to perform processing, data transfer or other intensive activities. Modern OSes will allocate each application to an appropriate processor core. By using socket messaging to communicate with each one you can keep your main application's user interface responsive and display status information. The following example shows you how to open a socket to the local machine:\n\n```\nopen socket to \"127.0.0.1:10000\" with message gotConnection\n```\n\nA detailed discussion of how to create a protocol using sockets can be found in chapter 12.\n\n> **Tip:** To simplify communication between multiple LiveCode programs, consider writing a simple library that sends and receives a handler name together with parameter data. To call a handler in the other LiveCode program, send the handler name and data to the library. The library will send the data over a socket. In the receiving program intercept the incoming data from the socket and use it to call the appropriate message with the parameter data received.\n\n## Extending the LiveCode IDE\n\nThe LiveCode IDE (integrated development environment) has been written using LiveCode. All the components  the Tools Palette, Property Inspector, Script Editor, Debugger, etc., are implemented as LiveCode stacks. The IDE has a series of library frontScripts and backScripts it uses to provide functionality both for the IDE and for your application. Some of these libraries are used only by the IDE (e.g. the debugger library), others (e.g. the Internet library, libURL) are copied into your standalone by the standalone builder.\n\nThis design makes it easy to extend the IDE with plug-ins. If you are an advanced LiveCode developer you can also edit the IDE itself to provide custom functionality.\n\n### Creating Plug-ins\n\nYou can create a plug-in to help perform tasks that you need to do regularly in the LiveCode IDE. Plug-ins are written as LiveCode stacks. (If you need to extend LiveCode using a lower level language, see the section on *Externals*, below.)\n\nTo create a plug-in, save your stack into the Plugins folder, located within the My LiveCode [Edition] folder, inside your Documents folder.\n\nYou can now load your stack by choosing its name from the Development -\\> Plugins submenu. By default your plug-in will be loaded as a palette. This allows you to operate the controls in the plug-in while the LiveCode IDE is in pointer tool mode. This allows you to create custom \"Property Inspector\" style behaviors or other object editing tools.\n\n**The Plugin Settings Screen**\n\nOpen the Plugin settings screen from the Development -\\> Plugins submenu. Choose the plugin you have created from the Plugin menu at the top of the screen to apply settings to it.\n\n![](images/image118.png)\n\nFigure 84  The Plugin Settings Screen\n\n**Open plugin when:**\n\nBy default your plugin will load when you chose it from the plugins menu. If you want to have your plugin load whenever you start LiveCode select the \"LiveCode starts up\". Use this if your plugin is used to set up your environment, for example by loading stacks that you are working on or adjusting window layout. To have your plugin load when LiveCode quits choose \"LiveCode quits\". Use this if your plugin performs clean up tasks that you want to have run whenever you exit.\n\n**Open as:**\n\nChoose the mode you want your plugin to open as. If you choose the invisible option, your plugin stack will be loaded invisible. Use this option to create a plugin that installs a faceless library (for example by inserting a button within it into the front or backscripts) or to perform some other automated task that does not require a visible user interface.\n\n> **Note:** Loading from your plugin will not allow you to edit the plugin itself. If you want to edit the plugin, first load it from the menu then use the Application Browser to make it toplevel by right clicking on it in the list of stacks and choosing Toplevel from the popup menu.\n\n**Send messages to plugin:**\n\nIn order to have your plug-in respond as you work in the IDE you need to register it to receive messages. The IDE can send a variety of messages to the current card in your plug-in as you change selection, switch tools, open and close stacks, etc. The messages that can be sent are listed below.\n\n| Message                  | Sent when                                       |\n|--------------------------|-------------------------------------------------|\n| revCloseStack            | The user closes a stack in the IDE              |\n| revEditScript            | The user chooses \"edit script\"                  |\n| revIDChanged             | The ID of an object is changed                  |\n| revMouseMove             | The mouse is moved                              |\n| revMoveControl           | A control is moved with the pointer tool        |\n| revNameChanged           | The name of an object is changed                |\n| revNewTool               | A new tool is chosen                            |\n| revPreOpenCard           | A preOpenCard message is sent on changing card  |\n| revPreOpenStack          | A preOpenStack message is sent on opening stack |\n| revResizeControl         | A control is resized using the pointer tool     |\n| revResizeStack           | A stack is resized                              |\n| revResumeStack           | A stack is activated                            |\n| revSaveStackRequest      | The save command is executed                    |\n| revSelectedObjectChanged | The selection is changed with the pointer tool  |\n| revSelectionChanged      | The text selection is changed                   |\n| revShutdown              | LiveCode is quit                                |\n\n> **Tip:** Internally the IDE implements these plugin messages by intercepting system messages sent my LiveCode in the IDE frontScripts and backScripts then sending out a corresponding message to any loaded plugin. You can look up these messages in the LiveCode Dictionary by removing the \"rev\" in front of the messages above.\n\nFor example, to have your plugin update whenever an object is selected with the pointer tool, select the `revSelectedObjectChanged`message. Then insert the following handler into your plugin card script:\n\n```\non revSelectedObjectChanged\n\t-- store the list of selected objects\n\tput the selObj into tObjectsList\n\trepeat for each line l in tObjectsList\n\t\t-- insert code to operate on each object here\n\tend repeat\nend revSelectedObjectChanged\n```\n\n### Editing the IDE\n\n> **Caution:** Editing the IDE can easily cause LiveCode to become unusable. We recommend that only advanced users attempt to edit the IDE. We recommend you back up the IDE prior to making any changes. We do not recommend attempting to edit the IDE while working on any mission critical project.\n\nTo edit the LiveCode IDE, turn on *LiveCode UI Elements in Lists* in the *View* menu. This causes LiveCode to display its own stacks within the Application Browser and other editing screens. You can now load these stacks to edit them. To allow you to edit LiveCode IDE objects with the keyboard shortcuts, turn on the *In LiveCode UI Windows* and *Contextual menus work in LiveCode Windows*, options in the *Preferences*.\n\nThe IDE uses the stack *revLibrary* to provide much of its functionality. The scripts are stored as a series of buttons and loaded into the `frontScripts`and backScripts when the IDE is started. To edit these scripts, go to the *Front Scripts* or *Back Scripts* tab within the Message Box and check the \"Show LiveCode UI Scripts\" checkbox.\n\n> **Caution:** If you make a mistake editing revFrontScript or revBackScript, LiveCode will become non-responsive and you will have to force-quit.\n\nThe Code Editor and Property Inspector functionality is provided by two stacks, *revTemplateScriptEditor* and *revTemplatePalette*. These stacks are cloned each time you open a new Script Editor or Inspector. To make permanent changes you need to apply the changes to these stacks and save them.\n\n## Externals  code written in lower level languages\n\nLiveCode provides an external interface which allows you to extend it using a lower level language (often C). For example, if you have preexisting code that performs processing in a lower level language, you can write a user interface in LiveCode and then call this library by writing a simple wrapper around it using LiveCode's externals interface. LiveCode supports transmitting data to and from externals, as well as drawing into image objects within LiveCode windows, manipulating the player object, and more.\n\n> **Note:** Some aspects of the built in functionality are supplied in the form of externals. These include the SSL library, the database library, the revBrowser library, zip library, video grabber and XML libraries. These libraries can be included in a standalone application, or excluded if they are not needed  saving disk space.\n\n### The Externals SDK\n\nWe provide a developer kit for writing externals which includes documentation and examples. You may download this kit from:\n\n<http://downloads.runrev.com/resources/externals/revexternalssdk.zip>\n\nThe following newsletter articles will also help you get started:\n\nExternal Writing for the Uninitiated  Part 1\n\n<http://www.runrev.com/developers/tutorials/advanced-externals-part-1/>\n\nExternal Writing for the Uninitiated  Part 2\n\n<http://www.runrev.com/developers/tutorials/advanced-externals-part-2/>\n\nWriting Externals for Linux with 2.9 or later\n\n<http://www.runrev.com/developers/tutorials/advanced-linux-externals/>\n\n## Building a Web Application\n\nAdditional documentation for this section is being prepared for the next version of LiveCode. In the mean time we recommend the comprehensive tutorial on this topic here:\n\n<http://www.hyperactivesw.com/cgitutorial/intro.html>\n\n# Working with Media\n\nOne of the most popular uses for LiveCode is to create full blown multimedia applications. Even if you aren't creating a traditional multimedia application, many applications require a compelling user interface.\n\nThis chapter details LiveCode's media support. We discuss the image features and capabilities: how to import and export images in a variety of formats, how to manipulate images within LiveCode, working with masks, the clipboard and screen capture, right through to animated GIFs. We detail the vector graphic features and explain how to manipulate vector graphics by script. We then cover the video and audio feature set. Then we show you how to create custom themed buttons. Finally we given an overview of the support for visual transition effects.\n\n## Bitmap Images\n\nLiveCode supports a wide variety of image formats, including the popular PNG and JPEG formats. PNG images are space efficient and have full support for alpha channels. JPEG images are good for displaying photos. For more details see the table below.\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|------------|------------|-----------------------------|--------------------------------------------------------------------------------------------------|\n| **Format** | **Export** | **Mask **                   | **Comments**                                                                                     |\n| **PNG**    | Yes        | Yes, 1-bit or alpha channel | Supports gamma adjustment, supports alpha channels, supports interlacing                         |\n| **JPEG**   | Yes        | No                          | Supports progressive JPEGs; lossy compression. Export allows you to set the level of compression |\n| **GIF**    | Yes        | 1-bit                       | GIF87a and GIF89a; supports animation; supports interlaced GIFs; maximum 256 colors              |\n| **BMP**    | No         | No                          | Uncompressed                                                                                     |\n| **PBM**    | Yes        | No                          | 1-bit (black and white)                                                                          |\n| **PGM**    | No         | No                          | Grayscale                                                                                        |\n| **PPM**    | No         | No                          |                                                                                                  |\n| **XBM**    | No         | No                          |                                                                                                  |\n| **XPM**    | No         | No                          | 1-bit (black and white)                                                                          |\n| **XWD**    | No         | No                          |                                                                                                  |\n| **PICT**   | No         | No                          | uncompressed                                                                                     |\n\nAs you can see from the table above, a number of the supported image formats can also be exported by LiveCode.\n\nYou can modify images using LiveCode's paint tools, or manipulate the binary data by script or using an external.\n\nYou can create images from any of LiveCode's native objects, including buttons, fields and graphics. These can then been exported in a number of formats. You can copy images from the clipboard or export images to the clipboard.\n\nLiveCode can capture a portion of the screen, or the entire screen.\n\n### Importing Images\n\nTo import an image, choose File -\\> Import As Control -\\> Image File. Select the image file you want to import. This will import the image file into a new image object on the current card. This is equivalent to executing the **import paint** command in the Message Box.\n\n> **Note:** If you want to reuse an image throughout your application, for example as part of a custom skin for your application, create a substack and import all your images into that. You can then reference them throughout your stack file. For more information, see the section Creating Custom Skins, below.\n\n### Importing Referenced Images\n\nTo reference an image file on disk choose File -\\> New Referenced Control -\\> Image File. This creates an image object on the current card and sets its **fileName** property to the path of the image file you selected. Referenced images do not expand the size of your stack and are only loaded from disk into memory when you navigate to the current card or otherwise display them on screen. Referenced images are ideal where you want to update the image in an image editor and see the changes in LiveCode without having to re-import.\n\nYou may wish to consider creating a folder next to your stack file to contain image files then using the Inspector to modify the file path to the image to be a referenced path. This allows you to move the stack and folder of images together onto a different system. for more information on referenced file paths, see the section *File Name Specifications and Paths*.\n\nYou can use the standalone builder to copy referenced images into a directory (updating each image's **fileName** property) or to copy referenced images into your stack. For more information see the chapter *Deploying your Application*.\n\n> **Important:** You cannot use the paint tools or manipulate the binary data of referenced images. You must import them first. If you want to modify the original file, you can make changes then export the image  see below for more details.\n\n### Import using Screen Capture\n\nTo import an image by capturing a portion of the screen, choose File -\\> Import As Control -\\> Snapshot. Select the region of the screen you want to import.\n\nTo take a screen capture by script, use the **import snapshot** command. To specify a section of the screen to import from without displaying the crosshairs use **import snapshot from rect**:\n\n```\nimport snapshot from 100,100,200,200\n```\n\nThis will create an image object on the current card from the rectangular area specified.\n\n### Creating Images\n\nTo create an image, drag an image object from the Tools palette to your stack. You may now paint on the image using the paint tools, set the `fileName`reference to an image or manipulate the binary data of the image.\n\n### Using the Paint Tools\n\nTo access the paint tools, press the fold out triangle at the bottom right of the Tools palette.\n\n![](images/image119.png)\n\nFigure 85  The Graphic Tools\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|-------------------------------|--------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|\n|                               | **Tool**           | **Usage**                                                                                                                                                                                    | **Keyboard modifiers**                                                            |\n| ![](images/image120.png) | Select             | Drag to select a rectangular area of an image                                                                                                                                                | Shift constraints to a square; command / control duplicates selection             |\n| ![](images/image121.png) | Bucket             | Fills shapes with color. Will fill any pixel connected to the pixel you click with the brush color                                                                                           | Control-click to fill with transparency                                           |\n| ![](images/image122.png) | Spray can          | Draw an airbrushed color using the brush shape                                                                                                                                               | Control-click to spray with transparency                                          |\n| ![](images/image123.png) | Eraser             | Remove color from an area leaving it transparent. Uses the brush shape                                                                                                                       |                                                                                   |\n| ![](images/image124.png) | Rectangle          | Draw a rectangle shape                                                                                                                                                                       | Shift constrains to a square; control creates transparency                        |\n| ![](images/image125.png) | Rounded rectangle  | Draw a rounded rectangle shape (hold down on the rectangle shape to select this shape)                                                                                                       | Shift constrains to a square; control creates transparency                        |\n| ![](images/image126.png) | Oval               | Draw an oval shape (hold down on the rectangle shape to select this shape)                                                                                                                   | Shift constrains to a square; control creates transparency                        |\n| ![](images/image127.png) | Regular polygon    | Draw regular polygon shape (hold down on the rectangle shape to select this shape)                                                                                                           | Shift constrains to a square; constrains rotation; control creates transparency   |\n| ![](images/image128.png) | Polygon            | Draw polygon shape (hold down on the rectangle shape to select this shape)                                                                                                                   | Shift constrains lines angles to multiples of 22.5; control creates transparency |\n| ![](images/image129.png) | Line               | Draw a straight line                                                                                                                                                                         | Shift constrains lines angles to multiples of 22.5; control creates transparency |\n| ![](images/image130.png) | Freehand           | Draw a freehand curve (hold down on the line shape to select this shape). If the filled option is chosen the beginning and end of the curve are joined automatically when you finish drawing | Alt / option prevents drawing line border; control creates transparency           |\n| ![](images/image131.png) | Pencil             | Draw a single-pixel-width freehand line                                                                                                                                                      | Control creates transparency                                                      |\n| ![](images/image132.png) | Brush              | Draw brush strokes using the brush shape                                                                                                                                                     | Control creates transparency; command click to magnify                            |\n| ![](images/image133.png) | Fill (brush) color | Select a color to fill shapes or use with the brush tools                                                                                                                                    |                                                                                   |\n| ![](images/image134.png) | Line color         | Select a color to draw lines or use with the pencil tool                                                                                                                                     |                                                                                   |\n| ![](images/image135.png) | Brush shape        | Choose a brush shape for use with the brush, eraser and airbrush tools                                                                                                                       |                                                                                   |\n\nTo magnify an image, right click it with the pointer tool and choose Magnify from the menu.\n\nWhen you edit an image, it will be recompressed into the format specified by the **paintCompression** global property.\n\n### Scripting with the Paint Tools\n\nPainting by script can be useful if you want the user to be able to see each paint action. If you want to manipulate the data of an image more efficiently off screen, see the next section.\n\nTo control the paint tools by script, create an image then choose the paint tool you want to use. Set the appropriate brush, pattern or line size then use the drag command to paint.\n\nThe following example creates an image, chooses the brush tool, selects a small circular brush shape, selects a red color, then draws a line:\n\n```\n-- set the size of the image\nset the rect of the templateImage to 100,100,400,400\ncreate image\nchoose brush tool\nset the brush to 8\nset the brushColor to red -- could use an RGB triplet here\nset the dragSpeed to 20 -- very slow\ndrag from 120,120 to 300,300\n```\n\nFor more information, see the entries for the **templateImage**, **tool**, **brush**, **brushColor**, **brushPattern**, **dragSpeed**, **penColor** and **penPattern** in the *LiveCode Dictionary*.\n\nYou may reduce the size of an image using the **crop** command.\n\nYou may rotate an image using the **rotate** command.\n\nTo adjust the quality of the scaling algorithm used when scaling an image, set the **resizeQuality** property before setting the image's rect.\n\n### Manipulating Binary Image Data\n\nTo manipulate the binary data of an image, use the image's **imageData** property. This property returns the color and transparency value of each pixel in the image in a consistent format regardless of the format the image is saved in. The `imageData`is stored as binary, with each pixel represented by 4 bytes. To convert it to and from RGB values use the `charToNum`and numToChar functions.\n\nFor example, the numeric value of the red channel for the tenth pixel is given by the expression charToNum(char ((4 \\* 9) + 2) of the imageData of image). The numeric value of the green channel is charToNum(char (4 \\* 9) + `3 of the imageData of image)`; and the numeric value of the blue channel is charToNum(char (4 \\* 9) + 4 of the imageData of image).\n\nTo manipulate the binary data of an image using an external, use the **imagePixMapID** property.\n\nWhen you set the `imageData`of an image the image will be recompressed into the format specified by the **paintCompression** global property.\n\n### Rendering an Image from Objects\n\nUse the **import snapshot** command to create an image from objects or a region of a stack. Instead of specifying a rectangle in global coordinates (as described above) specify a stack or object.\n\n> **Note:** Unlike screen capturing, the stack or object you specify to import an image from does not need to be displayed on screen. You can create a layout off screen in an invisible stack then render it into an image.\n\nTo import a snapshot of a region of a stack:\n\n```\nimport snapshot from 100,100,200,200 of stack \"Layout\"\n```\n\nTo import a snapshot of an object:\n\n```\nimport snapshot from button 5 of stack \"objects\"\n```\n\nThe import snapshot command creates a new image in the current **defaultStack**. The image is encoded using the current **paintCompression** format.\n\nTo save this snapshot directly to a file instead of creating an image, use the export snapshot command:\n```\nexport snapshot from the selectedObject to file \"snap.jpg\" as JPEG\n```\n### Exporting Images\n\nTo export an image in the current format that it is stored in, put it into a binary file using the URL commands. The following example prompts the user to select a file then export the image into it:\n\n```\nask file \"Select a file:\"\nput image \"picture\" into URL (\"binfile:\" & it)\n```\n\nTo export an image in a different format, use the **export** command.\n\n```\nexport image \"picture\" to file \"picture.png\" as PNG\n```\n\nYou may also export an image to a variable. See the **export** command in the *LiveCode Dictionary* for more information.\n\n### Copying and Pasting Images\n\nTo copy an image internally without using the system clipboard, simply put it into a variable or into another image.\n\n```\nput image 1 into image 2\n```\n\nTo recompress the image in a different format, use the **export** command to export it to a variable then put that variable into an image.\n\nTo copy an image to the clipboard, use the **copy** command.\n\n```\ncopy image 1\n```\n\nTo paste an image from the clipboard, use the **paste** command.\n\nTo transfer the binary data of an image to and from the clipboard get and set the clipBoardData[\"image\"] property. See the **clipBoardData** entry in the *LiveCode Dictionary* for more information.\n\n### Working with Animated GIFs\n\nYou can import an animated GIF image in the same way you import other images.\n\nSet the **repeatCount** property to specify how often to play the animation. Setting the `repeatCount`to 0 pauses the animation and setting it to -1 causes it to repeat forever.\n\nTo change the current frame set the **currentFrame** property.\n\n> **Note:** If you use an animated GIF as a button icon, it will play simultaneously in each button it is used for.\n\n## Working with Vector Graphics\n\nIn addition to bitmap graphics, LiveCode also supports vector graphics. You can create vector graphics using the graphics tools, or by script. You can manipulate them interactively in the IDE or by script. You can relayer them, export a description of them or convert them to bitmap format.\n\n> **Tip:** Animation Engine is a 3<sup>rd</sup> party library that includes a set of functions for programming interactive graphic animations. See the Related Software section of our web site for more information.\n\n### The Vector Graphic Tools\n\nTo see the graphic tools, unfold the triangle at the bottom right of the tools palette. The graphics tools are located above the paint tools on the tools palette. The graphic tools operate in the same way as the paint tools, except that each time you draw a shape a new graphic object is created. Unlike paint graphics, you can resize and adjust graphic objects after you have created them. For more information on the individual shapes, see the section on *Paint Tools*, above.\n\n### Creating Graphics by Script\n\nTo create graphics by script, set properties of the **templateGraphic** then use the **create graphic** command. For more information on template objects, see the section *Creating objects off screen using the template objects* in Chapter 7.\n\n### Manipulating graphics by script\n\nBecause each graphic is an individual object, you manipulate its appearance by setting properties rather than using the drag commands (as with the paint tools, above). You can control all properties of the graphic object by script including the rectangle, line and fill properties. You can change a graphic from one type to another (e.g. a rectangle to an oval) by setting its **style** property.\n\nThe polygon style of graphic has a **points** property which allows you to set the individual points of a line.\n\nSimple motion can be applied using the **move** command. For example, to move a graphic 100 pixels to the right asynchronously:\n\n```\nmove graphic 1 relative 100,0 without waiting\n```\n\nFor more information, see the **move** command in the LiveCode Dictionary.\n\nTo program a more complex animation effect, calculate the changes to the points or rectangles and set these values using timer based messaging. The following example scales a graphic named \"rectangle\" down by 100 pixels over the course of 1 second.\n\n```\nlocal sCount\n\non mouseUp\n\tput 0 into sCount\n\tscaleGraphic\nend mouseUp\n\non scaleGraphic\n\tadd 1 to sCount\n\tif sCount \\> 100 then exit scaleGraphic\n\tget the rect of graphic \"rectangle\"\n\tadd 1 to item 1 of it\n\tadd 1 to item 2 of it\n\tsubtract 1 from item 3 of it\n\tsubtract 1 from item 4 of it\n\tset the rect of graphic \"rectangle\" to it\n\tsend \"scaleGraphic\" to me in 10 milliseconds\nend scaleGraphic\n```\n\nSee the section on *Timer based messaging* for more information on using timers.\n\n## Working with Video\n\nLiveCode supports playback of video with the player object. On Windows and Mac OS, *QuickTime* is supported. QuickTime allows playback of a wide variety of file formats, including MPEG, H.264 and AAC. LiveCode also supports the controller, accessing QuickTime's streaming features and QuickTime Virtual Reality (QTVR).\n\nOn Windows systems, the player object can play back video using the *Windows Media subsystem*. This has more limited functionality than using QuickTime.\n\nOn Linux Systems, the player object can play back video using *mplayer*. There are some functionality limitations: `alwaysBuffer`, the startTime, endTime and `playSelection`properties have no effect, showController has no effect and play step forward/play step back do not work reliably.\n\nIn addition to these features, LiveCode has built-in support for the animated GIF format. Animated GIF files can be played back without 3<sup>rd</sup> party software. See above for more information. Other formats supported by plug-ins in web browsers can be played back using revBrowser (e.g. Flash). See the topic on *revBrowser* for more information.\n\n### The Player Object\n\nUse the player object to play and interact with video and audio. To create a player object, drag one onto your stack from the Tools palette. To select a movie file to play, open the Inspector for the player object and select a file to use as the source. Doing this sets the player's **fileName** property.\n\nTo *stream* a movie from an Internet server, set the fileName property to the URL address of the stream.\n\nTo play a player, use the **start** and **stop** commands.\n\n```\nstart player 1\nstop player 1\n```\n\nThe following table describes commonly used player properties:\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|--------------------------|-----------------------------------------------------------------------------------------------------------|------------------------------------------------------------|\n| **Property Name**        | **Function**                                                                                              | **Example**                                                |\n| **alwaysBuffer**         | Forces the player to be buffered, allowing objects to be drawn on top and the current frame to be printed | `set the alwaysBuffer of player 1 to true`                   |\n| **showController**       | Shows or hides the QuickTime controller                                                                   | `set the showController of player 1 to false`                |\n| **currentTime**          | Sets the current frame                                                                                    | set the currentTime of `player 1 to 1000`                    |\n| **duration & timeScale** | The duration of the movie and the number of intervals per second of a movie                               | `put (the duration of me/the timeScale of me) into tRunTime` |\n| **currentTimeChanged**   | Message sent when the current frame changes                                                               | `on currentTimeChanged pInterval`                            \n| |                                                                                                                                                                                                    \n| |                                                                                                                                        `put pInterval into field \"Time Code\"`                        \n| |                                                                                                                                                                                                    \n| |                                                                                                                                        `end currentTimeChanged`                                      |\n| **startTime**            | The start time of the selection                                                                           | `set the startTime of` player 1 to 50`0`                       |\n| **endTime**              | The end time of the selection                                                                             | set the endTime of player 1 to 1000                        |\n| **showSelection**        | Show the selection in the controller                                                                      | `set the showSelection of player 1 to true`                  |\n| **playSelection**        | Play only the selection                                                                                   | `set the playSelection of player 1 to true`                  |\n| **playRate**             | The speed to play the movie. Set this to -1 to play backwards                                             | `set the playRate of player 1 to 2`                          |\n| **looping**              | Causes playback to loop                                                                                   | `set the looping of player 1 to true`                        |\n| **playLoudness**         | Set the volume                                                                                            | set the playLoudNess of player 1 to 50                     |\n| **tracks**               | List of tracks within the movie                                                                           | `put the tracks of player 1 into tTracksList`                |\n| **enabledTracks**        | Enable or disable tracks                                                                                  | `Set the enabledTracks of player 1 to 3`                     |\n| **callbacks**            | A list of messages to be sent when the movie reaches specified time points                                | `set the callbacks of player 1 to \"1000, nextScene\"`         |\n\nThe following properties can be used to control a QTVR movie: **pan**, **tilt**, **zoom**, **currentNode**, **nodeChanged**, **hotspots**, and **hotSpotClicked**.\n\nFor more information on any of these terms, see the *LiveCode Dictionary*.\n\n### Preventing Use of QuickTime on Windows\n\nTo force LiveCode to use the Windows Media subsystem instead of QuickTime on Windows systems, even when QuickTime is installed, set the **dontUseQT** global property to true.\n\n> **Important:** You must set dontUseQT to true before you perform any movie or player related action.\n\n## Working with Sounds\n\nIn addition to playing back sound in a wide variety of formats using the player object, LiveCode has in-built support for playback of WAV, AIFF and AU format audio clips.\n\n> **Note:** We recommend you use the player object for playing audio as it supports a wide range of formats and compression types. Use the audio clip when you need basic audio playback on systems that do not have any of the 3<sup>rd</sup> party libraries supported by the player object installed.\n\n### Importing an Audio Clip\n\nTo import an audioClip choose File -\\> Import as Control -\\> Audio File. This will import the selected audio file into the current stack as an audioClip.\n\n### Playing an Audio Clip\n\nTo play an audio clip:\n\n```\nplay audioClip 1\n```\n\nTo stop playing\n\n```\nplay stop\n```\n\nTo set the volume:\n\n```\n-- sets the volume to 50%\nset the playLoudness of audioclip 1 to 50\n```\n\n## Working with Visual Transition Effects\n\nLiveCode supports visual transition effects when changing card or hiding and showing objects. There are three types of effect support: built-in effects which work on all platforms, QuickTime effects which work on systems that have QuickTime installed and Core Image effects which work on Mac OS 10.4 or later.\n\nUse the **visual effect** command to display a visual effect. To go to the next card with a dissolve transition effect:\n\n```\nvisual effect dissolve slow\ngo next card\n```\n\nTo make changes to objects on the screen with a visual effect (e.g. hide, show or move them), first lock the screen, then make the changes, then unlock the screen:\n\n```\nlock screen\nhide image 1\nshow image 3\nunlock screen with visual effect \"wipe right\"\n```\n\nTo choose a QuickTime effect using the effect chooser dialog use:\n\n```\nanswer effect\n-- store the visual effect as a custom property\nset the cEffect of this stack to it\n```\n\nThen:\n\n```\nvisual effect (the cEffect of this stack)\ngo next card\n```\n\nFor more information on visual effects, see the **visual effect** command in the *LiveCode Dictionary*. To try out the different visual effects available in an interactive format see the *Multimedia Workshop*, available at:\n\n[http://www.runrev.com/developers/exploring-LiveCode/multimedia/](http://www.runrev.com/developers/exploring-revolution/multimedia/)\n\n## Creating Custom Skins\n\nIn addition to its support for system native controls, LiveCode allows you the ability to create an entirely custom look, or skin, for your application. All of the built-in elements can be replaced with themed graphics allowing you to create rich multimedia. For example, LiveCode buttons support \"icons\" of unlimited size which can be used to replace the native appearance of a button entirely. Windows can be irregularly shaped and even contain holes and alpha mask (variable) transparency. All of LiveCode's objects support a variety of transfer modes or inks. Stacks can take over the entire screen or be displayed with a backdrop.\n\n### Custom Themed Buttons\n\nTo create a custom button, first create a regular button. Open the *Inspector* for the button and set its style to *Transparent*. Turn off the *Show Name* property. Next, switch to the *Icons & Border* pane in the Inspector. Turn off the *Hilite Border* property. You can now select any image you have imported to use as an icon for the button. To set the mouse down state, set the *hilite* icon. To set the roll over state set the *hover* icon.\n\nA button \"icon\" may be an image of any size in LiveCode, allowing a completely custom look.\n\n> **Tip:** To use the same set of images as icons throughout your stack file, create a substack and import all your theme images into it. Set the ID property of each image to a high value (between 10,000 and 100,000) so that it will be unique. You can now reference that image anywhere in your application. If you want to change theme, you only need to replace that image with another image and give it the same ID.\n\nAny object in LiveCode can behave like a button. For example, if you want to create a graphic that responds when a user clicks on it, create the graphic and add a `mouseUp`handler to it, in the same way you would with a button.\n\n### Irregular Windows\n\nTo create an irregularly shaped window, import or create an image that has a transparency mask. Then use the *Stack Inspector* to choose that image as the stack's *Shape*. To change the shape by script, set the **windowShape** property. Many modern window managers support alpha blended windows (variable degrees of transparency). To create a window with an alpha channel, import a PNG that contains an alpha channel and set the `windowShape`to this image.\n\n### Blend Modes (transfer modes or inks)\n\nBlend modes determine how an object's colors combine with the colors of the pixels underneath the object to determine how the object's color is displayed. To set the blend mode of an object, use the *Blending* pane in the *Inspector* or set the object's **ink** property. All objects in LiveCode support blend modes, with the exception of stacks.\n\n```\nset the ink of image \"picture\" to \"blendBurn\"\n```\n\nFor more information, see the **ink** entry in the LiveCode Dictionary.\n\nTo set the degree of transparency, set the object's **`blendLevel`** property. All LiveCode objects (including stacks) support `blendLevel`:\n\n```\nset the blendLevel of button 1 to 50 -- sets a button to 50% transparent\n```\n\n### Full screen mode\n\nA stack can be displayed as full screen by setting its **fullScreen** property to true:\n\n```\nset the fullScreen of this stack to true\n```\n\nSet this property back to `false`to exit full screen mode.\n\nIf you want to hide or show the menu bar on Mac OS X use the **`hide menuBar`** or **`show menuBar`** commands:\n\nhide menuBar\n\nshow menuBar\n\nSimilarly, use **hide taskbar** and **show taskbar** on Windows systems to hide and show the taskbar.\n\n### Displaying a Backdrop\n\nTo display a backdrop set the **backDrop** global property. You may set the backDrop to a solid color or to the ID of an image.\n\n```\nset the backDrop to \"black\"\n```\n\nTo remove the `backDrop`:\n\n```\nset the backDrop to none\n```\n\n| &nbsp;| &nbsp;| &nbsp;| &nbsp;|\n|------|--------|-------|-------|\n|**The Development Environment**                                             | **Windows / Linux** | **Mac OS X** |\n| Choose run (browse) tool                       | Control-9                               | Command-9                               |\n| Choose edit (pointer) tool                     | Conttrol-0                              | Command-0                               |\n| Toogle between run and edit tools              | Control-alt-tab                         | Command-option-tab                      |\n| Hide or show palettes                          | Control-tab                             | Command-control-tab                     |\n| Display context menus when running             | Control-shift-right click               | Command-control-shift-click             |\n| Save all open stacks                           | Control-alt-s                           | Command-option-s                        |\n| Apply default button in Save dialog            | Return                                  | Return                                  |\n| Apply non-default button in save dialog        | Control-1<sup>st</sup> letter of button | Command-1<sup>st</sup> letter of button |\n\n| **Navigation** |     |    |\n|------|--------|-------|\n| Go to the first card                           | Control-1                               | Command-1                               |\n| Go to the previous card                        | Control-2                               | Command-2                               |\n| Go to the next card                            | Control-3                               | Command-3                               |\n| Go to the last card                            | Control-4                               | Command-4                               |\n| Go to the recent card                          | Control-5                               | Command-5                               |\n| Go to the top or bottom of a field             | Control-up/down arrow                   | Command-up/down arrow                   |\n\n| **Objects**  |     |    |\n|------|--------|-------|\n| Select all                                     | Control-a                               | Command-a                               |\n| Duplicate                                      | Control-d                               | Command-d                               |\n| Create card                                    | Control-n                               | Command-n                               |\n| Nudge control                                  | Arrow keys                              | Arrow keys                              |\n| Nudge control by 10 pixels                     | Shift-arrow-keys                        | Shift-arrow-keys                        |\n| Open object inspector for selection            | Return                                  | Return                                  |\n| Open stack inspector                           | Control-K                               | Command-K                               |\n| Remove styles from selected text               | Control-;                               | Command-;                               |\n| Equalize heights of selected controls          | Control-shift-=                         | Command-shift-=                         |\n| Equalize width of selected controls            | Control-=                               | Command-=                               |\n| Magnify image with paint tool                  | Control-right-click                     | Command-click                           |\n| Apply transparency with paint tool             | Control-click                           | Control-click                           |\n| Constrain paint tool selection to a square     | Shift                                   | Shift                                   |\n| Constrain object aspect ratio                  | Shift                                   | Shift                                   |\n\n| **The Code Editor**  |     |    |\n|------|--------|-------|\n| Edit script of selected object                 | Control-e                               | Command-e                               |\n| Edit card script                               | Control-shift-c                         | Command-shift-c                         |\n| Edit stack script                              | Control-shift-s                         | Command-shift-s                         |\n| Edit script of object under mouse              | Control-alt-click                       | Command-option-click                    |\n| Apply changes                                  | Enter                                   | Enter                                   |\n| Apply changes and close                        | Enter twice                             | Enter twice                             |\n| Apply changes and save stack                   | Control-s                               | Command-s                               |\n| Comment out selected lines                     | Control-hyphen                          | Command-hyphen                          |\n| Remove comments                                | Control-shift-hyphen                    | Command-shift-hyphen                    |\n| Switch to find mode                            | Control-f                               | Command-f                               |\n| Find next                                      | Control-g                               | Command-g                               |\n| Find selected text                             | Control-Option-f                        | Command-Option-f                        |\n| Format current handler                         | Tab                                     | Tab                                     |\n\n| **The Message Box** |     |    |\n|------|--------|-------|\n| Open/close message box                         | Control-m                               | Command-m                               |\n| Switch to first tab in message box             | Control-m                               | Command-m                               |\n| Clear message field                            | Control-u                               | Command-u                               |\n| Scroll through recent messages (single line)   | Up/down arrow                           | Up/down arrow                           |\n| Scroll through recent messages (multiple line) | Alt-up/down arrow                       | Option-up/down arrow                    |\n| Execute message (single line)                  | Return                                  | Return                                  |\n| Execute message (multiple line)                | Enter                                   \n| |                                                                                           \n| |                                                  Control-Return                           | Enter                                   \n| |                                                                                                                                     \n| |                                                                                            Control-Return                           |\n\n| **The Debugger** |     |    |\n|------|--------|-------|\n| Step Into                                      | F11                                     | F11                                     |\n| Step Over                                      | F10                                     | F10                                     |\n| Step Out                                       | Shift-F11                               | Shift-F11                               |\n| Run                                            | F5                                      | F5                                      |\n| Stop                                           | Shift-F5                                | Shift-F5                                |\n| Abort                                          | Control-.                               | Command-.                               |\n\n\n"
	}